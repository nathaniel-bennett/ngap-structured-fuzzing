#![allow(non_camel_case_types)]
#![allow(dead_code)]
use asn1_codecs::Asn1Choice;
use bitvec::prelude::*;
use entropic::prelude::*;

pub const ID_AMF_TNL_ASSOCIATION_FAILED_TO_SETUP_LIST: u16 = 4;

pub const ID_AMF_TNL_ASSOCIATION_SETUP_LIST: u16 = 5;

pub const ID_AMF_TNL_ASSOCIATION_TO_ADD_LIST: u16 = 6;

pub const ID_AMF_TNL_ASSOCIATION_TO_REMOVE_LIST: u16 = 7;

pub const ID_AMF_TNL_ASSOCIATION_TO_UPDATE_LIST: u16 = 8;

pub const ID_AMF_UE_NGAP_ID: u16 = 10;

pub const ID_AMFCP_RELOCATION_INDICATION: u8 = 64;

pub const ID_AMF_CONFIGURATION_UPDATE: u8 = 0;

pub const ID_AMF_NAME: u16 = 1;

pub const ID_AMF_OVERLOAD_RESPONSE: u16 = 2;

pub const ID_AMF_SET_ID: u16 = 3;

pub const ID_AMF_STATUS_INDICATION: u8 = 1;

pub const ID_AMF_TRAFFIC_LOAD_REDUCTION_INDICATION: u16 = 9;

pub const ID_ADDITIONAL_DL_FORWARDING_UPTNL_INFORMATION: u16 = 152;

pub const ID_ADDITIONAL_DL_QOS_FLOW_PER_TNL_INFORMATION: u16 = 155;

pub const ID_ADDITIONAL_DLUPTNL_INFORMATION_FOR_HO_LIST: u16 = 153;

pub const ID_ADDITIONAL_NGU_UP_TNL_INFORMATION: u16 = 154;

pub const ID_ADDITIONAL_REDUNDANT_DL_NGU_UP_TNL_INFORMATION: u16 = 183;

pub const ID_ADDITIONAL_REDUNDANT_DL_QOS_FLOW_PER_TNL_INFORMATION: u16 = 184;

pub const ID_ADDITIONAL_REDUNDANT_NGU_UP_TNL_INFORMATION: u16 = 185;

pub const ID_ADDITIONAL_REDUNDANT_UL_NGU_UP_TNL_INFORMATION: u16 = 186;

pub const ID_ADDITIONAL_UL_NGU_UP_TNL_INFORMATION: u16 = 126;

pub const ID_ADDITIONAL_UL_FORWARDING_UPTNL_INFORMATION: u16 = 172;

pub const ID_ALLOWED_NSSAI: u16 = 0;

pub const ID_ALTERNATIVE_QO_S_PARA_SET_LIST: u16 = 220;

pub const ID_ASSISTANCE_DATA_FOR_PAGING: u16 = 11;

pub const ID_AUTHENTICATED_INDICATION: u16 = 245;

pub const ID_BROADCAST_CANCELLED_AREA_LIST: u16 = 12;

pub const ID_BROADCAST_COMPLETED_AREA_LIST: u16 = 13;

pub const ID_BURST_ARRIVAL_TIME_DOWNLINK: u16 = 279;

pub const ID_C_EMODE_B_SUPPORT_INDICATOR: u16 = 224;

pub const ID_C_EMODE_BRESTRICTED: u16 = 222;

pub const ID_CN_ASSISTED_RAN_TUNING: u16 = 165;

pub const ID_CN_PACKET_DELAY_BUDGET_DL: u16 = 187;

pub const ID_CN_PACKET_DELAY_BUDGET_UL: u16 = 188;

pub const ID_CN_TYPE_RESTRICTIONS_FOR_EQUIVALENT: u16 = 160;

pub const ID_CN_TYPE_RESTRICTIONS_FOR_SERVING: u16 = 161;

pub const ID_CANCEL_ALL_WARNING_MESSAGES: u16 = 14;

pub const ID_CAUSE: u16 = 15;

pub const ID_CELL_ID_LIST_FOR_RESTART: u16 = 16;

pub const ID_CELL_TRAFFIC_TRACE: u8 = 2;

pub const ID_COMMON_NETWORK_INSTANCE: u16 = 166;

pub const ID_CONCURRENT_WARNING_MESSAGE_IND: u16 = 17;

pub const ID_CONFIGURED_TAC_INDICATION: u16 = 272;

pub const ID_CONNECTION_ESTABLISHMENT_INDICATION: u8 = 65;

pub const ID_CORE_NETWORK_ASSISTANCE_INFORMATION_FOR_INACTIVE: u16 = 18;

pub const ID_CRITICALITY_DIAGNOSTICS: u16 = 19;

pub const ID_CURRENT_QO_S_PARA_SET_INDEX: u16 = 221;

pub const ID_DAPS_REQUEST_INFO: u16 = 266;

pub const ID_DAPS_RESPONSE_INFO_LIST: u16 = 267;

pub const ID_DL_CP_SECURITY_INFORMATION: u16 = 212;

pub const ID_DL_NGU_UP_TNL_INFORMATION: u16 = 128;

pub const ID_DATA_CODING_SCHEME: u16 = 20;

pub const ID_DATA_FORWARDING_NOT_POSSIBLE: u16 = 127;

pub const ID_DATA_FORWARDING_RESPONSE_ERAB_LIST: u16 = 249;

pub const ID_DEACTIVATE_TRACE: u8 = 3;

pub const ID_DEFAULT_PAGING_DRX: u16 = 21;

pub const ID_DIRECT_FORWARDING_PATH_AVAILABILITY: u16 = 22;

pub const ID_DOWNLINK_NAS_TRANSPORT: u8 = 4;

pub const ID_DOWNLINK_NON_UE_ASSOCIATED_NRP_PA_TRANSPORT: u8 = 5;

pub const ID_DOWNLINK_RAN_CONFIGURATION_TRANSFER: u8 = 6;

pub const ID_DOWNLINK_RAN_EARLY_STATUS_TRANSFER: u8 = 63;

pub const ID_DOWNLINK_RAN_STATUS_TRANSFER: u8 = 7;

pub const ID_DOWNLINK_RIM_INFORMATION_TRANSFER: u8 = 54;

pub const ID_DOWNLINK_UE_ASSOCIATED_NRP_PA_TRANSPORT: u8 = 8;

pub const ID_EDT_SESSION: u16 = 227;

pub const ID_ENDC_SON_CONFIGURATION_TRANSFER_DL: u16 = 157;

pub const ID_ENDC_SON_CONFIGURATION_TRANSFER_UL: u16 = 158;

pub const ID_EUTRA_CGI: u16 = 25;

pub const ID_EARLY_STATUS_TRANSFER_TRANSPARENT_CONTAINER: u16 = 268;

pub const ID_EMERGENCY_AREA_ID_LIST_FOR_RESTART: u16 = 23;

pub const ID_EMERGENCY_FALLBACK_INDICATOR: u16 = 24;

pub const ID_END_INDICATION: u16 = 226;

pub const ID_ENDPOINT_IP_ADDRESS_AND_PORT: u16 = 169;

pub const ID_ENHANCED_COVERAGE_RESTRICTION: u16 = 205;

pub const ID_ERROR_INDICATION: u8 = 9;

pub const ID_EXTENDED_AMF_NAME: u16 = 274;

pub const ID_EXTENDED_CONNECTED_TIME: u16 = 206;

pub const ID_EXTENDED_RAN_NODE_NAME: u16 = 273;

pub const ID_EXTENDED_PACKET_DELAY_BUDGET: u16 = 189;

pub const ID_EXTENDED_RAT_RESTRICTION_INFORMATION: u16 = 180;

pub const ID_EXTENDED_SLICE_SUPPORT_LIST: u16 = 270;

pub const ID_EXTENDED_TAI_SLICE_SUPPORT_LIST: u16 = 271;

pub const ID_EXTENDED_UE_IDENTITY_INDEX_VALUE: u16 = 280;

pub const ID_FIVE_G_S_TMSI: u16 = 26;

pub const ID_GUAMI: u16 = 28;

pub const ID_GUAMI_TYPE: u16 = 176;

pub const ID_GLOBAL_CABLE_ID: u16 = 275;

pub const ID_GLOBAL_RAN_NODE_ID: u16 = 27;

pub const ID_GLOBAL_TNGF_ID: u16 = 240;

pub const ID_GLOBAL_TWIF_ID: u16 = 241;

pub const ID_GLOBAL_W_AGF_ID: u16 = 242;

pub const ID_HANDOVER_CANCEL: u8 = 10;

pub const ID_HANDOVER_FLAG: u16 = 143;

pub const ID_HANDOVER_NOTIFICATION: u8 = 11;

pub const ID_HANDOVER_PREPARATION: u8 = 12;

pub const ID_HANDOVER_RESOURCE_ALLOCATION: u8 = 13;

pub const ID_HANDOVER_SUCCESS: u8 = 61;

pub const ID_HANDOVER_TYPE: u16 = 29;

pub const ID_IAB_AUTHORIZED: u16 = 199;

pub const ID_IAB_SUPPORTED: u16 = 200;

pub const ID_IAB_NODE_INDICATION: u16 = 201;

pub const ID_IMS_VOICE_SUPPORT_INDICATOR: u16 = 30;

pub const ID_INDEX_TO_RFSP: u16 = 31;

pub const ID_INFO_ON_RECOMMENDED_CELLS_AND_RAN_NODES_FOR_PAGING: u16 = 32;

pub const ID_INITIAL_CONTEXT_SETUP: u8 = 14;

pub const ID_INITIAL_UE_MESSAGE: u8 = 15;

pub const ID_INTERSYSTEM_SON_CONFIGURATION_TRANSFER_DL: u16 = 250;

pub const ID_INTERSYSTEM_SON_CONFIGURATION_TRANSFER_UL: u16 = 251;

pub const ID_LTEM_INDICATION: u16 = 225;

pub const ID_LTEUE_SIDELINK_AGGREGATE_MAXIMUM_BITRATE: u16 = 217;

pub const ID_LTEV2X_SERVICES_AUTHORIZED: u16 = 215;

pub const ID_LAST_EUTRAN_PLMN_IDENTITY: u16 = 150;

pub const ID_LOCATION_REPORT: u8 = 18;

pub const ID_LOCATION_REPORTING_ADDITIONAL_INFO: u16 = 170;

pub const ID_LOCATION_REPORTING_CONTROL: u8 = 16;

pub const ID_LOCATION_REPORTING_FAILURE_INDICATION: u8 = 17;

pub const ID_LOCATION_REPORTING_REQUEST_TYPE: u16 = 33;

pub const ID_MDT_CONFIGURATION: u16 = 255;

pub const ID_MANAGEMENT_BASED_MDTPLMN_LIST: u16 = 254;

pub const ID_MASKED_IMEISV: u16 = 34;

pub const ID_MAXIMUM_INTEGRITY_PROTECTED_DATA_RATE_DL: u16 = 151;

pub const ID_MESSAGE_IDENTIFIER: u16 = 35;

pub const ID_MOBILITY_RESTRICTION_LIST: u16 = 36;

pub const ID_NAS_PDU: u16 = 38;

pub const ID_NASC: u16 = 37;

pub const ID_NAS_NON_DELIVERY_INDICATION: u8 = 19;

pub const ID_NAS_SECURITY_PARAMETERS_FROM_NGRAN: u16 = 39;

pub const ID_NB_IO_T_DEFAULT_PAGING_DRX: u16 = 204;

pub const ID_NB_IO_T_PAGING_E_DRX_INFO: u16 = 203;

pub const ID_NB_IO_T_PAGING_DRX: u16 = 202;

pub const ID_NB_IO_T_UE_PRIORITY: u16 = 210;

pub const ID_NGAP_MESSAGE: u16 = 42;

pub const ID_NGRAN_CGI: u16 = 43;

pub const ID_NGRAN_TNL_ASSOCIATION_TO_REMOVE_LIST: u16 = 167;

pub const ID_NGRAN_TRACE_ID: u16 = 44;

pub const ID_NG_RESET: u8 = 20;

pub const ID_NG_SETUP: u8 = 21;

pub const ID_NID: u16 = 263;

pub const ID_NPN_ACCESS_INFORMATION: u16 = 259;

pub const ID_NPN_MOBILITY_INFORMATION: u16 = 261;

pub const ID_NPN_PAGING_ASSISTANCE_INFORMATION: u16 = 260;

pub const ID_NPN_SUPPORT: u16 = 258;

pub const ID_NR_CGI: u16 = 45;

pub const ID_NRP_PA_PDU: u16 = 46;

pub const ID_NRUE_SIDELINK_AGGREGATE_MAXIMUM_BITRATE: u16 = 218;

pub const ID_NRV2X_SERVICES_AUTHORIZED: u16 = 216;

pub const ID_NETWORK_INSTANCE: u16 = 129;

pub const ID_NEW_AMF_UE_NGAP_ID: u16 = 40;

pub const ID_NEW_GUAMI: u16 = 162;

pub const ID_NEW_SECURITY_CONTEXT_IND: u16 = 41;

pub const ID_NOTIFY_SOURCE_NGRAN_NODE: u16 = 269;

pub const ID_NUMBER_OF_BROADCASTS_REQUESTED: u16 = 47;

pub const ID_OLD_AMF: u16 = 48;

pub const ID_OLD_ASSOCIATED_QOS_FLOW_LIST_U_LENDMARKEREXPECTED: u16 = 159;

pub const ID_OVERLOAD_START: u8 = 22;

pub const ID_OVERLOAD_START_NSSAI_LIST: u16 = 49;

pub const ID_OVERLOAD_STOP: u8 = 23;

pub const ID_PC5_QO_S_PARAMETERS: u16 = 219;

pub const ID_PDU_SESSION_AGGREGATE_MAXIMUM_BIT_RATE: u16 = 130;

pub const ID_PDU_SESSION_RESOURCE_ADMITTED_LIST: u16 = 53;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_MODIFY_LIST_MOD_CFM: u16 = 131;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_MODIFY_LIST_MOD_RES: u16 = 54;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_RESUME_LIST_RES_REQ: u16 = 229;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_RESUME_LIST_RES_RES: u16 = 230;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_SETUP_LIST_CXT_FAIL: u16 = 132;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_SETUP_LIST_CXT_RES: u16 = 55;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_SETUP_LIST_HO_ACK: u16 = 56;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_SETUP_LIST_PS_REQ: u16 = 57;

pub const ID_PDU_SESSION_RESOURCE_FAILED_TO_SETUP_LIST_SU_RES: u16 = 58;

pub const ID_PDU_SESSION_RESOURCE_HANDOVER_LIST: u16 = 59;

pub const ID_PDU_SESSION_RESOURCE_LIST_CXT_REL_CPL: u16 = 60;

pub const ID_PDU_SESSION_RESOURCE_LIST_CXT_REL_REQ: u16 = 133;

pub const ID_PDU_SESSION_RESOURCE_LIST_HO_RQD: u16 = 61;

pub const ID_PDU_SESSION_RESOURCE_MODIFY: u8 = 26;

pub const ID_PDU_SESSION_RESOURCE_MODIFY_INDICATION: u8 = 27;

pub const ID_PDU_SESSION_RESOURCE_MODIFY_LIST_MOD_CFM: u16 = 62;

pub const ID_PDU_SESSION_RESOURCE_MODIFY_LIST_MOD_IND: u16 = 63;

pub const ID_PDU_SESSION_RESOURCE_MODIFY_LIST_MOD_REQ: u16 = 64;

pub const ID_PDU_SESSION_RESOURCE_MODIFY_LIST_MOD_RES: u16 = 65;

pub const ID_PDU_SESSION_RESOURCE_NOTIFY: u8 = 30;

pub const ID_PDU_SESSION_RESOURCE_NOTIFY_LIST: u16 = 66;

pub const ID_PDU_SESSION_RESOURCE_RELEASE: u8 = 28;

pub const ID_PDU_SESSION_RESOURCE_RELEASE_RESPONSE_TRANSFER: u16 = 145;

pub const ID_PDU_SESSION_RESOURCE_RELEASED_LIST_NOT: u16 = 67;

pub const ID_PDU_SESSION_RESOURCE_RELEASED_LIST_PS_ACK: u16 = 68;

pub const ID_PDU_SESSION_RESOURCE_RELEASED_LIST_PS_FAIL: u16 = 69;

pub const ID_PDU_SESSION_RESOURCE_RELEASED_LIST_REL_RES: u16 = 70;

pub const ID_PDU_SESSION_RESOURCE_RESUME_LIST_RES_REQ: u16 = 232;

pub const ID_PDU_SESSION_RESOURCE_RESUME_LIST_RES_RES: u16 = 233;

pub const ID_PDU_SESSION_RESOURCE_SECONDARY_RAT_USAGE_LIST: u16 = 142;

pub const ID_PDU_SESSION_RESOURCE_SETUP: u8 = 29;

pub const ID_PDU_SESSION_RESOURCE_SETUP_LIST_CXT_REQ: u16 = 71;

pub const ID_PDU_SESSION_RESOURCE_SETUP_LIST_CXT_RES: u16 = 72;

pub const ID_PDU_SESSION_RESOURCE_SETUP_LIST_HO_REQ: u16 = 73;

pub const ID_PDU_SESSION_RESOURCE_SETUP_LIST_SU_REQ: u16 = 74;

pub const ID_PDU_SESSION_RESOURCE_SETUP_LIST_SU_RES: u16 = 75;

pub const ID_PDU_SESSION_RESOURCE_SUSPEND_LIST_SUS_REQ: u16 = 231;

pub const ID_PDU_SESSION_RESOURCE_SWITCHED_LIST: u16 = 77;

pub const ID_PDU_SESSION_RESOURCE_TO_BE_SWITCHED_DL_LIST: u16 = 76;

pub const ID_PDU_SESSION_RESOURCE_TO_RELEASE_LIST_HO_CMD: u16 = 78;

pub const ID_PDU_SESSION_RESOURCE_TO_RELEASE_LIST_REL_CMD: u16 = 79;

pub const ID_PDU_SESSION_TYPE: u16 = 134;

pub const ID_PLMN_SUPPORT_LIST: u16 = 80;

pub const ID_PS_CELL_INFORMATION: u16 = 149;

pub const ID_PWS_CANCEL: u8 = 32;

pub const ID_PWS_FAILED_CELL_ID_LIST: u16 = 81;

pub const ID_PWS_FAILURE_INDICATION: u8 = 33;

pub const ID_PWS_RESTART_INDICATION: u8 = 34;

pub const ID_PAGING: u8 = 24;

pub const ID_PAGING_ASSIS_DATAFOR_C_ECAPAB_UE: u16 = 207;

pub const ID_PAGING_DRX: u16 = 50;

pub const ID_PAGING_ORIGIN: u16 = 51;

pub const ID_PAGING_PRIORITY: u16 = 52;

pub const ID_PAGINGE_DRX_INFORMATION: u16 = 223;

pub const ID_PATH_SWITCH_REQUEST: u8 = 25;

pub const ID_PRIVACY_INDICATOR: u16 = 256;

pub const ID_PRIVATE_MESSAGE: u8 = 31;

pub const ID_QOS_FLOW_ADD_OR_MODIFY_REQUEST_LIST: u16 = 135;

pub const ID_QOS_FLOW_FEEDBACK_LIST: u16 = 278;

pub const ID_QOS_FLOW_PARAMETERS_LIST: u16 = 277;

pub const ID_QOS_FLOW_SETUP_REQUEST_LIST: u16 = 136;

pub const ID_QOS_FLOW_TO_RELEASE_LIST: u16 = 137;

pub const ID_QOS_MONITORING_REPORTING_FREQUENCY: u16 = 276;

pub const ID_QOS_MONITORING_REQUEST: u16 = 181;

pub const ID_RAN_UE_NGAP_ID: u16 = 85;

pub const ID_RANCP_RELOCATION_INDICATION: u8 = 57;

pub const ID_RAN_CONFIGURATION_UPDATE: u8 = 35;

pub const ID_RAN_NODE_NAME: u16 = 82;

pub const ID_RAN_PAGING_PRIORITY: u16 = 83;

pub const ID_RAN_STATUS_TRANSFER_TRANSPARENT_CONTAINER: u16 = 84;

pub const ID_RAT_INFORMATION: u16 = 179;

pub const ID_RG_LEVEL_WIRELINE_ACCESS_CHARACTERISTICS: u16 = 238;

pub const ID_RIM_INFORMATION_TRANSFER: u16 = 175;

pub const ID_RRC_RESUME_CAUSE: u16 = 237;

pub const ID_RRC_ESTABLISHMENT_CAUSE: u16 = 90;

pub const ID_RRC_INACTIVE_TRANSITION_REPORT: u8 = 37;

pub const ID_RRC_INACTIVE_TRANSITION_REPORT_REQUEST: u16 = 91;

pub const ID_RRC_STATE: u16 = 92;

pub const ID_REDIRECTION_VOICE_FALLBACK: u16 = 146;

pub const ID_REDUNDANT_COMMON_NETWORK_INSTANCE: u16 = 190;

pub const ID_REDUNDANT_DL_NGU_TNL_INFORMATION_REUSED: u16 = 191;

pub const ID_REDUNDANT_DL_NGU_UP_TNL_INFORMATION: u16 = 192;

pub const ID_REDUNDANT_DL_QOS_FLOW_PER_TNL_INFORMATION: u16 = 193;

pub const ID_REDUNDANT_PDU_SESSION_INFORMATION: u16 = 197;

pub const ID_REDUNDANT_QOS_FLOW_INDICATOR: u16 = 194;

pub const ID_REDUNDANT_UL_NGU_UP_TNL_INFORMATION: u16 = 195;

pub const ID_RELATIVE_AMF_CAPACITY: u16 = 86;

pub const ID_REPETITION_PERIOD: u16 = 87;

pub const ID_REROUTE_NAS_REQUEST: u8 = 36;

pub const ID_RESET_TYPE: u16 = 88;

pub const ID_RETRIEVE_UE_INFORMATION: u8 = 55;

pub const ID_ROUTING_ID: u16 = 89;

pub const ID_S_NSSAI: u16 = 148;

pub const ID_SCTP_TL_AS: u16 = 173;

pub const ID_SON_CONFIGURATION_TRANSFER_DL: u16 = 98;

pub const ID_SON_CONFIGURATION_TRANSFER_UL: u16 = 99;

pub const ID_SON_INFORMATION_REPORT: u16 = 252;

pub const ID_SRVCC_OPERATION_POSSIBLE: u16 = 177;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT: u8 = 52;

pub const ID_SECONDARY_RAT_USAGE_INFORMATION: u16 = 144;

pub const ID_SECURITY_CONTEXT: u16 = 93;

pub const ID_SECURITY_INDICATION: u16 = 138;

pub const ID_SECURITY_KEY: u16 = 94;

pub const ID_SECURITY_RESULT: u16 = 156;

pub const ID_SELECTED_PLMN_IDENTITY: u16 = 174;

pub const ID_SERIAL_NUMBER: u16 = 95;

pub const ID_SERVED_GUAMI_LIST: u16 = 96;

pub const ID_SG_NB_UE_X2AP_ID: u16 = 182;

pub const ID_SLICE_SUPPORT_LIST: u16 = 97;

pub const ID_SOURCE_AMF_UE_NGAP_ID: u16 = 100;

pub const ID_SOURCE_TO_TARGET_AMF_INFORMATION_REROUTE: u16 = 171;

pub const ID_SOURCE_TO_TARGET_TRANSPARENT_CONTAINER: u16 = 101;

pub const ID_SUPPORTED_TA_LIST: u16 = 102;

pub const ID_SUSPEND_REQUEST_INDICATION: u16 = 235;

pub const ID_SUSPEND_RESPONSE_INDICATION: u16 = 236;

pub const ID_TAI: u16 = 213;

pub const ID_TAI_LIST_FOR_PAGING: u16 = 103;

pub const ID_TAI_LIST_FOR_RESTART: u16 = 104;

pub const ID_TNGF_IDENTITY_INFORMATION: u16 = 246;

pub const ID_TNL_ASSOCIATION_TRANSPORT_LAYER_ADDRESS_NGRAN: u16 = 168;

pub const ID_TSC_TRAFFIC_CHARACTERISTICS: u16 = 196;

pub const ID_TWIF_IDENTITY_INFORMATION: u16 = 247;

pub const ID_TARGET_ID: u16 = 105;

pub const ID_TARGET_RNC_ID: u16 = 178;

pub const ID_TARGET_TO_SOURCE_TRANSPARENT_CONTAINER: u16 = 106;

pub const ID_TARGETTO_SOURCE_FAILURE_TRANSPARENT_CONTAINER: u16 = 262;

pub const ID_TIME_TO_WAIT: u16 = 107;

pub const ID_TRACE_ACTIVATION: u16 = 108;

pub const ID_TRACE_COLLECTION_ENTITY_IP_ADDRESS: u16 = 109;

pub const ID_TRACE_COLLECTION_ENTITY_URI: u16 = 257;

pub const ID_TRACE_FAILURE_INDICATION: u8 = 38;

pub const ID_TRACE_START: u8 = 39;

pub const ID_UE_DIFFERENTIATION_INFO: u16 = 209;

pub const ID_UE_NGAP_I_DS: u16 = 114;

pub const ID_UE_UP_C_IO_T_SUPPORT: u16 = 234;

pub const ID_UE_ASSOCIATED_LOGICAL_NG_CONNECTION_LIST: u16 = 111;

pub const ID_UE_AGGREGATE_MAXIMUM_BIT_RATE: u16 = 110;

pub const ID_UE_CAPABILITY_INFO_REQUEST: u16 = 228;

pub const ID_UE_CONTEXT_MODIFICATION: u8 = 40;

pub const ID_UE_CONTEXT_RELEASE: u8 = 41;

pub const ID_UE_CONTEXT_RELEASE_REQUEST: u8 = 42;

pub const ID_UE_CONTEXT_REQUEST: u16 = 112;

pub const ID_UE_CONTEXT_RESUME: u8 = 58;

pub const ID_UE_CONTEXT_SUSPEND: u8 = 59;

pub const ID_UE_HISTORY_INFORMATION_FROM_THE_UE: u16 = 253;

pub const ID_UE_INFORMATION_TRANSFER: u8 = 56;

pub const ID_UE_PAGING_IDENTITY: u16 = 115;

pub const ID_UE_PRESENCE_IN_AREA_OF_INTEREST_LIST: u16 = 116;

pub const ID_UE_RADIO_CAPABILITY: u16 = 117;

pub const ID_UE_RADIO_CAPABILITY_EUTRA_FORMAT: u16 = 265;

pub const ID_UE_RADIO_CAPABILITY_CHECK: u8 = 43;

pub const ID_UE_RADIO_CAPABILITY_FOR_PAGING: u16 = 118;

pub const ID_UE_RADIO_CAPABILITY_FOR_PAGING_OF_NB_IO_T: u16 = 214;

pub const ID_UE_RADIO_CAPABILITY_ID: u16 = 264;

pub const ID_UE_RADIO_CAPABILITY_ID_MAPPING: u8 = 60;

pub const ID_UE_RADIO_CAPABILITY_INFO_INDICATION: u8 = 44;

pub const ID_UE_RETENTION_INFORMATION: u16 = 147;

pub const ID_UE_SECURITY_CAPABILITIES: u16 = 119;

pub const ID_UETNLA_BINDING_RELEASE: u8 = 45;

pub const ID_UL_CP_SECURITY_INFORMATION: u16 = 211;

pub const ID_UL_NGU_UP_TNL_INFORMATION: u16 = 139;

pub const ID_UL_NGU_UP_TNL_MODIFY_LIST: u16 = 140;

pub const ID_UL_FORWARDING: u16 = 163;

pub const ID_UL_FORWARDING_UP_TNL_INFORMATION: u16 = 164;

pub const ID_UNAVAILABLE_GUAMI_LIST: u16 = 120;

pub const ID_UPLINK_NAS_TRANSPORT: u8 = 46;

pub const ID_UPLINK_NON_UE_ASSOCIATED_NRP_PA_TRANSPORT: u8 = 47;

pub const ID_UPLINK_RAN_CONFIGURATION_TRANSFER: u8 = 48;

pub const ID_UPLINK_RAN_EARLY_STATUS_TRANSFER: u8 = 62;

pub const ID_UPLINK_RAN_STATUS_TRANSFER: u8 = 49;

pub const ID_UPLINK_RIM_INFORMATION_TRANSFER: u8 = 53;

pub const ID_UPLINK_UE_ASSOCIATED_NRP_PA_TRANSPORT: u8 = 50;

pub const ID_USED_RSN_INFORMATION: u16 = 198;

pub const ID_USER_LOCATION_INFORMATION: u16 = 121;

pub const ID_USER_LOCATION_INFORMATION_TNGF: u16 = 244;

pub const ID_USER_LOCATION_INFORMATION_TWIF: u16 = 248;

pub const ID_USER_LOCATION_INFORMATION_W_AGF: u16 = 243;

pub const ID_W_AGF_IDENTITY_INFORMATION: u16 = 239;

pub const ID_WUS_ASSISTANCE_INFORMATION: u16 = 208;

pub const ID_WARNING_AREA_COORDINATES: u16 = 141;

pub const ID_WARNING_AREA_LIST: u16 = 122;

pub const ID_WARNING_MESSAGE_CONTENTS: u16 = 123;

pub const ID_WARNING_SECURITY_INFO: u16 = 124;

pub const ID_WARNING_TYPE: u16 = 125;

pub const ID_WRITE_REPLACE_WARNING: u8 = 51;

pub const MAX_NRARFCN: i64 = 3279165;

pub const MAX_PRIVATE_I_ES: i64 = 65535;

pub const MAX_PROTOCOL_EXTENSIONS: i64 = 65535;

pub const MAX_PROTOCOL_I_ES: i64 = 65535;

pub const MAXNOOF_ALLOWED_AREAS: i64 = 16;

pub const MAXNOOF_ALLOWED_CA_GSPER_PLMN: i64 = 256;

pub const MAXNOOF_ALLOWED_S_NSSA_IS: i64 = 8;

pub const MAXNOOF_AO_I: i64 = 64;

pub const MAXNOOF_BPLM_NS: i64 = 12;

pub const MAXNOOF_BLUETOOTH_NAME: i64 = 4;

pub const MAXNOOF_CAG_SPER_CELL: i64 = 64;

pub const MAXNOOF_CANDIDATE_CELLS: i64 = 32;

pub const MAXNOOF_CELL_I_DFOR_MDT: i64 = 32;

pub const MAXNOOF_CELL_I_DFOR_WARNING: i64 = 65535;

pub const MAXNOOF_CELLIN_AO_I: i64 = 256;

pub const MAXNOOF_CELLIN_EAI: i64 = 65535;

pub const MAXNOOF_CELLIN_TAI: i64 = 65535;

pub const MAXNOOF_CELLS_UE_MOVING_TRAJECTORY: i64 = 16;

pub const MAXNOOF_CELLSIN_UE_HISTORY_INFO: i64 = 16;

pub const MAXNOOF_CELLSING_NB: i64 = 16384;

pub const MAXNOOF_CELLSINNGE_NB: i64 = 256;

pub const MAXNOOF_DR_BS: i64 = 32;

pub const MAXNOOF_E_RA_BS: i64 = 256;

pub const MAXNOOF_EA_IFOR_RESTART: i64 = 256;

pub const MAXNOOF_EPLM_NS: i64 = 15;

pub const MAXNOOF_EPLM_NS_PLUS_ONE: i64 = 16;

pub const MAXNOOF_EMERGENCY_AREA_ID: i64 = 65535;

pub const MAXNOOF_ERRORS: i64 = 256;

pub const MAXNOOF_EXT_SLICE_ITEMS: i64 = 65535;

pub const MAXNOOF_FORB_TA_CS: i64 = 4096;

pub const MAXNOOF_FREQFOR_MDT: i64 = 8;

pub const MAXNOOF_MDTPLM_NS: i64 = 16;

pub const MAXNOOF_MULTI_CONNECTIVITY: i64 = 4;

pub const MAXNOOF_MULTI_CONNECTIVITY_MINUS_ONE: i64 = 3;

pub const MAXNOOF_NG_CONNECTIONS_TO_RESET: i64 = 65536;

pub const MAXNOOF_NR_CELL_BANDS: i64 = 32;

pub const MAXNOOF_NEIGH_PC_IFOR_MDT: i64 = 32;

pub const MAXNOOF_PC5_QO_S_FLOWS: i64 = 2048;

pub const MAXNOOF_PDU_SESSIONS: i64 = 256;

pub const MAXNOOF_PLM_NS: i64 = 12;

pub const MAXNOOF_QOS_FLOWS: i64 = 64;

pub const MAXNOOF_QOS_PARA_SETS: i64 = 8;

pub const MAXNOOF_RAN_NODEIN_AO_I: i64 = 64;

pub const MAXNOOF_RECOMMENDED_CELLS: i64 = 16;

pub const MAXNOOF_RECOMMENDED_RAN_NODES: i64 = 16;

pub const MAXNOOF_SENSOR_NAME: i64 = 3;

pub const MAXNOOF_SERVED_GUAM_IS: i64 = 256;

pub const MAXNOOF_SLICE_ITEMS: i64 = 1024;

pub const MAXNOOF_TA_CS: i64 = 256;

pub const MAXNOOF_TA_IFOR_INACTIVE: i64 = 16;

pub const MAXNOOF_TA_IFOR_PAGING: i64 = 16;

pub const MAXNOOF_TA_IFOR_RESTART: i64 = 2048;

pub const MAXNOOF_TA_IFOR_WARNING: i64 = 65535;

pub const MAXNOOF_TA_IIN_AO_I: i64 = 16;

pub const MAXNOOF_T_AFOR_MDT: i64 = 8;

pub const MAXNOOF_TNL_ASSOCIATIONS: i64 = 32;

pub const MAXNOOF_TIME_PERIODS: i64 = 2;

pub const MAXNOOF_WLAN_NAME: i64 = 4;

pub const MAXNOOF_XN_EXT_TL_AS: i64 = 16;

pub const MAXNOOF_XN_GTP_TL_AS: i64 = 16;

pub const MAXNOOF_XN_TL_AS: i64 = 2;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AMF_TNLAssociationSetupItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AMF_TNLAssociationSetupItemIE_Extensions>,
}
impl entropic::Entropic for AMF_TNLAssociationSetupItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_tnl_association_address: CPTransportLayerInformation = source.get_entropic()?;
        let ie_extensions: Option<AMF_TNLAssociationSetupItemIE_Extensions> = None;
        Ok(Self {
            amf_tnl_association_address,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_tnl_association_address.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationSetupList(pub Vec<AMF_TNLAssociationSetupItem>);
impl entropic::Entropic for AMF_TNLAssociationSetupList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationSetupItem::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationSetupList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AMF_TNLAssociationToAddItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub tnl_association_usage: Option<TNLAssociationUsage>,
    pub tnl_address_weight_factor: TNLAddressWeightFactor,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AMF_TNLAssociationToAddItemIE_Extensions>,
}
impl entropic::Entropic for AMF_TNLAssociationToAddItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_tnl_association_address: CPTransportLayerInformation = source.get_entropic()?;
        let tnl_association_usage: Option<TNLAssociationUsage> = source.get_entropic()?;
        let tnl_address_weight_factor: TNLAddressWeightFactor = source.get_entropic()?;
        let ie_extensions: Option<AMF_TNLAssociationToAddItemIE_Extensions> = None;
        Ok(Self {
            amf_tnl_association_address,
            tnl_association_usage,
            tnl_address_weight_factor,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_tnl_association_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tnl_association_usage.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tnl_address_weight_factor.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationToAddList(pub Vec<AMF_TNLAssociationToAddItem>);
impl entropic::Entropic for AMF_TNLAssociationToAddList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationToAddItem::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationToAddList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AMF_TNLAssociationToRemoveItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AMF_TNLAssociationToRemoveItemIE_Extensions>,
}
impl entropic::Entropic for AMF_TNLAssociationToRemoveItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_tnl_association_address: CPTransportLayerInformation = source.get_entropic()?;
        let ie_extensions: Option<AMF_TNLAssociationToRemoveItemIE_Extensions> = None;
        Ok(Self {
            amf_tnl_association_address,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_tnl_association_address.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationToRemoveList(pub Vec<AMF_TNLAssociationToRemoveItem>);
impl entropic::Entropic for AMF_TNLAssociationToRemoveList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationToRemoveItem::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationToRemoveList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct AMF_TNLAssociationToUpdateItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub tnl_association_usage: Option<TNLAssociationUsage>,
    #[asn(optional_idx = 1)]
    pub tnl_address_weight_factor: Option<TNLAddressWeightFactor>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<AMF_TNLAssociationToUpdateItemIE_Extensions>,
}
impl entropic::Entropic for AMF_TNLAssociationToUpdateItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_tnl_association_address: CPTransportLayerInformation = source.get_entropic()?;
        let tnl_association_usage: Option<TNLAssociationUsage> = source.get_entropic()?;
        let tnl_address_weight_factor: Option<TNLAddressWeightFactor> = source.get_entropic()?;
        let ie_extensions: Option<AMF_TNLAssociationToUpdateItemIE_Extensions> = None;
        Ok(Self {
            amf_tnl_association_address,
            tnl_association_usage,
            tnl_address_weight_factor,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_tnl_association_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tnl_association_usage.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tnl_address_weight_factor.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationToUpdateList(pub Vec<AMF_TNLAssociationToUpdateItem>);
impl entropic::Entropic for AMF_TNLAssociationToUpdateList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationToUpdateItem::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationToUpdateList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1099511627775")]
pub struct AMF_UE_NGAP_ID(pub u64);
impl entropic::Entropic for AMF_UE_NGAP_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(AMF_UE_NGAP_ID(source.get_uniform_range(0..=1099511627775)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1099511627775 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFCPRelocationIndication {
    pub protocol_i_es: AMFCPRelocationIndicationProtocolIEs,
}
impl entropic::Entropic for AMFCPRelocationIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: AMFCPRelocationIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFConfigurationUpdate {
    pub protocol_i_es: AMFConfigurationUpdateProtocolIEs,
}
impl entropic::Entropic for AMFConfigurationUpdate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: AMFConfigurationUpdateProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFConfigurationUpdateAcknowledge {
    pub protocol_i_es: AMFConfigurationUpdateAcknowledgeProtocolIEs,
}
impl entropic::Entropic for AMFConfigurationUpdateAcknowledge {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: AMFConfigurationUpdateAcknowledgeProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFConfigurationUpdateFailure {
    pub protocol_i_es: AMFConfigurationUpdateFailureProtocolIEs,
}
impl entropic::Entropic for AMFConfigurationUpdateFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: AMFConfigurationUpdateFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct AMFName(pub String);
impl entropic::Entropic for AMFName {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_entropy_source(source)?);
        }
        Ok(Self(s))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_entropy_sink(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "UTF8String", sz_extensible = true, sz_lb = "1", sz_ub = "150")]
pub struct AMFNameUTF8String(pub String);
impl entropic::Entropic for AMFNameUTF8String {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_entropy_source(source)?);
        }
        Ok(Self(s))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_entropy_sink(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "VisibleString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct AMFNameVisibleString(pub String);
impl entropic::Entropic for AMFNameVisibleString {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_entropy_source(source)?);
        }
        Ok(Self(s))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_entropy_sink(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum AMFPagingTarget {
    #[asn(key = 0, extended = false)]
    GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 1, extended = false)]
    TAI(TAI),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(AMFPagingTarget_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for AMFPagingTarget {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            AMFPagingTarget::GlobalRANNodeID(_) => 0u128.try_into().unwrap(),
            AMFPagingTarget::TAI(_) => 1u128.try_into().unwrap(),
            AMFPagingTarget::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct AMFPointer(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for AMFPointer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(6, 16383);
        let total_bitlen = source.get_bounded_len(6..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(AMFPointer(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 6);
        let capped_max = std::cmp::min(6, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(6..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct AMFRegionID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for AMFRegionID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(AMFRegionID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct AMFSetID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for AMFSetID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(10, 16383);
        let total_bitlen = source.get_bounded_len(10..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(AMFSetID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 10);
        let capped_max = std::cmp::min(10, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(10..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFStatusIndication {
    pub protocol_i_es: AMFStatusIndicationProtocolIEs,
}
impl entropic::Entropic for AMFStatusIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: AMFStatusIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AdditionalDLUPTNLInformationForHOItem {
    pub additional_dl_ngu_up_tnl_information: UPTransportLayerInformation,
    pub additional_qos_flow_setup_response_list: QosFlowListWithDataForwarding,
    #[asn(optional_idx = 0)]
    pub additional_dl_forwarding_uptnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AdditionalDLUPTNLInformationForHOItemIE_Extensions>,
}
impl entropic::Entropic for AdditionalDLUPTNLInformationForHOItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let additional_dl_ngu_up_tnl_information: UPTransportLayerInformation =
            source.get_entropic()?;
        let additional_qos_flow_setup_response_list: QosFlowListWithDataForwarding =
            source.get_entropic()?;
        let additional_dl_forwarding_uptnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let ie_extensions: Option<AdditionalDLUPTNLInformationForHOItemIE_Extensions> = None;
        Ok(Self {
            additional_dl_ngu_up_tnl_information,
            additional_qos_flow_setup_response_list,
            additional_dl_forwarding_uptnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .additional_dl_ngu_up_tnl_information
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .additional_qos_flow_setup_response_list
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .additional_dl_forwarding_uptnl_information
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct AdditionalDLUPTNLInformationForHOList(pub Vec<AdditionalDLUPTNLInformationForHOItem>);
impl entropic::Entropic for AdditionalDLUPTNLInformationForHOList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AdditionalDLUPTNLInformationForHOItem::from_entropy_source(
                source,
            )?);
        }
        Ok(AdditionalDLUPTNLInformationForHOList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(3, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct AdditionalQosFlowInformation(pub u8);
impl AdditionalQosFlowInformation {
    pub const MORE_LIKELY: u8 = 0u8;
}
impl entropic::Entropic for AdditionalQosFlowInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(AdditionalQosFlowInformation(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AllocationAndRetentionPriority {
    pub priority_level_arp: PriorityLevelARP,
    pub pre_emption_capability: Pre_emptionCapability,
    pub pre_emption_vulnerability: Pre_emptionVulnerability,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AllocationAndRetentionPriorityIE_Extensions>,
}
impl entropic::Entropic for AllocationAndRetentionPriority {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let priority_level_arp: PriorityLevelARP = source.get_entropic()?;
        let pre_emption_capability: Pre_emptionCapability = source.get_entropic()?;
        let pre_emption_vulnerability: Pre_emptionVulnerability = source.get_entropic()?;
        let ie_extensions: Option<AllocationAndRetentionPriorityIE_Extensions> = None;
        Ok(Self {
            priority_level_arp,
            pre_emption_capability,
            pre_emption_vulnerability,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.priority_level_arp.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pre_emption_capability.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pre_emption_vulnerability.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct Allowed_CAG_List_per_PLMN(pub Vec<CAG_ID>);
impl entropic::Entropic for Allowed_CAG_List_per_PLMN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CAG_ID::from_entropy_source(source)?);
        }
        Ok(Allowed_CAG_List_per_PLMN(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Allowed_PNI_NPN_Item {
    pub plmn_identity: PLMNIdentity,
    pub pni_npn_restricted: Allowed_PNI_NPN_ItemPNI_NPN_restricted,
    pub allowed_cag_list_per_plmn: Allowed_CAG_List_per_PLMN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Allowed_PNI_NPN_ItemIE_Extensions>,
}
impl entropic::Entropic for Allowed_PNI_NPN_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let pni_npn_restricted: Allowed_PNI_NPN_ItemPNI_NPN_restricted = source.get_entropic()?;
        let allowed_cag_list_per_plmn: Allowed_CAG_List_per_PLMN = source.get_entropic()?;
        let ie_extensions: Option<Allowed_PNI_NPN_ItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            pni_npn_restricted,
            allowed_cag_list_per_plmn,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pni_npn_restricted.to_entropy_sink(sink)?;
        __entropic_internal_length += self.allowed_cag_list_per_plmn.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct Allowed_PNI_NPN_List(pub Vec<Allowed_PNI_NPN_Item>);
impl entropic::Entropic for Allowed_PNI_NPN_List {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Allowed_PNI_NPN_Item::from_entropy_source(source)?);
        }
        Ok(Allowed_PNI_NPN_List(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct AllowedNSSAI(pub Vec<AllowedNSSAI_Item>);
impl entropic::Entropic for AllowedNSSAI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(8, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AllowedNSSAI_Item::from_entropy_source(source)?);
        }
        Ok(AllowedNSSAI(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AllowedNSSAI_Item {
    pub s_nssai: S_NSSAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AllowedNSSAI_ItemIE_Extensions>,
}
impl entropic::Entropic for AllowedNSSAI_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let s_nssai: S_NSSAI = source.get_entropic()?;
        let ie_extensions: Option<AllowedNSSAI_ItemIE_Extensions> = None;
        Ok(Self {
            s_nssai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.s_nssai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct AllowedTACs(pub Vec<TAC>);
impl entropic::Entropic for AllowedTACs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAC::from_entropy_source(source)?);
        }
        Ok(AllowedTACs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8", extensible = true)]
pub struct AlternativeQoSParaSetIndex(pub u8);
impl entropic::Entropic for AlternativeQoSParaSetIndex {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(AlternativeQoSParaSetIndex(source.get_uniform_range(1..=8)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=8 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct AlternativeQoSParaSetItem {
    pub alternative_qo_s_para_set_index: AlternativeQoSParaSetIndex,
    #[asn(optional_idx = 0)]
    pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
    #[asn(optional_idx = 1)]
    pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
    #[asn(optional_idx = 2)]
    pub packet_delay_budget: Option<PacketDelayBudget>,
    #[asn(optional_idx = 3)]
    pub packet_error_rate: Option<PacketErrorRate>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<AlternativeQoSParaSetItemIE_Extensions>,
}
impl entropic::Entropic for AlternativeQoSParaSetItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let alternative_qo_s_para_set_index: AlternativeQoSParaSetIndex = source.get_entropic()?;
        let guaranteed_flow_bit_rate_dl: Option<BitRate> = source.get_entropic()?;
        let guaranteed_flow_bit_rate_ul: Option<BitRate> = source.get_entropic()?;
        let packet_delay_budget: Option<PacketDelayBudget> = source.get_entropic()?;
        let packet_error_rate: Option<PacketErrorRate> = source.get_entropic()?;
        let ie_extensions: Option<AlternativeQoSParaSetItemIE_Extensions> = None;
        Ok(Self {
            alternative_qo_s_para_set_index,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            packet_delay_budget,
            packet_error_rate,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.alternative_qo_s_para_set_index.to_entropy_sink(sink)?;
        __entropic_internal_length += self.guaranteed_flow_bit_rate_dl.to_entropy_sink(sink)?;
        __entropic_internal_length += self.guaranteed_flow_bit_rate_ul.to_entropy_sink(sink)?;
        __entropic_internal_length += self.packet_delay_budget.to_entropy_sink(sink)?;
        __entropic_internal_length += self.packet_error_rate.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct AlternativeQoSParaSetList(pub Vec<AlternativeQoSParaSetItem>);
impl entropic::Entropic for AlternativeQoSParaSetList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(8, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AlternativeQoSParaSetItem::from_entropy_source(source)?);
        }
        Ok(AlternativeQoSParaSetList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "8", extensible = true)]
pub struct AlternativeQoSParaSetNotifyIndex(pub u8);
impl entropic::Entropic for AlternativeQoSParaSetNotifyIndex {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(AlternativeQoSParaSetNotifyIndex(
            source.get_uniform_range(0..=8)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=8 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct AreaOfInterest {
    #[asn(optional_idx = 0)]
    pub area_of_interest_tai_list: Option<AreaOfInterestTAIList>,
    #[asn(optional_idx = 1)]
    pub area_of_interest_cell_list: Option<AreaOfInterestCellList>,
    #[asn(optional_idx = 2)]
    pub area_of_interest_ran_node_list: Option<AreaOfInterestRANNodeList>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<AreaOfInterestIE_Extensions>,
}
impl entropic::Entropic for AreaOfInterest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let area_of_interest_tai_list: Option<AreaOfInterestTAIList> = source.get_entropic()?;
        let area_of_interest_cell_list: Option<AreaOfInterestCellList> = source.get_entropic()?;
        let area_of_interest_ran_node_list: Option<AreaOfInterestRANNodeList> =
            source.get_entropic()?;
        let ie_extensions: Option<AreaOfInterestIE_Extensions> = None;
        Ok(Self {
            area_of_interest_tai_list,
            area_of_interest_cell_list,
            area_of_interest_ran_node_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.area_of_interest_tai_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.area_of_interest_cell_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.area_of_interest_ran_node_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestCellItem {
    pub ngran_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestCellItemIE_Extensions>,
}
impl entropic::Entropic for AreaOfInterestCellItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ngran_cgi: NGRAN_CGI = source.get_entropic()?;
        let ie_extensions: Option<AreaOfInterestCellItemIE_Extensions> = None;
        Ok(Self {
            ngran_cgi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ngran_cgi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct AreaOfInterestCellList(pub Vec<AreaOfInterestCellItem>);
impl entropic::Entropic for AreaOfInterestCellList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestCellItem::from_entropy_source(source)?);
        }
        Ok(AreaOfInterestCellList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestItem {
    pub area_of_interest: AreaOfInterest,
    pub location_reporting_reference_id: LocationReportingReferenceID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestItemIE_Extensions>,
}
impl entropic::Entropic for AreaOfInterestItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let area_of_interest: AreaOfInterest = source.get_entropic()?;
        let location_reporting_reference_id: LocationReportingReferenceID =
            source.get_entropic()?;
        let ie_extensions: Option<AreaOfInterestItemIE_Extensions> = None;
        Ok(Self {
            area_of_interest,
            location_reporting_reference_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.area_of_interest.to_entropy_sink(sink)?;
        __entropic_internal_length += self.location_reporting_reference_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct AreaOfInterestList(pub Vec<AreaOfInterestItem>);
impl entropic::Entropic for AreaOfInterestList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestItem::from_entropy_source(source)?);
        }
        Ok(AreaOfInterestList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestRANNodeItem {
    pub global_ran_node_id: GlobalRANNodeID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestRANNodeItemIE_Extensions>,
}
impl entropic::Entropic for AreaOfInterestRANNodeItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let global_ran_node_id: GlobalRANNodeID = source.get_entropic()?;
        let ie_extensions: Option<AreaOfInterestRANNodeItemIE_Extensions> = None;
        Ok(Self {
            global_ran_node_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.global_ran_node_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct AreaOfInterestRANNodeList(pub Vec<AreaOfInterestRANNodeItem>);
impl entropic::Entropic for AreaOfInterestRANNodeList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestRANNodeItem::from_entropy_source(source)?);
        }
        Ok(AreaOfInterestRANNodeList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestTAIItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestTAIItemIE_Extensions>,
}
impl entropic::Entropic for AreaOfInterestTAIItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai: TAI = source.get_entropic()?;
        let ie_extensions: Option<AreaOfInterestTAIItemIE_Extensions> = None;
        Ok(Self { tai, ie_extensions })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct AreaOfInterestTAIList(pub Vec<AreaOfInterestTAIItem>);
impl entropic::Entropic for AreaOfInterestTAIList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestTAIItem::from_entropy_source(source)?);
        }
        Ok(AreaOfInterestTAIList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum AreaScopeOfMDT_EUTRA {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedMDT_EUTRA),
    #[asn(key = 1, extended = false)]
    TABased(TABasedMDT),
    #[asn(key = 2, extended = false)]
    PLMNWide(AreaScopeOfMDT_EUTRA_pLMNWide),
    #[asn(key = 3, extended = false)]
    TAIBased(TAIBasedMDT),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(AreaScopeOfMDT_EUTRA_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for AreaScopeOfMDT_EUTRA {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            AreaScopeOfMDT_EUTRA::CellBased(_) => 0u128.try_into().unwrap(),
            AreaScopeOfMDT_EUTRA::TABased(_) => 1u128.try_into().unwrap(),
            AreaScopeOfMDT_EUTRA::PLMNWide(_) => 2u128.try_into().unwrap(),
            AreaScopeOfMDT_EUTRA::TAIBased(_) => 3u128.try_into().unwrap(),
            AreaScopeOfMDT_EUTRA::Choice_Extensions(_) => 4u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum AreaScopeOfMDT_NR {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedMDT_NR),
    #[asn(key = 1, extended = false)]
    TABased(TABasedMDT),
    #[asn(key = 2, extended = false)]
    PLMNWide(AreaScopeOfMDT_NR_pLMNWide),
    #[asn(key = 3, extended = false)]
    TAIBased(TAIBasedMDT),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(AreaScopeOfMDT_NR_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for AreaScopeOfMDT_NR {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            AreaScopeOfMDT_NR::CellBased(_) => 0u128.try_into().unwrap(),
            AreaScopeOfMDT_NR::TABased(_) => 1u128.try_into().unwrap(),
            AreaScopeOfMDT_NR::PLMNWide(_) => 2u128.try_into().unwrap(),
            AreaScopeOfMDT_NR::TAIBased(_) => 3u128.try_into().unwrap(),
            AreaScopeOfMDT_NR::Choice_Extensions(_) => 4u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AreaScopeOfNeighCellsItem {
    pub nr_frequency_info: NRFrequencyInfo,
    #[asn(optional_idx = 0)]
    pub pci_list_for_mdt: Option<PCIListForMDT>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AreaScopeOfNeighCellsItemIE_Extensions>,
}
impl entropic::Entropic for AreaScopeOfNeighCellsItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_frequency_info: NRFrequencyInfo = source.get_entropic()?;
        let pci_list_for_mdt: Option<PCIListForMDT> = source.get_entropic()?;
        let ie_extensions: Option<AreaScopeOfNeighCellsItemIE_Extensions> = None;
        Ok(Self {
            nr_frequency_info,
            pci_list_for_mdt,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_frequency_info.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pci_list_for_mdt.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct AreaScopeOfNeighCellsList(pub Vec<AreaScopeOfNeighCellsItem>);
impl entropic::Entropic for AreaScopeOfNeighCellsList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(8, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaScopeOfNeighCellsItem::from_entropy_source(source)?);
        }
        Ok(AreaScopeOfNeighCellsList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct AssistanceDataForPaging {
    #[asn(optional_idx = 0)]
    pub assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells>,
    #[asn(optional_idx = 1)]
    pub paging_attempt_information: Option<PagingAttemptInformation>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<AssistanceDataForPagingIE_Extensions>,
}
impl entropic::Entropic for AssistanceDataForPaging {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells> =
            source.get_entropic()?;
        let paging_attempt_information: Option<PagingAttemptInformation> = source.get_entropic()?;
        let ie_extensions: Option<AssistanceDataForPagingIE_Extensions> = None;
        Ok(Self {
            assistance_data_for_recommended_cells,
            paging_attempt_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .assistance_data_for_recommended_cells
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.paging_attempt_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AssistanceDataForRecommendedCells {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AssistanceDataForRecommendedCellsIE_Extensions>,
}
impl entropic::Entropic for AssistanceDataForRecommendedCells {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let recommended_cells_for_paging: RecommendedCellsForPaging = source.get_entropic()?;
        let ie_extensions: Option<AssistanceDataForRecommendedCellsIE_Extensions> = None;
        Ok(Self {
            recommended_cells_for_paging,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.recommended_cells_for_paging.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AssociatedQosFlowItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub qos_flow_mapping_indication: Option<AssociatedQosFlowItemQosFlowMappingIndication>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AssociatedQosFlowItemIE_Extensions>,
}
impl entropic::Entropic for AssociatedQosFlowItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let qos_flow_mapping_indication: Option<AssociatedQosFlowItemQosFlowMappingIndication> =
            source.get_entropic()?;
        let ie_extensions: Option<AssociatedQosFlowItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            qos_flow_mapping_indication,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_mapping_indication.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct AssociatedQosFlowList(pub Vec<AssociatedQosFlowItem>);
impl entropic::Entropic for AssociatedQosFlowList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AssociatedQosFlowItem::from_entropy_source(source)?);
        }
        Ok(AssociatedQosFlowList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct AuthenticatedIndication(pub u8);
impl AuthenticatedIndication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for AuthenticatedIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(AuthenticatedIndication(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095", extensible = true)]
pub struct AveragingWindow(pub u16);
impl entropic::Entropic for AveragingWindow {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(AveragingWindow(source.get_uniform_range(0..=4095)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4000000000000", extensible = true)]
pub struct BitRate(pub u64);
impl entropic::Entropic for BitRate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(BitRate(source.get_uniform_range(0..=4000000000000)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4000000000000 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasConfig(pub u8);
impl BluetoothMeasConfig {
    pub const SETUP: u8 = 0u8;
}
impl entropic::Entropic for BluetoothMeasConfig {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(BluetoothMeasConfig(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BluetoothMeasConfigNameItem {
    pub bluetooth_name: BluetoothName,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<BluetoothMeasConfigNameItemIE_Extensions>,
}
impl entropic::Entropic for BluetoothMeasConfigNameItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let bluetooth_name: BluetoothName = source.get_entropic()?;
        let ie_extensions: Option<BluetoothMeasConfigNameItemIE_Extensions> = None;
        Ok(Self {
            bluetooth_name,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.bluetooth_name.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct BluetoothMeasConfigNameList(pub Vec<BluetoothMeasConfigNameItem>);
impl entropic::Entropic for BluetoothMeasConfigNameList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(BluetoothMeasConfigNameItem::from_entropy_source(source)?);
        }
        Ok(BluetoothMeasConfigNameList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BluetoothMeasurementConfiguration {
    pub bluetooth_meas_config: BluetoothMeasConfig,
    #[asn(optional_idx = 0)]
    pub bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub bt_rssi: Option<BluetoothMeasurementConfigurationBt_rssi>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<BluetoothMeasurementConfigurationIE_Extensions>,
}
impl entropic::Entropic for BluetoothMeasurementConfiguration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let bluetooth_meas_config: BluetoothMeasConfig = source.get_entropic()?;
        let bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList> =
            source.get_entropic()?;
        let bt_rssi: Option<BluetoothMeasurementConfigurationBt_rssi> = source.get_entropic()?;
        let ie_extensions: Option<BluetoothMeasurementConfigurationIE_Extensions> = None;
        Ok(Self {
            bluetooth_meas_config,
            bluetooth_meas_config_name_list,
            bt_rssi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.bluetooth_meas_config.to_entropy_sink(sink)?;
        __entropic_internal_length += self.bluetooth_meas_config_name_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.bt_rssi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "248"
)]
pub struct BluetoothName(pub Vec<u8>);
impl entropic::Entropic for BluetoothName {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(BluetoothName(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "6", extensible = false)]
pub enum BroadcastCancelledAreaList {
    #[asn(key = 0, extended = false)]
    CellIDCancelledEUTRA(CellIDCancelledEUTRA),
    #[asn(key = 1, extended = false)]
    TAICancelledEUTRA(TAICancelledEUTRA),
    #[asn(key = 2, extended = false)]
    EmergencyAreaIDCancelledEUTRA(EmergencyAreaIDCancelledEUTRA),
    #[asn(key = 3, extended = false)]
    CellIDCancelledNR(CellIDCancelledNR),
    #[asn(key = 4, extended = false)]
    TAICancelledNR(TAICancelledNR),
    #[asn(key = 5, extended = false)]
    EmergencyAreaIDCancelledNR(EmergencyAreaIDCancelledNR),
    #[asn(key = 6, extended = false)]
    Choice_Extensions(BroadcastCancelledAreaList_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for BroadcastCancelledAreaList {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            BroadcastCancelledAreaList::CellIDCancelledEUTRA(_) => 0u128.try_into().unwrap(),
            BroadcastCancelledAreaList::TAICancelledEUTRA(_) => 1u128.try_into().unwrap(),
            BroadcastCancelledAreaList::EmergencyAreaIDCancelledEUTRA(_) => {
                2u128.try_into().unwrap()
            }
            BroadcastCancelledAreaList::CellIDCancelledNR(_) => 3u128.try_into().unwrap(),
            BroadcastCancelledAreaList::TAICancelledNR(_) => 4u128.try_into().unwrap(),
            BroadcastCancelledAreaList::EmergencyAreaIDCancelledNR(_) => 5u128.try_into().unwrap(),
            BroadcastCancelledAreaList::Choice_Extensions(_) => 6u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "6", extensible = false)]
pub enum BroadcastCompletedAreaList {
    #[asn(key = 0, extended = false)]
    CellIDBroadcastEUTRA(CellIDBroadcastEUTRA),
    #[asn(key = 1, extended = false)]
    TAIBroadcastEUTRA(TAIBroadcastEUTRA),
    #[asn(key = 2, extended = false)]
    EmergencyAreaIDBroadcastEUTRA(EmergencyAreaIDBroadcastEUTRA),
    #[asn(key = 3, extended = false)]
    CellIDBroadcastNR(CellIDBroadcastNR),
    #[asn(key = 4, extended = false)]
    TAIBroadcastNR(TAIBroadcastNR),
    #[asn(key = 5, extended = false)]
    EmergencyAreaIDBroadcastNR(EmergencyAreaIDBroadcastNR),
    #[asn(key = 6, extended = false)]
    Choice_Extensions(BroadcastCompletedAreaList_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for BroadcastCompletedAreaList {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            BroadcastCompletedAreaList::CellIDBroadcastEUTRA(_) => 0u128.try_into().unwrap(),
            BroadcastCompletedAreaList::TAIBroadcastEUTRA(_) => 1u128.try_into().unwrap(),
            BroadcastCompletedAreaList::EmergencyAreaIDBroadcastEUTRA(_) => {
                2u128.try_into().unwrap()
            }
            BroadcastCompletedAreaList::CellIDBroadcastNR(_) => 3u128.try_into().unwrap(),
            BroadcastCompletedAreaList::TAIBroadcastNR(_) => 4u128.try_into().unwrap(),
            BroadcastCompletedAreaList::EmergencyAreaIDBroadcastNR(_) => 5u128.try_into().unwrap(),
            BroadcastCompletedAreaList::Choice_Extensions(_) => 6u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BroadcastPLMNItem {
    pub plmn_identity: PLMNIdentity,
    pub tai_slice_support_list: SliceSupportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<BroadcastPLMNItemIE_Extensions>,
}
impl entropic::Entropic for BroadcastPLMNItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let tai_slice_support_list: SliceSupportList = source.get_entropic()?;
        let ie_extensions: Option<BroadcastPLMNItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            tai_slice_support_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tai_slice_support_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct BroadcastPLMNList(pub Vec<BroadcastPLMNItem>);
impl entropic::Entropic for BroadcastPLMNList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(12, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(BroadcastPLMNItem::from_entropy_source(source)?);
        }
        Ok(BroadcastPLMNList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(12, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct BurstArrivalTime(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CAG_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for CAG_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(32..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(CAG_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 32);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CEmodeBSupport_Indicator(pub u8);
impl CEmodeBSupport_Indicator {
    pub const SUPPORTED: u8 = 0u8;
}
impl entropic::Entropic for CEmodeBSupport_Indicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CEmodeBSupport_Indicator(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CEmodeBrestricted(pub u8);
impl CEmodeBrestricted {
    pub const RESTRICTED: u8 = 0u8;
    pub const NOT_RESTRICTED: u8 = 1u8;
}
impl entropic::Entropic for CEmodeBrestricted {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CEmodeBrestricted(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CNAssistedRANTuning {
    #[asn(optional_idx = 0)]
    pub expected_ue_behaviour: Option<ExpectedUEBehaviour>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CNAssistedRANTuningIE_Extensions>,
}
impl entropic::Entropic for CNAssistedRANTuning {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let expected_ue_behaviour: Option<ExpectedUEBehaviour> = source.get_entropic()?;
        let ie_extensions: Option<CNAssistedRANTuningIE_Extensions> = None;
        Ok(Self {
            expected_ue_behaviour,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.expected_ue_behaviour.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct CNTypeRestrictionsForEquivalent(pub Vec<CNTypeRestrictionsForEquivalentItem>);
impl entropic::Entropic for CNTypeRestrictionsForEquivalent {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(15, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CNTypeRestrictionsForEquivalentItem::from_entropy_source(
                source,
            )?);
        }
        Ok(CNTypeRestrictionsForEquivalent(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(15, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CNTypeRestrictionsForEquivalentItem {
    pub plmn_identity: PLMNIdentity,
    pub cn_type: CNTypeRestrictionsForEquivalentItemCn_Type,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CNTypeRestrictionsForEquivalentItemIE_Extensions>,
}
impl entropic::Entropic for CNTypeRestrictionsForEquivalentItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let cn_type: CNTypeRestrictionsForEquivalentItemCn_Type = source.get_entropic()?;
        let ie_extensions: Option<CNTypeRestrictionsForEquivalentItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            cn_type,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cn_type.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CNTypeRestrictionsForServing(pub u8);
impl CNTypeRestrictionsForServing {
    pub const EPC_FORBIDDEN: u8 = 0u8;
}
impl entropic::Entropic for CNTypeRestrictionsForServing {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CNTypeRestrictionsForServing(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTValueForPDCP_SN12 {
    pub pdcp_sn12: COUNTValueForPDCP_SN12PDCP_SN12,
    pub hfn_pdcp_sn12: COUNTValueForPDCP_SN12HFN_PDCP_SN12,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTValueForPDCP_SN12IE_Extensions>,
}
impl entropic::Entropic for COUNTValueForPDCP_SN12 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdcp_sn12: COUNTValueForPDCP_SN12PDCP_SN12 = source.get_entropic()?;
        let hfn_pdcp_sn12: COUNTValueForPDCP_SN12HFN_PDCP_SN12 = source.get_entropic()?;
        let ie_extensions: Option<COUNTValueForPDCP_SN12IE_Extensions> = None;
        Ok(Self {
            pdcp_sn12,
            hfn_pdcp_sn12,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdcp_sn12.to_entropy_sink(sink)?;
        __entropic_internal_length += self.hfn_pdcp_sn12.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTValueForPDCP_SN18 {
    pub pdcp_sn18: COUNTValueForPDCP_SN18PDCP_SN18,
    pub hfn_pdcp_sn18: COUNTValueForPDCP_SN18HFN_PDCP_SN18,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTValueForPDCP_SN18IE_Extensions>,
}
impl entropic::Entropic for COUNTValueForPDCP_SN18 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdcp_sn18: COUNTValueForPDCP_SN18PDCP_SN18 = source.get_entropic()?;
        let hfn_pdcp_sn18: COUNTValueForPDCP_SN18HFN_PDCP_SN18 = source.get_entropic()?;
        let ie_extensions: Option<COUNTValueForPDCP_SN18IE_Extensions> = None;
        Ok(Self {
            pdcp_sn18,
            hfn_pdcp_sn18,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdcp_sn18.to_entropy_sink(sink)?;
        __entropic_internal_length += self.hfn_pdcp_sn18.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CPTransportLayerInformation {
    #[asn(key = 0, extended = false)]
    EndpointIPAddress(TransportLayerAddress),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(CPTransportLayerInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for CPTransportLayerInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            CPTransportLayerInformation::EndpointIPAddress(_) => 0u128.try_into().unwrap(),
            CPTransportLayerInformation::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CancelAllWarningMessages(pub u8);
impl CancelAllWarningMessages {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for CancelAllWarningMessages {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CancelAllWarningMessages(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_EUTRA(pub Vec<CancelledCellsInEAI_EUTRA_Item>);
impl entropic::Entropic for CancelledCellsInEAI_EUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInEAI_EUTRA_Item::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInEAI_EUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInEAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInEAI_EUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for CancelledCellsInEAI_EUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = source.get_entropic()?;
        let ie_extensions: Option<CancelledCellsInEAI_EUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.number_of_broadcasts.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_NR(pub Vec<CancelledCellsInEAI_NR_Item>);
impl entropic::Entropic for CancelledCellsInEAI_NR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInEAI_NR_Item::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInEAI_NR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInEAI_NR_Item {
    pub nr_cgi: NR_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInEAI_NR_ItemIE_Extensions>,
}
impl entropic::Entropic for CancelledCellsInEAI_NR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_cgi: NR_CGI = source.get_entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = source.get_entropic()?;
        let ie_extensions: Option<CancelledCellsInEAI_NR_ItemIE_Extensions> = None;
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.number_of_broadcasts.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_EUTRA(pub Vec<CancelledCellsInTAI_EUTRA_Item>);
impl entropic::Entropic for CancelledCellsInTAI_EUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInTAI_EUTRA_Item::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInTAI_EUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInTAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInTAI_EUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for CancelledCellsInTAI_EUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = source.get_entropic()?;
        let ie_extensions: Option<CancelledCellsInTAI_EUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.number_of_broadcasts.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_NR(pub Vec<CancelledCellsInTAI_NR_Item>);
impl entropic::Entropic for CancelledCellsInTAI_NR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInTAI_NR_Item::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInTAI_NR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInTAI_NR_Item {
    pub nr_cgi: NR_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInTAI_NR_ItemIE_Extensions>,
}
impl entropic::Entropic for CancelledCellsInTAI_NR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_cgi: NR_CGI = source.get_entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = source.get_entropic()?;
        let ie_extensions: Option<CancelledCellsInTAI_NR_ItemIE_Extensions> = None;
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.number_of_broadcasts.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum CandidateCell {
    #[asn(key = 0, extended = false)]
    CandidateCGI(CandidateCellID),
    #[asn(key = 1, extended = false)]
    CandidatePCI(CandidatePCI),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(CandidateCell_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for CandidateCell {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            CandidateCell::CandidateCGI(_) => 0u128.try_into().unwrap(),
            CandidateCell::CandidatePCI(_) => 1u128.try_into().unwrap(),
            CandidateCell::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CandidateCellID {
    pub candidate_cell_id: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CandidateCellIDIE_Extensions>,
}
impl entropic::Entropic for CandidateCellID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let candidate_cell_id: NR_CGI = source.get_entropic()?;
        let ie_extensions: Option<CandidateCellIDIE_Extensions> = None;
        Ok(Self {
            candidate_cell_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.candidate_cell_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CandidateCellItem {
    pub candidate_cell: CandidateCell,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CandidateCellItemIE_Extensions>,
}
impl entropic::Entropic for CandidateCellItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let candidate_cell: CandidateCell = source.get_entropic()?;
        let ie_extensions: Option<CandidateCellItemIE_Extensions> = None;
        Ok(Self {
            candidate_cell,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.candidate_cell.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CandidateCellList(pub Vec<CandidateCellItem>);
impl entropic::Entropic for CandidateCellList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CandidateCellItem::from_entropy_source(source)?);
        }
        Ok(CandidateCellList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CandidatePCI {
    pub candidate_pci: CandidatePCICandidatePCI,
    pub candidate_nrarfcn: CandidatePCICandidateNRARFCN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CandidatePCIIE_Extensions>,
}
impl entropic::Entropic for CandidatePCI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let candidate_pci: CandidatePCICandidatePCI = source.get_entropic()?;
        let candidate_nrarfcn: CandidatePCICandidateNRARFCN = source.get_entropic()?;
        let ie_extensions: Option<CandidatePCIIE_Extensions> = None;
        Ok(Self {
            candidate_pci,
            candidate_nrarfcn,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.candidate_pci.to_entropy_sink(sink)?;
        __entropic_internal_length += self.candidate_nrarfcn.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum Cause {
    #[asn(key = 0, extended = false)]
    RadioNetwork(CauseRadioNetwork),
    #[asn(key = 1, extended = false)]
    Transport(CauseTransport),
    #[asn(key = 2, extended = false)]
    Nas(CauseNas),
    #[asn(key = 3, extended = false)]
    Protocol(CauseProtocol),
    #[asn(key = 4, extended = false)]
    Misc(CauseMisc),
    #[asn(key = 5, extended = false)]
    Choice_Extensions(Cause_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for Cause {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Cause::RadioNetwork(_) => 0u128.try_into().unwrap(),
            Cause::Transport(_) => 1u128.try_into().unwrap(),
            Cause::Nas(_) => 2u128.try_into().unwrap(),
            Cause::Protocol(_) => 3u128.try_into().unwrap(),
            Cause::Misc(_) => 4u128.try_into().unwrap(),
            Cause::Choice_Extensions(_) => 5u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct CauseMisc(pub u8);
impl CauseMisc {
    pub const CONTROL_PROCESSING_OVERLOAD: u8 = 0u8;
    pub const NOT_ENOUGH_USER_PLANE_PROCESSING_RESOURCES: u8 = 1u8;
    pub const HARDWARE_FAILURE: u8 = 2u8;
    pub const OM_INTERVENTION: u8 = 3u8;
    pub const UNKNOWN_PLMN_OR_SNPN: u8 = 4u8;
    pub const UNSPECIFIED: u8 = 5u8;
}
impl entropic::Entropic for CauseMisc {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CauseMisc(source.get_uniform_range(0..=5)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct CauseNas(pub u8);
impl CauseNas {
    pub const NORMAL_RELEASE: u8 = 0u8;
    pub const AUTHENTICATION_FAILURE: u8 = 1u8;
    pub const DEREGISTER: u8 = 2u8;
    pub const UNSPECIFIED: u8 = 3u8;
}
impl entropic::Entropic for CauseNas {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CauseNas(source.get_uniform_range(0..=3)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct CauseProtocol(pub u8);
impl CauseProtocol {
    pub const TRANSFER_SYNTAX_ERROR: u8 = 0u8;
    pub const ABSTRACT_SYNTAX_ERROR_REJECT: u8 = 1u8;
    pub const ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY: u8 = 2u8;
    pub const MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE: u8 = 3u8;
    pub const SEMANTIC_ERROR: u8 = 4u8;
    pub const ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE: u8 = 5u8;
    pub const UNSPECIFIED: u8 = 6u8;
}
impl entropic::Entropic for CauseProtocol {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CauseProtocol(source.get_uniform_range(0..=6)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=6 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "44")]
pub struct CauseRadioNetwork(pub u8);
impl CauseRadioNetwork {
    pub const UNSPECIFIED: u8 = 0u8;
    pub const TXNRELOCOVERALL_EXPIRY: u8 = 1u8;
    pub const SUCCESSFUL_HANDOVER: u8 = 2u8;
    pub const RELEASE_DUE_TO_NGRAN_GENERATED_REASON: u8 = 3u8;
    pub const RELEASE_DUE_TO_5GC_GENERATED_REASON: u8 = 4u8;
    pub const HANDOVER_CANCELLED: u8 = 5u8;
    pub const PARTIAL_HANDOVER: u8 = 6u8;
    pub const HO_FAILURE_IN_TARGET_5GC_NGRAN_NODE_OR_TARGET_SYSTEM: u8 = 7u8;
    pub const HO_TARGET_NOT_ALLOWED: u8 = 8u8;
    pub const TNGRELOCOVERALL_EXPIRY: u8 = 9u8;
    pub const TNGRELOCPREP_EXPIRY: u8 = 10u8;
    pub const CELL_NOT_AVAILABLE: u8 = 11u8;
    pub const UNKNOWN_TARGET_ID: u8 = 12u8;
    pub const NO_RADIO_RESOURCES_AVAILABLE_IN_TARGET_CELL: u8 = 13u8;
    pub const UNKNOWN_LOCAL_UE_NGAP_ID: u8 = 14u8;
    pub const INCONSISTENT_REMOTE_UE_NGAP_ID: u8 = 15u8;
    pub const HANDOVER_DESIRABLE_FOR_RADIO_REASON: u8 = 16u8;
    pub const TIME_CRITICAL_HANDOVER: u8 = 17u8;
    pub const RESOURCE_OPTIMISATION_HANDOVER: u8 = 18u8;
    pub const REDUCE_LOAD_IN_SERVING_CELL: u8 = 19u8;
    pub const USER_INACTIVITY: u8 = 20u8;
    pub const RADIO_CONNECTION_WITH_UE_LOST: u8 = 21u8;
    pub const RADIO_RESOURCES_NOT_AVAILABLE: u8 = 22u8;
    pub const INVALID_QOS_COMBINATION: u8 = 23u8;
    pub const FAILURE_IN_RADIO_INTERFACE_PROCEDURE: u8 = 24u8;
    pub const INTERACTION_WITH_OTHER_PROCEDURE: u8 = 25u8;
    pub const UNKNOWN_PDU_SESSION_ID: u8 = 26u8;
    pub const UNKOWN_QOS_FLOW_ID: u8 = 27u8;
    pub const MULTIPLE_PDU_SESSION_ID_INSTANCES: u8 = 28u8;
    pub const MULTIPLE_QOS_FLOW_ID_INSTANCES: u8 = 29u8;
    pub const ENCRYPTION_AND_OR_INTEGRITY_PROTECTION_ALGORITHMS_NOT_SUPPORTED: u8 = 30u8;
    pub const NG_INTRA_SYSTEM_HANDOVER_TRIGGERED: u8 = 31u8;
    pub const NG_INTER_SYSTEM_HANDOVER_TRIGGERED: u8 = 32u8;
    pub const XN_HANDOVER_TRIGGERED: u8 = 33u8;
    pub const NOT_SUPPORTED_5QI_VALUE: u8 = 34u8;
    pub const UE_CONTEXT_TRANSFER: u8 = 35u8;
    pub const IMS_VOICE_EPS_FALLBACK_OR_RAT_FALLBACK_TRIGGERED: u8 = 36u8;
    pub const UP_INTEGRITY_PROTECTION_NOT_POSSIBLE: u8 = 37u8;
    pub const UP_CONFIDENTIALITY_PROTECTION_NOT_POSSIBLE: u8 = 38u8;
    pub const SLICE_NOT_SUPPORTED: u8 = 39u8;
    pub const UE_IN_RRC_INACTIVE_STATE_NOT_REACHABLE: u8 = 40u8;
    pub const REDIRECTION: u8 = 41u8;
    pub const RESOURCES_NOT_AVAILABLE_FOR_THE_SLICE: u8 = 42u8;
    pub const UE_MAX_INTEGRITY_PROTECTED_DATA_RATE_REASON: u8 = 43u8;
    pub const RELEASE_DUE_TO_CN_DETECTED_MOBILITY: u8 = 44u8;
}
impl entropic::Entropic for CauseRadioNetwork {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CauseRadioNetwork(source.get_uniform_range(0..=44)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=44 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CauseTransport(pub u8);
impl CauseTransport {
    pub const TRANSPORT_RESOURCE_UNAVAILABLE: u8 = 0u8;
    pub const UNSPECIFIED: u8 = 1u8;
}
impl entropic::Entropic for CauseTransport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CauseTransport(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Cell_CAGInformation {
    pub ngran_cgi: NGRAN_CGI,
    pub cell_cag_list: CellCAGList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Cell_CAGInformationIE_Extensions>,
}
impl entropic::Entropic for Cell_CAGInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ngran_cgi: NGRAN_CGI = source.get_entropic()?;
        let cell_cag_list: CellCAGList = source.get_entropic()?;
        let ie_extensions: Option<Cell_CAGInformationIE_Extensions> = None;
        Ok(Self {
            ngran_cgi,
            cell_cag_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ngran_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cell_cag_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedMDT_EUTRA {
    pub cell_id_listfor_mdt: CellIdListforMDT_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedMDT_EUTRAIE_Extensions>,
}
impl entropic::Entropic for CellBasedMDT_EUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cell_id_listfor_mdt: CellIdListforMDT_EUTRA = source.get_entropic()?;
        let ie_extensions: Option<CellBasedMDT_EUTRAIE_Extensions> = None;
        Ok(Self {
            cell_id_listfor_mdt,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_id_listfor_mdt.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedMDT_NR {
    pub cell_id_listfor_mdt: CellIdListforMDT_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedMDT_NRIE_Extensions>,
}
impl entropic::Entropic for CellBasedMDT_NR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cell_id_listfor_mdt: CellIdListforMDT_NR = source.get_entropic()?;
        let ie_extensions: Option<CellBasedMDT_NRIE_Extensions> = None;
        Ok(Self {
            cell_id_listfor_mdt,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_id_listfor_mdt.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct CellCAGList(pub Vec<CAG_ID>);
impl entropic::Entropic for CellCAGList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CAG_ID::from_entropy_source(source)?);
        }
        Ok(CellCAGList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastEUTRA(pub Vec<CellIDBroadcastEUTRA_Item>);
impl entropic::Entropic for CellIDBroadcastEUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDBroadcastEUTRA_Item::from_entropy_source(source)?);
        }
        Ok(CellIDBroadcastEUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDBroadcastEUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDBroadcastEUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for CellIDBroadcastEUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let ie_extensions: Option<CellIDBroadcastEUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastNR(pub Vec<CellIDBroadcastNR_Item>);
impl entropic::Entropic for CellIDBroadcastNR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDBroadcastNR_Item::from_entropy_source(source)?);
        }
        Ok(CellIDBroadcastNR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDBroadcastNR_Item {
    pub nr_cgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDBroadcastNR_ItemIE_Extensions>,
}
impl entropic::Entropic for CellIDBroadcastNR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_cgi: NR_CGI = source.get_entropic()?;
        let ie_extensions: Option<CellIDBroadcastNR_ItemIE_Extensions> = None;
        Ok(Self {
            nr_cgi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_cgi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledEUTRA(pub Vec<CellIDCancelledEUTRA_Item>);
impl entropic::Entropic for CellIDCancelledEUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDCancelledEUTRA_Item::from_entropy_source(source)?);
        }
        Ok(CellIDCancelledEUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDCancelledEUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDCancelledEUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for CellIDCancelledEUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = source.get_entropic()?;
        let ie_extensions: Option<CellIDCancelledEUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.number_of_broadcasts.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledNR(pub Vec<CellIDCancelledNR_Item>);
impl entropic::Entropic for CellIDCancelledNR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDCancelledNR_Item::from_entropy_source(source)?);
        }
        Ok(CellIDCancelledNR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDCancelledNR_Item {
    pub nr_cgi: NR_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDCancelledNR_ItemIE_Extensions>,
}
impl entropic::Entropic for CellIDCancelledNR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_cgi: NR_CGI = source.get_entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = source.get_entropic()?;
        let ie_extensions: Option<CellIDCancelledNR_ItemIE_Extensions> = None;
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.number_of_broadcasts.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum CellIDListForRestart {
    #[asn(key = 0, extended = false)]
    EUTRA_CGIListforRestart(EUTRA_CGIList),
    #[asn(key = 1, extended = false)]
    NR_CGIListforRestart(NR_CGIList),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(CellIDListForRestart_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for CellIDListForRestart {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            CellIDListForRestart::EUTRA_CGIListforRestart(_) => 0u128.try_into().unwrap(),
            CellIDListForRestart::NR_CGIListforRestart(_) => 1u128.try_into().unwrap(),
            CellIDListForRestart::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforMDT_EUTRA(pub Vec<EUTRA_CGI>);
impl entropic::Entropic for CellIdListforMDT_EUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRA_CGI::from_entropy_source(source)?);
        }
        Ok(CellIdListforMDT_EUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforMDT_NR(pub Vec<NR_CGI>);
impl entropic::Entropic for CellIdListforMDT_NR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NR_CGI::from_entropy_source(source)?);
        }
        Ok(CellIdListforMDT_NR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct CellSize(pub u8);
impl CellSize {
    pub const VERYSMALL: u8 = 0u8;
    pub const SMALL: u8 = 1u8;
    pub const MEDIUM: u8 = 2u8;
    pub const LARGE: u8 = 3u8;
}
impl entropic::Entropic for CellSize {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CellSize(source.get_uniform_range(0..=3)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellTrafficTrace {
    pub protocol_i_es: CellTrafficTraceProtocolIEs,
}
impl entropic::Entropic for CellTrafficTrace {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: CellTrafficTraceProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellType {
    pub cell_size: CellSize,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellTypeIE_Extensions>,
}
impl entropic::Entropic for CellType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cell_size: CellSize = source.get_entropic()?;
        let ie_extensions: Option<CellTypeIE_Extensions> = None;
        Ok(Self {
            cell_size,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_size.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CommonNetworkInstance(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_EUTRA(pub Vec<CompletedCellsInEAI_EUTRA_Item>);
impl entropic::Entropic for CompletedCellsInEAI_EUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInEAI_EUTRA_Item::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInEAI_EUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInEAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInEAI_EUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for CompletedCellsInEAI_EUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let ie_extensions: Option<CompletedCellsInEAI_EUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_NR(pub Vec<CompletedCellsInEAI_NR_Item>);
impl entropic::Entropic for CompletedCellsInEAI_NR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInEAI_NR_Item::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInEAI_NR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInEAI_NR_Item {
    pub nr_cgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInEAI_NR_ItemIE_Extensions>,
}
impl entropic::Entropic for CompletedCellsInEAI_NR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_cgi: NR_CGI = source.get_entropic()?;
        let ie_extensions: Option<CompletedCellsInEAI_NR_ItemIE_Extensions> = None;
        Ok(Self {
            nr_cgi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_cgi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_EUTRA(pub Vec<CompletedCellsInTAI_EUTRA_Item>);
impl entropic::Entropic for CompletedCellsInTAI_EUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInTAI_EUTRA_Item::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInTAI_EUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInTAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInTAI_EUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for CompletedCellsInTAI_EUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let ie_extensions: Option<CompletedCellsInTAI_EUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_NR(pub Vec<CompletedCellsInTAI_NR_Item>);
impl entropic::Entropic for CompletedCellsInTAI_NR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInTAI_NR_Item::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInTAI_NR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInTAI_NR_Item {
    pub nr_cgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInTAI_NR_ItemIE_Extensions>,
}
impl entropic::Entropic for CompletedCellsInTAI_NR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_cgi: NR_CGI = source.get_entropic()?;
        let ie_extensions: Option<CompletedCellsInTAI_NR_ItemIE_Extensions> = None;
        Ok(Self {
            nr_cgi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_cgi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ConcurrentWarningMessageInd(pub u8);
impl ConcurrentWarningMessageInd {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for ConcurrentWarningMessageInd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ConcurrentWarningMessageInd(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ConfidentialityProtectionIndication(pub u8);
impl ConfidentialityProtectionIndication {
    pub const REQUIRED: u8 = 0u8;
    pub const PREFERRED: u8 = 1u8;
    pub const NOT_NEEDED: u8 = 2u8;
}
impl entropic::Entropic for ConfidentialityProtectionIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ConfidentialityProtectionIndication(
            source.get_uniform_range(0..=2)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ConfidentialityProtectionResult(pub u8);
impl ConfidentialityProtectionResult {
    pub const PERFORMED: u8 = 0u8;
    pub const NOT_PERFORMED: u8 = 1u8;
}
impl entropic::Entropic for ConfidentialityProtectionResult {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ConfidentialityProtectionResult(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "128",
    sz_ub = "128"
)]
pub struct ConfiguredNSSAI(pub Vec<u8>);
impl entropic::Entropic for ConfiguredNSSAI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(128, 16383);
        let vec_len = source.get_bounded_len(128..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(ConfiguredNSSAI(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(128, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(128..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ConfiguredTACIndication(pub u8);
impl ConfiguredTACIndication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for ConfiguredTACIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ConfiguredTACIndication(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ConnectionEstablishmentIndication {
    pub protocol_i_es: ConnectionEstablishmentIndicationProtocolIEs,
}
impl entropic::Entropic for ConnectionEstablishmentIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: ConnectionEstablishmentIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct CoreNetworkAssistanceInformationForInactive {
    pub ue_identity_index_value: UEIdentityIndexValue,
    #[asn(optional_idx = 0)]
    pub ue_specific_drx: Option<PagingDRX>,
    pub periodic_registration_update_timer: PeriodicRegistrationUpdateTimer,
    #[asn(optional_idx = 1)]
    pub mico_mode_indication: Option<MICOModeIndication>,
    pub tai_list_for_inactive: TAIListForInactive,
    #[asn(optional_idx = 2)]
    pub expected_ue_behaviour: Option<ExpectedUEBehaviour>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<CoreNetworkAssistanceInformationForInactiveIE_Extensions>,
}
impl entropic::Entropic for CoreNetworkAssistanceInformationForInactive {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ue_identity_index_value: UEIdentityIndexValue = source.get_entropic()?;
        let ue_specific_drx: Option<PagingDRX> = source.get_entropic()?;
        let periodic_registration_update_timer: PeriodicRegistrationUpdateTimer =
            source.get_entropic()?;
        let mico_mode_indication: Option<MICOModeIndication> = source.get_entropic()?;
        let tai_list_for_inactive: TAIListForInactive = source.get_entropic()?;
        let expected_ue_behaviour: Option<ExpectedUEBehaviour> = source.get_entropic()?;
        let ie_extensions: Option<CoreNetworkAssistanceInformationForInactiveIE_Extensions> = None;
        Ok(Self {
            ue_identity_index_value,
            ue_specific_drx,
            periodic_registration_update_timer,
            mico_mode_indication,
            tai_list_for_inactive,
            expected_ue_behaviour,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ue_identity_index_value.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ue_specific_drx.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .periodic_registration_update_timer
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.mico_mode_indication.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tai_list_for_inactive.to_entropy_sink(sink)?;
        __entropic_internal_length += self.expected_ue_behaviour.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CoverageEnhancementLevel(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Criticality(pub u8);
impl Criticality {
    pub const REJECT: u8 = 0u8;
    pub const IGNORE: u8 = 1u8;
    pub const NOTIFY: u8 = 2u8;
}
impl entropic::Entropic for Criticality {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Criticality(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct CriticalityDiagnostics {
    #[asn(optional_idx = 0)]
    pub procedure_code: Option<ProcedureCode>,
    #[asn(optional_idx = 1)]
    pub triggering_message: Option<TriggeringMessage>,
    #[asn(optional_idx = 2)]
    pub procedure_criticality: Option<Criticality>,
    #[asn(optional_idx = 3)]
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnostics_IE_List>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<CriticalityDiagnosticsIE_Extensions>,
}
impl entropic::Entropic for CriticalityDiagnostics {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let procedure_code: Option<ProcedureCode> = source.get_entropic()?;
        let triggering_message: Option<TriggeringMessage> = source.get_entropic()?;
        let procedure_criticality: Option<Criticality> = source.get_entropic()?;
        let i_es_criticality_diagnostics: Option<CriticalityDiagnostics_IE_List> =
            source.get_entropic()?;
        let ie_extensions: Option<CriticalityDiagnosticsIE_Extensions> = None;
        Ok(Self {
            procedure_code,
            triggering_message,
            procedure_criticality,
            i_es_criticality_diagnostics,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.procedure_code.to_entropy_sink(sink)?;
        __entropic_internal_length += self.triggering_message.to_entropy_sink(sink)?;
        __entropic_internal_length += self.procedure_criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.i_es_criticality_diagnostics.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CriticalityDiagnostics_IE_Item {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIE_ID,
    pub type_of_error: TypeOfError,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CriticalityDiagnostics_IE_ItemIE_Extensions>,
}
impl entropic::Entropic for CriticalityDiagnostics_IE_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ie_criticality: Criticality = source.get_entropic()?;
        let ie_id: ProtocolIE_ID = source.get_entropic()?;
        let type_of_error: TypeOfError = source.get_entropic()?;
        let ie_extensions: Option<CriticalityDiagnostics_IE_ItemIE_Extensions> = None;
        Ok(Self {
            ie_criticality,
            ie_id,
            type_of_error,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ie_criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.type_of_error.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CriticalityDiagnostics_IE_List(pub Vec<CriticalityDiagnostics_IE_Item>);
impl entropic::Entropic for CriticalityDiagnostics_IE_List {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CriticalityDiagnostics_IE_Item::from_entropy_source(source)?);
        }
        Ok(CriticalityDiagnostics_IE_List(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSRequestInfo {
    pub daps_indicator: DAPSRequestInfoDAPSIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSRequestInfoIE_Extensions>,
}
impl entropic::Entropic for DAPSRequestInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let daps_indicator: DAPSRequestInfoDAPSIndicator = source.get_entropic()?;
        let ie_extensions: Option<DAPSRequestInfoIE_Extensions> = None;
        Ok(Self {
            daps_indicator,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.daps_indicator.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfo {
    pub dapsresponseindicator: DAPSResponseInfoDapsresponseindicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSResponseInfoIE_Extensions>,
}
impl entropic::Entropic for DAPSResponseInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dapsresponseindicator: DAPSResponseInfoDapsresponseindicator = source.get_entropic()?;
        let ie_extensions: Option<DAPSResponseInfoIE_Extensions> = None;
        Ok(Self {
            dapsresponseindicator,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dapsresponseindicator.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfoItem {
    pub drb_id: DRB_ID,
    pub daps_response_info: DAPSResponseInfo,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DAPSResponseInfoItemIE_Extension>,
}
impl entropic::Entropic for DAPSResponseInfoItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let drb_id: DRB_ID = source.get_entropic()?;
        let daps_response_info: DAPSResponseInfo = source.get_entropic()?;
        let ie_extension: Option<DAPSResponseInfoItemIE_Extension> = source.get_entropic()?;
        Ok(Self {
            drb_id,
            daps_response_info,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.drb_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.daps_response_info.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DAPSResponseInfoList(pub Vec<DAPSResponseInfoItem>);
impl entropic::Entropic for DAPSResponseInfoList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSResponseInfoItem::from_entropy_source(source)?);
        }
        Ok(DAPSResponseInfoList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DL_CP_SecurityInformation {
    pub dl_nas_mac: DL_NAS_MAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DL_CP_SecurityInformationIE_Extensions>,
}
impl entropic::Entropic for DL_CP_SecurityInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_nas_mac: DL_NAS_MAC = source.get_entropic()?;
        let ie_extensions: Option<DL_CP_SecurityInformationIE_Extensions> = None;
        Ok(Self {
            dl_nas_mac,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_nas_mac.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct DL_NAS_MAC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for DL_NAS_MAC {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(DL_NAS_MAC(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DL_NGU_TNLInformationReused(pub u8);
impl DL_NGU_TNLInformationReused {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for DL_NGU_TNLInformationReused {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DL_NGU_TNLInformationReused(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DLForwarding(pub u8);
impl DLForwarding {
    pub const DL_FORWARDING_PROPOSED: u8 = 0u8;
}
impl entropic::Entropic for DLForwarding {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DLForwarding(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32", extensible = true)]
pub struct DRB_ID(pub u8);
impl entropic::Entropic for DRB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DRB_ID(source.get_uniform_range(1..=32)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=32 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum DRBStatusDL {
    #[asn(key = 0, extended = false)]
    DRBStatusDL12(DRBStatusDL12),
    #[asn(key = 1, extended = false)]
    DRBStatusDL18(DRBStatusDL18),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(DRBStatusDL_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for DRBStatusDL {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            DRBStatusDL::DRBStatusDL12(_) => 0u128.try_into().unwrap(),
            DRBStatusDL::DRBStatusDL18(_) => 1u128.try_into().unwrap(),
            DRBStatusDL::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBStatusDL12 {
    pub dl_count_value: COUNTValueForPDCP_SN12,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBStatusDL12IE_Extension>,
}
impl entropic::Entropic for DRBStatusDL12 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_count_value: COUNTValueForPDCP_SN12 = source.get_entropic()?;
        let ie_extension: Option<DRBStatusDL12IE_Extension> = source.get_entropic()?;
        Ok(Self {
            dl_count_value,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_count_value.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBStatusDL18 {
    pub dl_count_value: COUNTValueForPDCP_SN18,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBStatusDL18IE_Extension>,
}
impl entropic::Entropic for DRBStatusDL18 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_count_value: COUNTValueForPDCP_SN18 = source.get_entropic()?;
        let ie_extension: Option<DRBStatusDL18IE_Extension> = source.get_entropic()?;
        Ok(Self {
            dl_count_value,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_count_value.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum DRBStatusUL {
    #[asn(key = 0, extended = false)]
    DRBStatusUL12(DRBStatusUL12),
    #[asn(key = 1, extended = false)]
    DRBStatusUL18(DRBStatusUL18),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(DRBStatusUL_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for DRBStatusUL {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            DRBStatusUL::DRBStatusUL12(_) => 0u128.try_into().unwrap(),
            DRBStatusUL::DRBStatusUL18(_) => 1u128.try_into().unwrap(),
            DRBStatusUL::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct DRBStatusUL12 {
    pub ul_count_value: COUNTValueForPDCP_SN12,
    #[asn(optional_idx = 0)]
    pub receive_status_of_ul_pdcp_sd_us: Option<DRBStatusUL12ReceiveStatusOfUL_PDCP_SDUs>,
    #[asn(optional_idx = 1)]
    pub ie_extension: Option<DRBStatusUL12IE_Extension>,
}
impl entropic::Entropic for DRBStatusUL12 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ul_count_value: COUNTValueForPDCP_SN12 = source.get_entropic()?;
        let receive_status_of_ul_pdcp_sd_us: Option<DRBStatusUL12ReceiveStatusOfUL_PDCP_SDUs> =
            source.get_entropic()?;
        let ie_extension: Option<DRBStatusUL12IE_Extension> = source.get_entropic()?;
        Ok(Self {
            ul_count_value,
            receive_status_of_ul_pdcp_sd_us,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ul_count_value.to_entropy_sink(sink)?;
        __entropic_internal_length += self.receive_status_of_ul_pdcp_sd_us.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct DRBStatusUL18 {
    pub ul_count_value: COUNTValueForPDCP_SN18,
    #[asn(optional_idx = 0)]
    pub receive_status_of_ul_pdcp_sd_us: Option<DRBStatusUL18ReceiveStatusOfUL_PDCP_SDUs>,
    #[asn(optional_idx = 1)]
    pub ie_extension: Option<DRBStatusUL18IE_Extension>,
}
impl entropic::Entropic for DRBStatusUL18 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ul_count_value: COUNTValueForPDCP_SN18 = source.get_entropic()?;
        let receive_status_of_ul_pdcp_sd_us: Option<DRBStatusUL18ReceiveStatusOfUL_PDCP_SDUs> =
            source.get_entropic()?;
        let ie_extension: Option<DRBStatusUL18IE_Extension> = source.get_entropic()?;
        Ok(Self {
            ul_count_value,
            receive_status_of_ul_pdcp_sd_us,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ul_count_value.to_entropy_sink(sink)?;
        __entropic_internal_length += self.receive_status_of_ul_pdcp_sd_us.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBsSubjectToEarlyStatusTransfer_Item {
    pub drb_id: DRB_ID,
    pub first_dlcount: DRBStatusDL,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension>,
}
impl entropic::Entropic for DRBsSubjectToEarlyStatusTransfer_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let drb_id: DRB_ID = source.get_entropic()?;
        let first_dlcount: DRBStatusDL = source.get_entropic()?;
        let ie_extension: Option<DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension> =
            source.get_entropic()?;
        Ok(Self {
            drb_id,
            first_dlcount,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.drb_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.first_dlcount.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DRBsSubjectToEarlyStatusTransfer_List(pub Vec<DRBsSubjectToEarlyStatusTransfer_Item>);
impl entropic::Entropic for DRBsSubjectToEarlyStatusTransfer_List {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBsSubjectToEarlyStatusTransfer_Item::from_entropy_source(
                source,
            )?);
        }
        Ok(DRBsSubjectToEarlyStatusTransfer_List(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBsSubjectToStatusTransferItem {
    pub drb_id: DRB_ID,
    pub drb_status_ul: DRBStatusUL,
    pub drb_status_dl: DRBStatusDL,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBsSubjectToStatusTransferItemIE_Extension>,
}
impl entropic::Entropic for DRBsSubjectToStatusTransferItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let drb_id: DRB_ID = source.get_entropic()?;
        let drb_status_ul: DRBStatusUL = source.get_entropic()?;
        let drb_status_dl: DRBStatusDL = source.get_entropic()?;
        let ie_extension: Option<DRBsSubjectToStatusTransferItemIE_Extension> =
            source.get_entropic()?;
        Ok(Self {
            drb_id,
            drb_status_ul,
            drb_status_dl,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.drb_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.drb_status_ul.to_entropy_sink(sink)?;
        __entropic_internal_length += self.drb_status_dl.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DRBsSubjectToStatusTransferList(pub Vec<DRBsSubjectToStatusTransferItem>);
impl entropic::Entropic for DRBsSubjectToStatusTransferList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBsSubjectToStatusTransferItem::from_entropy_source(
                source,
            )?);
        }
        Ok(DRBsSubjectToStatusTransferList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBsToQosFlowsMappingItem {
    pub drb_id: DRB_ID,
    pub associated_qos_flow_list: AssociatedQosFlowList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DRBsToQosFlowsMappingItemIE_Extensions>,
}
impl entropic::Entropic for DRBsToQosFlowsMappingItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let drb_id: DRB_ID = source.get_entropic()?;
        let associated_qos_flow_list: AssociatedQosFlowList = source.get_entropic()?;
        let ie_extensions: Option<DRBsToQosFlowsMappingItemIE_Extensions> = None;
        Ok(Self {
            drb_id,
            associated_qos_flow_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.drb_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.associated_qos_flow_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DRBsToQosFlowsMappingList(pub Vec<DRBsToQosFlowsMappingItem>);
impl entropic::Entropic for DRBsToQosFlowsMappingList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBsToQosFlowsMappingItem::from_entropy_source(source)?);
        }
        Ok(DRBsToQosFlowsMappingList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct DataCodingScheme(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for DataCodingScheme {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(DataCodingScheme(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DataForwardingAccepted(pub u8);
impl DataForwardingAccepted {
    pub const DATA_FORWARDING_ACCEPTED: u8 = 0u8;
}
impl entropic::Entropic for DataForwardingAccepted {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DataForwardingAccepted(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DataForwardingNotPossible(pub u8);
impl DataForwardingNotPossible {
    pub const DATA_FORWARDING_NOT_POSSIBLE: u8 = 0u8;
}
impl entropic::Entropic for DataForwardingNotPossible {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DataForwardingNotPossible(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct DataForwardingResponseDRBItem {
    pub drb_id: DRB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ul_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<DataForwardingResponseDRBItemIE_Extensions>,
}
impl entropic::Entropic for DataForwardingResponseDRBItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let drb_id: DRB_ID = source.get_entropic()?;
        let dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let ul_forwarding_up_tnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let ie_extensions: Option<DataForwardingResponseDRBItemIE_Extensions> = None;
        Ok(Self {
            drb_id,
            dl_forwarding_up_tnl_information,
            ul_forwarding_up_tnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.drb_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .dl_forwarding_up_tnl_information
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .ul_forwarding_up_tnl_information
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DataForwardingResponseDRBList(pub Vec<DataForwardingResponseDRBItem>);
impl entropic::Entropic for DataForwardingResponseDRBList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DataForwardingResponseDRBItem::from_entropy_source(source)?);
        }
        Ok(DataForwardingResponseDRBList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct DataForwardingResponseERABList(pub Vec<DataForwardingResponseERABListItem>);
impl entropic::Entropic for DataForwardingResponseERABList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DataForwardingResponseERABListItem::from_entropy_source(
                source,
            )?);
        }
        Ok(DataForwardingResponseERABList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DataForwardingResponseERABListItem {
    pub e_rab_id: E_RAB_ID,
    pub dl_forwarding_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DataForwardingResponseERABListItemIE_Extensions>,
}
impl entropic::Entropic for DataForwardingResponseERABListItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let e_rab_id: E_RAB_ID = source.get_entropic()?;
        let dl_forwarding_up_tnl_information: UPTransportLayerInformation =
            source.get_entropic()?;
        let ie_extensions: Option<DataForwardingResponseERABListItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            dl_forwarding_up_tnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .dl_forwarding_up_tnl_information
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DeactivateTrace {
    pub protocol_i_es: DeactivateTraceProtocolIEs,
}
impl entropic::Entropic for DeactivateTrace {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DeactivateTraceProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct DelayCritical(pub u8);
impl DelayCritical {
    pub const DELAY_CRITICAL: u8 = 0u8;
    pub const NON_DELAY_CRITICAL: u8 = 1u8;
}
impl entropic::Entropic for DelayCritical {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DelayCritical(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DirectForwardingPathAvailability(pub u8);
impl DirectForwardingPathAvailability {
    pub const DIRECT_PATH_AVAILABLE: u8 = 0u8;
}
impl entropic::Entropic for DirectForwardingPathAvailability {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DirectForwardingPathAvailability(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNASTransport {
    pub protocol_i_es: DownlinkNASTransportProtocolIEs,
}
impl entropic::Entropic for DownlinkNASTransport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DownlinkNASTransportProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNonUEAssociatedNRPPaTransport {
    pub protocol_i_es: DownlinkNonUEAssociatedNRPPaTransportProtocolIEs,
}
impl entropic::Entropic for DownlinkNonUEAssociatedNRPPaTransport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DownlinkNonUEAssociatedNRPPaTransportProtocolIEs =
            source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRANConfigurationTransfer {
    pub protocol_i_es: DownlinkRANConfigurationTransferProtocolIEs,
}
impl entropic::Entropic for DownlinkRANConfigurationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DownlinkRANConfigurationTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRANEarlyStatusTransfer {
    pub protocol_i_es: DownlinkRANEarlyStatusTransferProtocolIEs,
}
impl entropic::Entropic for DownlinkRANEarlyStatusTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DownlinkRANEarlyStatusTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRANStatusTransfer {
    pub protocol_i_es: DownlinkRANStatusTransferProtocolIEs,
}
impl entropic::Entropic for DownlinkRANStatusTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DownlinkRANStatusTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRIMInformationTransfer {
    pub protocol_i_es: DownlinkRIMInformationTransferProtocolIEs,
}
impl entropic::Entropic for DownlinkRIMInformationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DownlinkRIMInformationTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkUEAssociatedNRPPaTransport {
    pub protocol_i_es: DownlinkUEAssociatedNRPPaTransportProtocolIEs,
}
impl entropic::Entropic for DownlinkUEAssociatedNRPPaTransport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: DownlinkUEAssociatedNRPPaTransportProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct Dynamic5QIDescriptor {
    pub priority_level_qos: PriorityLevelQos,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    #[asn(optional_idx = 0)]
    pub five_qi: Option<FiveQI>,
    #[asn(optional_idx = 1)]
    pub delay_critical: Option<DelayCritical>,
    #[asn(optional_idx = 2)]
    pub averaging_window: Option<AveragingWindow>,
    #[asn(optional_idx = 3)]
    pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<Dynamic5QIDescriptorIE_Extensions>,
}
impl entropic::Entropic for Dynamic5QIDescriptor {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let priority_level_qos: PriorityLevelQos = source.get_entropic()?;
        let packet_delay_budget: PacketDelayBudget = source.get_entropic()?;
        let packet_error_rate: PacketErrorRate = source.get_entropic()?;
        let five_qi: Option<FiveQI> = source.get_entropic()?;
        let delay_critical: Option<DelayCritical> = source.get_entropic()?;
        let averaging_window: Option<AveragingWindow> = source.get_entropic()?;
        let maximum_data_burst_volume: Option<MaximumDataBurstVolume> = source.get_entropic()?;
        let ie_extensions: Option<Dynamic5QIDescriptorIE_Extensions> = None;
        Ok(Self {
            priority_level_qos,
            packet_delay_budget,
            packet_error_rate,
            five_qi,
            delay_critical,
            averaging_window,
            maximum_data_burst_volume,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.priority_level_qos.to_entropy_sink(sink)?;
        __entropic_internal_length += self.packet_delay_budget.to_entropy_sink(sink)?;
        __entropic_internal_length += self.packet_error_rate.to_entropy_sink(sink)?;
        __entropic_internal_length += self.five_qi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.delay_critical.to_entropy_sink(sink)?;
        __entropic_internal_length += self.averaging_window.to_entropy_sink(sink)?;
        __entropic_internal_length += self.maximum_data_burst_volume.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct E_RAB_ID(pub u8);
impl entropic::Entropic for E_RAB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(E_RAB_ID(source.get_uniform_range(0..=15)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABInformationItem {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DLForwarding>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABInformationItemIE_Extensions>,
}
impl entropic::Entropic for E_RABInformationItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let e_rab_id: E_RAB_ID = source.get_entropic()?;
        let dl_forwarding: Option<DLForwarding> = source.get_entropic()?;
        let ie_extensions: Option<E_RABInformationItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            dl_forwarding,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.dl_forwarding.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABInformationList(pub Vec<E_RABInformationItem>);
impl entropic::Entropic for E_RABInformationList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABInformationItem::from_entropy_source(source)?);
        }
        Ok(E_RABInformationList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EDT_Session(pub u8);
impl EDT_Session {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for EDT_Session {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(EDT_Session(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct EN_DCSONConfigurationTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum ENB_ID {
    #[asn(key = 0, extended = false)]
    MacroENB_ID(ENB_ID_macroENB_ID),
    #[asn(key = 1, extended = false)]
    HomeENB_ID(ENB_ID_homeENB_ID),
    #[asn(key = 2, extended = false)]
    Short_macroENB_ID(ENB_ID_short_macroENB_ID),
    #[asn(key = 3, extended = false)]
    Long_macroENB_ID(ENB_ID_long_macroENB_ID),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(ENB_ID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for ENB_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            ENB_ID::MacroENB_ID(_) => 0u128.try_into().unwrap(),
            ENB_ID::HomeENB_ID(_) => 1u128.try_into().unwrap(),
            ENB_ID::Short_macroENB_ID(_) => 2u128.try_into().unwrap(),
            ENB_ID::Long_macroENB_ID(_) => 3u128.try_into().unwrap(),
            ENB_ID::Choice_Extensions(_) => 4u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct EPS_TAC(pub Vec<u8>);
impl entropic::Entropic for EPS_TAC {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(EPS_TAC(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EPS_TAI {
    pub plmn_identity: PLMNIdentity,
    pub eps_tac: EPS_TAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EPS_TAIIE_Extensions>,
}
impl entropic::Entropic for EPS_TAI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let eps_tac: EPS_TAC = source.get_entropic()?;
        let ie_extensions: Option<EPS_TAIIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            eps_tac,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.eps_tac.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EUTRA_CGI {
    pub plmn_identity: PLMNIdentity,
    pub eutra_cell_identity: EUTRACellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EUTRA_CGIIE_Extensions>,
}
impl entropic::Entropic for EUTRA_CGI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let eutra_cell_identity: EUTRACellIdentity = source.get_entropic()?;
        let ie_extensions: Option<EUTRA_CGIIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            eutra_cell_identity,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.eutra_cell_identity.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct EUTRA_CGIList(pub Vec<EUTRA_CGI>);
impl entropic::Entropic for EUTRA_CGIList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRA_CGI::from_entropy_source(source)?);
        }
        Ok(EUTRA_CGIList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EUTRA_CGIListForWarning(pub Vec<EUTRA_CGI>);
impl entropic::Entropic for EUTRA_CGIListForWarning {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRA_CGI::from_entropy_source(source)?);
        }
        Ok(EUTRA_CGIListForWarning(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct EUTRACellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for EUTRACellIdentity {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(28, 16383);
        let total_bitlen = source.get_bounded_len(28..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(EUTRACellIdentity(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 28);
        let capped_max = std::cmp::min(28, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(28..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct EUTRAencryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for EUTRAencryptionAlgorithms {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(EUTRAencryptionAlgorithms(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct EUTRAintegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for EUTRAintegrityProtectionAlgorithms {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(EUTRAintegrityProtectionAlgorithms(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EarlyStatusTransfer_TransparentContainer {
    pub procedure_stage: ProcedureStageChoice,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EarlyStatusTransfer_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for EarlyStatusTransfer_TransparentContainer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let procedure_stage: ProcedureStageChoice = source.get_entropic()?;
        let ie_extensions: Option<EarlyStatusTransfer_TransparentContainerIE_Extensions> = None;
        Ok(Self {
            procedure_stage,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.procedure_stage.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct EmergencyAreaID(pub Vec<u8>);
impl entropic::Entropic for EmergencyAreaID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(EmergencyAreaID(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastEUTRA(pub Vec<EmergencyAreaIDBroadcastEUTRA_Item>);
impl entropic::Entropic for EmergencyAreaIDBroadcastEUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaIDBroadcastEUTRA_Item::from_entropy_source(
                source,
            )?);
        }
        Ok(EmergencyAreaIDBroadcastEUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDBroadcastEUTRA_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub completed_cells_in_eai_eutra: CompletedCellsInEAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for EmergencyAreaIDBroadcastEUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let emergency_area_id: EmergencyAreaID = source.get_entropic()?;
        let completed_cells_in_eai_eutra: CompletedCellsInEAI_EUTRA = source.get_entropic()?;
        let ie_extensions: Option<EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            emergency_area_id,
            completed_cells_in_eai_eutra,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.emergency_area_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.completed_cells_in_eai_eutra.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastNR(pub Vec<EmergencyAreaIDBroadcastNR_Item>);
impl entropic::Entropic for EmergencyAreaIDBroadcastNR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaIDBroadcastNR_Item::from_entropy_source(
                source,
            )?);
        }
        Ok(EmergencyAreaIDBroadcastNR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDBroadcastNR_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub completed_cells_in_eai_nr: CompletedCellsInEAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDBroadcastNR_ItemIE_Extensions>,
}
impl entropic::Entropic for EmergencyAreaIDBroadcastNR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let emergency_area_id: EmergencyAreaID = source.get_entropic()?;
        let completed_cells_in_eai_nr: CompletedCellsInEAI_NR = source.get_entropic()?;
        let ie_extensions: Option<EmergencyAreaIDBroadcastNR_ItemIE_Extensions> = None;
        Ok(Self {
            emergency_area_id,
            completed_cells_in_eai_nr,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.emergency_area_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.completed_cells_in_eai_nr.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledEUTRA(pub Vec<EmergencyAreaIDCancelledEUTRA_Item>);
impl entropic::Entropic for EmergencyAreaIDCancelledEUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaIDCancelledEUTRA_Item::from_entropy_source(
                source,
            )?);
        }
        Ok(EmergencyAreaIDCancelledEUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDCancelledEUTRA_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub cancelled_cells_in_eai_eutra: CancelledCellsInEAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for EmergencyAreaIDCancelledEUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let emergency_area_id: EmergencyAreaID = source.get_entropic()?;
        let cancelled_cells_in_eai_eutra: CancelledCellsInEAI_EUTRA = source.get_entropic()?;
        let ie_extensions: Option<EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            emergency_area_id,
            cancelled_cells_in_eai_eutra,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.emergency_area_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cancelled_cells_in_eai_eutra.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledNR(pub Vec<EmergencyAreaIDCancelledNR_Item>);
impl entropic::Entropic for EmergencyAreaIDCancelledNR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaIDCancelledNR_Item::from_entropy_source(
                source,
            )?);
        }
        Ok(EmergencyAreaIDCancelledNR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDCancelledNR_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub cancelled_cells_in_eai_nr: CancelledCellsInEAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDCancelledNR_ItemIE_Extensions>,
}
impl entropic::Entropic for EmergencyAreaIDCancelledNR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let emergency_area_id: EmergencyAreaID = source.get_entropic()?;
        let cancelled_cells_in_eai_nr: CancelledCellsInEAI_NR = source.get_entropic()?;
        let ie_extensions: Option<EmergencyAreaIDCancelledNR_ItemIE_Extensions> = None;
        Ok(Self {
            emergency_area_id,
            cancelled_cells_in_eai_nr,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.emergency_area_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cancelled_cells_in_eai_nr.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDList(pub Vec<EmergencyAreaID>);
impl entropic::Entropic for EmergencyAreaIDList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID::from_entropy_source(source)?);
        }
        Ok(EmergencyAreaIDList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct EmergencyAreaIDListForRestart(pub Vec<EmergencyAreaID>);
impl entropic::Entropic for EmergencyAreaIDListForRestart {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID::from_entropy_source(source)?);
        }
        Ok(EmergencyAreaIDListForRestart(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct EmergencyFallbackIndicator {
    pub emergency_fallback_request_indicator: EmergencyFallbackRequestIndicator,
    #[asn(optional_idx = 0)]
    pub emergency_service_target_cn: Option<EmergencyServiceTargetCN>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<EmergencyFallbackIndicatorIE_Extensions>,
}
impl entropic::Entropic for EmergencyFallbackIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let emergency_fallback_request_indicator: EmergencyFallbackRequestIndicator =
            source.get_entropic()?;
        let emergency_service_target_cn: Option<EmergencyServiceTargetCN> =
            source.get_entropic()?;
        let ie_extensions: Option<EmergencyFallbackIndicatorIE_Extensions> = None;
        Ok(Self {
            emergency_fallback_request_indicator,
            emergency_service_target_cn,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .emergency_fallback_request_indicator
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.emergency_service_target_cn.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EmergencyFallbackRequestIndicator(pub u8);
impl EmergencyFallbackRequestIndicator {
    pub const EMERGENCY_FALLBACK_REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for EmergencyFallbackRequestIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(EmergencyFallbackRequestIndicator(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EmergencyServiceTargetCN(pub u8);
impl EmergencyServiceTargetCN {
    pub const FIVE_GC: u8 = 0u8;
    pub const EPC: u8 = 1u8;
}
impl entropic::Entropic for EmergencyServiceTargetCN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(EmergencyServiceTargetCN(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EndIndication(pub u8);
impl EndIndication {
    pub const NO_FURTHER_DATA: u8 = 0u8;
    pub const FURTHER_DATA_EXISTS: u8 = 1u8;
}
impl entropic::Entropic for EndIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(EndIndication(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct EndpointIPAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
    pub port_number: PortNumber,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EndpointIPAddressAndPortIE_Extensions>,
}
impl entropic::Entropic for EndpointIPAddressAndPort {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let endpoint_ip_address: TransportLayerAddress = source.get_entropic()?;
        let port_number: PortNumber = source.get_entropic()?;
        let ie_extensions: Option<EndpointIPAddressAndPortIE_Extensions> = None;
        Ok(Self {
            endpoint_ip_address,
            port_number,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.endpoint_ip_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.port_number.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Enhanced_CoverageRestriction(pub u8);
impl Enhanced_CoverageRestriction {
    pub const RESTRICTED: u8 = 0u8;
}
impl entropic::Entropic for Enhanced_CoverageRestriction {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Enhanced_CoverageRestriction(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct EquivalentPLMNs(pub Vec<PLMNIdentity>);
impl entropic::Entropic for EquivalentPLMNs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(15, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNIdentity::from_entropy_source(source)?);
        }
        Ok(EquivalentPLMNs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(15, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ErrorIndication {
    pub protocol_i_es: ErrorIndicationProtocolIEs,
}
impl entropic::Entropic for ErrorIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: ErrorIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EventL1LoggedMDTConfig {
    pub l1_threshold: MeasurementThresholdL1LoggedMDT,
    pub hysteresis: Hysteresis,
    pub time_to_trigger: TimeToTrigger,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EventL1LoggedMDTConfigIE_Extensions>,
}
impl entropic::Entropic for EventL1LoggedMDTConfig {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let l1_threshold: MeasurementThresholdL1LoggedMDT = source.get_entropic()?;
        let hysteresis: Hysteresis = source.get_entropic()?;
        let time_to_trigger: TimeToTrigger = source.get_entropic()?;
        let ie_extensions: Option<EventL1LoggedMDTConfigIE_Extensions> = None;
        Ok(Self {
            l1_threshold,
            hysteresis,
            time_to_trigger,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.l1_threshold.to_entropy_sink(sink)?;
        __entropic_internal_length += self.hysteresis.to_entropy_sink(sink)?;
        __entropic_internal_length += self.time_to_trigger.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum EventTrigger {
    #[asn(key = 0, extended = false)]
    OutOfCoverage(EventTrigger_outOfCoverage),
    #[asn(key = 1, extended = false)]
    EventL1LoggedMDTConfig(EventL1LoggedMDTConfig),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(EventTrigger_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for EventTrigger {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            EventTrigger::OutOfCoverage(_) => 0u128.try_into().unwrap(),
            EventTrigger::EventL1LoggedMDTConfig(_) => 1u128.try_into().unwrap(),
            EventTrigger::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct EventType(pub u8);
impl EventType {
    pub const DIRECT: u8 = 0u8;
    pub const CHANGE_OF_SERVE_CELL: u8 = 1u8;
    pub const UE_PRESENCE_IN_AREA_OF_INTEREST: u8 = 2u8;
    pub const STOP_CHANGE_OF_SERVE_CELL: u8 = 3u8;
    pub const STOP_UE_PRESENCE_IN_AREA_OF_INTEREST: u8 = 4u8;
    pub const CANCEL_LOCATION_REPORTING_FOR_THE_UE: u8 = 5u8;
}
impl entropic::Entropic for EventType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(EventType(source.get_uniform_range(0..=5)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedActivityPeriod(pub u8);
impl entropic::Entropic for ExpectedActivityPeriod {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ExpectedActivityPeriod(source.get_uniform_range(1..=30)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=30 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct ExpectedHOInterval(pub u8);
impl ExpectedHOInterval {
    pub const SEC15: u8 = 0u8;
    pub const SEC30: u8 = 1u8;
    pub const SEC60: u8 = 2u8;
    pub const SEC90: u8 = 3u8;
    pub const SEC120: u8 = 4u8;
    pub const SEC180: u8 = 5u8;
    pub const LONG_TIME: u8 = 6u8;
}
impl entropic::Entropic for ExpectedHOInterval {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ExpectedHOInterval(source.get_uniform_range(0..=6)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=6 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedIdlePeriod(pub u8);
impl entropic::Entropic for ExpectedIdlePeriod {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ExpectedIdlePeriod(source.get_uniform_range(1..=30)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=30 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ExpectedUEActivityBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity_period: Option<ExpectedActivityPeriod>,
    #[asn(optional_idx = 1)]
    pub expected_idle_period: Option<ExpectedIdlePeriod>,
    #[asn(optional_idx = 2)]
    pub source_of_ue_activity_behaviour_information: Option<SourceOfUEActivityBehaviourInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ExpectedUEActivityBehaviourIE_Extensions>,
}
impl entropic::Entropic for ExpectedUEActivityBehaviour {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let expected_activity_period: Option<ExpectedActivityPeriod> = source.get_entropic()?;
        let expected_idle_period: Option<ExpectedIdlePeriod> = source.get_entropic()?;
        let source_of_ue_activity_behaviour_information: Option<
            SourceOfUEActivityBehaviourInformation,
        > = source.get_entropic()?;
        let ie_extensions: Option<ExpectedUEActivityBehaviourIE_Extensions> = None;
        Ok(Self {
            expected_activity_period,
            expected_idle_period,
            source_of_ue_activity_behaviour_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.expected_activity_period.to_entropy_sink(sink)?;
        __entropic_internal_length += self.expected_idle_period.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .source_of_ue_activity_behaviour_information
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct ExpectedUEBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_ue_activity_behaviour: Option<ExpectedUEActivityBehaviour>,
    #[asn(optional_idx = 1)]
    pub expected_ho_interval: Option<ExpectedHOInterval>,
    #[asn(optional_idx = 2)]
    pub expected_ue_mobility: Option<ExpectedUEMobility>,
    #[asn(optional_idx = 3)]
    pub expected_ue_moving_trajectory: Option<ExpectedUEMovingTrajectory>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<ExpectedUEBehaviourIE_Extensions>,
}
impl entropic::Entropic for ExpectedUEBehaviour {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let expected_ue_activity_behaviour: Option<ExpectedUEActivityBehaviour> =
            source.get_entropic()?;
        let expected_ho_interval: Option<ExpectedHOInterval> = source.get_entropic()?;
        let expected_ue_mobility: Option<ExpectedUEMobility> = source.get_entropic()?;
        let expected_ue_moving_trajectory: Option<ExpectedUEMovingTrajectory> =
            source.get_entropic()?;
        let ie_extensions: Option<ExpectedUEBehaviourIE_Extensions> = None;
        Ok(Self {
            expected_ue_activity_behaviour,
            expected_ho_interval,
            expected_ue_mobility,
            expected_ue_moving_trajectory,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.expected_ue_activity_behaviour.to_entropy_sink(sink)?;
        __entropic_internal_length += self.expected_ho_interval.to_entropy_sink(sink)?;
        __entropic_internal_length += self.expected_ue_mobility.to_entropy_sink(sink)?;
        __entropic_internal_length += self.expected_ue_moving_trajectory.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ExpectedUEMobility(pub u8);
impl ExpectedUEMobility {
    pub const STATIONARY: u8 = 0u8;
    pub const MOBILE: u8 = 1u8;
}
impl entropic::Entropic for ExpectedUEMobility {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ExpectedUEMobility(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ExpectedUEMovingTrajectory(pub Vec<ExpectedUEMovingTrajectoryItem>);
impl entropic::Entropic for ExpectedUEMovingTrajectory {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ExpectedUEMovingTrajectoryItem::from_entropy_source(source)?);
        }
        Ok(ExpectedUEMovingTrajectory(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ExpectedUEMovingTrajectoryItem {
    pub ngran_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub time_stayed_in_cell: Option<ExpectedUEMovingTrajectoryItemTimeStayedInCell>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ExpectedUEMovingTrajectoryItemIE_Extensions>,
}
impl entropic::Entropic for ExpectedUEMovingTrajectoryItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ngran_cgi: NGRAN_CGI = source.get_entropic()?;
        let time_stayed_in_cell: Option<ExpectedUEMovingTrajectoryItemTimeStayedInCell> =
            source.get_entropic()?;
        let ie_extensions: Option<ExpectedUEMovingTrajectoryItemIE_Extensions> = None;
        Ok(Self {
            ngran_cgi,
            time_stayed_in_cell,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ngran_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.time_stayed_in_cell.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct Extended_AMFName {
    #[asn(optional_idx = 0)]
    pub amf_name_visible_string: Option<AMFNameVisibleString>,
    #[asn(optional_idx = 1)]
    pub amf_name_utf8_string: Option<AMFNameUTF8String>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<Extended_AMFNameIE_Extensions>,
}
impl entropic::Entropic for Extended_AMFName {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_name_visible_string: Option<AMFNameVisibleString> = source.get_entropic()?;
        let amf_name_utf8_string: Option<AMFNameUTF8String> = source.get_entropic()?;
        let ie_extensions: Option<Extended_AMFNameIE_Extensions> = None;
        Ok(Self {
            amf_name_visible_string,
            amf_name_utf8_string,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_name_visible_string.to_entropy_sink(sink)?;
        __entropic_internal_length += self.amf_name_utf8_string.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct Extended_ConnectedTime(pub u8);
impl entropic::Entropic for Extended_ConnectedTime {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Extended_ConnectedTime(source.get_uniform_range(0..=255)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct Extended_RANNodeName {
    #[asn(optional_idx = 0)]
    pub ran_node_name_visible_string: Option<RANNodeNameVisibleString>,
    #[asn(optional_idx = 1)]
    pub ran_node_name_utf8_string: Option<RANNodeNameUTF8String>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<Extended_RANNodeNameIE_Extensions>,
}
impl entropic::Entropic for Extended_RANNodeName {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ran_node_name_visible_string: Option<RANNodeNameVisibleString> =
            source.get_entropic()?;
        let ran_node_name_utf8_string: Option<RANNodeNameUTF8String> = source.get_entropic()?;
        let ie_extensions: Option<Extended_RANNodeNameIE_Extensions> = None;
        Ok(Self {
            ran_node_name_visible_string,
            ran_node_name_utf8_string,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ran_node_name_visible_string.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ran_node_name_utf8_string.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "65535", extensible = true)]
pub struct ExtendedPacketDelayBudget(pub u16);
impl entropic::Entropic for ExtendedPacketDelayBudget {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ExtendedPacketDelayBudget(
            source.get_uniform_range(1..=65535)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ExtendedRATRestrictionInformation {
    pub primary_rat_restriction: ExtendedRATRestrictionInformationPrimaryRATRestriction,
    pub secondary_rat_restriction: ExtendedRATRestrictionInformationSecondaryRATRestriction,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ExtendedRATRestrictionInformationIE_Extensions>,
}
impl entropic::Entropic for ExtendedRATRestrictionInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let primary_rat_restriction: ExtendedRATRestrictionInformationPrimaryRATRestriction =
            source.get_entropic()?;
        let secondary_rat_restriction: ExtendedRATRestrictionInformationSecondaryRATRestriction =
            source.get_entropic()?;
        let ie_extensions: Option<ExtendedRATRestrictionInformationIE_Extensions> = None;
        Ok(Self {
            primary_rat_restriction,
            secondary_rat_restriction,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.primary_rat_restriction.to_entropy_sink(sink)?;
        __entropic_internal_length += self.secondary_rat_restriction.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "4096", ub = "65535")]
pub struct ExtendedRNC_ID(pub u16);
impl entropic::Entropic for ExtendedRNC_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ExtendedRNC_ID(source.get_uniform_range(4096..=65535)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(4096..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExtendedSliceSupportList(pub Vec<SliceSupportItem>);
impl entropic::Entropic for ExtendedSliceSupportList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SliceSupportItem::from_entropy_source(source)?);
        }
        Ok(ExtendedSliceSupportList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct ExtendedUEIdentityIndexValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ExtendedUEIdentityIndexValue {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ExtendedUEIdentityIndexValue(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FailureIndication {
    pub uerlf_report_container: UERLFReportContainer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FailureIndicationIE_Extensions>,
}
impl entropic::Entropic for FailureIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let uerlf_report_container: UERLFReportContainer = source.get_entropic()?;
        let ie_extensions: Option<FailureIndicationIE_Extensions> = None;
        Ok(Self {
            uerlf_report_container,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.uerlf_report_container.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FirstDLCount {
    pub dr_bs_subject_to_early_status_transfer: DRBsSubjectToEarlyStatusTransfer_List,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<FirstDLCountIE_Extension>,
}
impl entropic::Entropic for FirstDLCount {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dr_bs_subject_to_early_status_transfer: DRBsSubjectToEarlyStatusTransfer_List =
            source.get_entropic()?;
        let ie_extension: Option<FirstDLCountIE_Extension> = source.get_entropic()?;
        Ok(Self {
            dr_bs_subject_to_early_status_transfer,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .dr_bs_subject_to_early_status_transfer
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FiveG_S_TMSI {
    pub amf_set_id: AMFSetID,
    pub amf_pointer: AMFPointer,
    pub five_g_tmsi: FiveG_TMSI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FiveG_S_TMSIIE_Extensions>,
}
impl entropic::Entropic for FiveG_S_TMSI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_set_id: AMFSetID = source.get_entropic()?;
        let amf_pointer: AMFPointer = source.get_entropic()?;
        let five_g_tmsi: FiveG_TMSI = source.get_entropic()?;
        let ie_extensions: Option<FiveG_S_TMSIIE_Extensions> = None;
        Ok(Self {
            amf_set_id,
            amf_pointer,
            five_g_tmsi,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_set_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.amf_pointer.to_entropy_sink(sink)?;
        __entropic_internal_length += self.five_g_tmsi.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct FiveG_TMSI(pub Vec<u8>);
impl entropic::Entropic for FiveG_TMSI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(FiveG_TMSI(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct FiveQI(pub u8);
impl entropic::Entropic for FiveQI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(FiveQI(source.get_uniform_range(0..=255)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenAreaInformation(pub Vec<ForbiddenAreaInformation_Item>);
impl entropic::Entropic for ForbiddenAreaInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ForbiddenAreaInformation_Item::from_entropy_source(source)?);
        }
        Ok(ForbiddenAreaInformation(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenAreaInformation_Item {
    pub plmn_identity: PLMNIdentity,
    pub forbidden_ta_cs: ForbiddenTACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenAreaInformation_ItemIE_Extensions>,
}
impl entropic::Entropic for ForbiddenAreaInformation_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let forbidden_ta_cs: ForbiddenTACs = source.get_entropic()?;
        let ie_extensions: Option<ForbiddenAreaInformation_ItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            forbidden_ta_cs,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.forbidden_ta_cs.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenTACs(pub Vec<TAC>);
impl entropic::Entropic for ForbiddenTACs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4096, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAC::from_entropy_source(source)?);
        }
        Ok(ForbiddenTACs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4096, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FromEUTRANtoNGRAN {
    pub sourcee_nbid: IntersystemSONeNBID,
    pub target_ngra_nnode_id: IntersystemSONNGRANnodeID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FromEUTRANtoNGRANIE_Extensions>,
}
impl entropic::Entropic for FromEUTRANtoNGRAN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let sourcee_nbid: IntersystemSONeNBID = source.get_entropic()?;
        let target_ngra_nnode_id: IntersystemSONNGRANnodeID = source.get_entropic()?;
        let ie_extensions: Option<FromEUTRANtoNGRANIE_Extensions> = None;
        Ok(Self {
            sourcee_nbid,
            target_ngra_nnode_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.sourcee_nbid.to_entropy_sink(sink)?;
        __entropic_internal_length += self.target_ngra_nnode_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FromNGRANtoEUTRAN {
    pub source_ngra_nnode_id: IntersystemSONNGRANnodeID,
    pub targete_nbid: IntersystemSONeNBID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FromNGRANtoEUTRANIE_Extensions>,
}
impl entropic::Entropic for FromNGRANtoEUTRAN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let source_ngra_nnode_id: IntersystemSONNGRANnodeID = source.get_entropic()?;
        let targete_nbid: IntersystemSONeNBID = source.get_entropic()?;
        let ie_extensions: Option<FromNGRANtoEUTRANIE_Extensions> = None;
        Ok(Self {
            source_ngra_nnode_id,
            targete_nbid,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.source_ngra_nnode_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.targete_nbid.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct GBR_QosInformation {
    pub maximum_flow_bit_rate_dl: BitRate,
    pub maximum_flow_bit_rate_ul: BitRate,
    pub guaranteed_flow_bit_rate_dl: BitRate,
    pub guaranteed_flow_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub notification_control: Option<NotificationControl>,
    #[asn(optional_idx = 1)]
    pub maximum_packet_loss_rate_dl: Option<PacketLossRate>,
    #[asn(optional_idx = 2)]
    pub maximum_packet_loss_rate_ul: Option<PacketLossRate>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<GBR_QosInformationIE_Extensions>,
}
impl entropic::Entropic for GBR_QosInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let maximum_flow_bit_rate_dl: BitRate = source.get_entropic()?;
        let maximum_flow_bit_rate_ul: BitRate = source.get_entropic()?;
        let guaranteed_flow_bit_rate_dl: BitRate = source.get_entropic()?;
        let guaranteed_flow_bit_rate_ul: BitRate = source.get_entropic()?;
        let notification_control: Option<NotificationControl> = source.get_entropic()?;
        let maximum_packet_loss_rate_dl: Option<PacketLossRate> = source.get_entropic()?;
        let maximum_packet_loss_rate_ul: Option<PacketLossRate> = source.get_entropic()?;
        let ie_extensions: Option<GBR_QosInformationIE_Extensions> = None;
        Ok(Self {
            maximum_flow_bit_rate_dl,
            maximum_flow_bit_rate_ul,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            notification_control,
            maximum_packet_loss_rate_dl,
            maximum_packet_loss_rate_ul,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.maximum_flow_bit_rate_dl.to_entropy_sink(sink)?;
        __entropic_internal_length += self.maximum_flow_bit_rate_ul.to_entropy_sink(sink)?;
        __entropic_internal_length += self.guaranteed_flow_bit_rate_dl.to_entropy_sink(sink)?;
        __entropic_internal_length += self.guaranteed_flow_bit_rate_ul.to_entropy_sink(sink)?;
        __entropic_internal_length += self.notification_control.to_entropy_sink(sink)?;
        __entropic_internal_length += self.maximum_packet_loss_rate_dl.to_entropy_sink(sink)?;
        __entropic_internal_length += self.maximum_packet_loss_rate_ul.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum GNB_ID {
    #[asn(key = 0, extended = false)]
    GNB_ID(GNB_ID_gNB_ID),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(GNB_ID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for GNB_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            GNB_ID::GNB_ID(_) => 0u128.try_into().unwrap(),
            GNB_ID::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "22", sz_ub = "22")]
pub struct GNBSetID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for GNBSetID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(22, 16383);
        let total_bitlen = source.get_bounded_len(22..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(GNBSetID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 22);
        let capped_max = std::cmp::min(22, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(22..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct GTP_TEID(pub Vec<u8>);
impl entropic::Entropic for GTP_TEID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(GTP_TEID(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GTPTunnel {
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GTPTunnelIE_Extensions>,
}
impl entropic::Entropic for GTPTunnel {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let transport_layer_address: TransportLayerAddress = source.get_entropic()?;
        let gtp_teid: GTP_TEID = source.get_entropic()?;
        let ie_extensions: Option<GTPTunnelIE_Extensions> = None;
        Ok(Self {
            transport_layer_address,
            gtp_teid,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.transport_layer_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.gtp_teid.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GUAMI {
    pub plmn_identity: PLMNIdentity,
    pub amf_region_id: AMFRegionID,
    pub amf_set_id: AMFSetID,
    pub amf_pointer: AMFPointer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GUAMIIE_Extensions>,
}
impl entropic::Entropic for GUAMI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let amf_region_id: AMFRegionID = source.get_entropic()?;
        let amf_set_id: AMFSetID = source.get_entropic()?;
        let amf_pointer: AMFPointer = source.get_entropic()?;
        let ie_extensions: Option<GUAMIIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            amf_region_id,
            amf_set_id,
            amf_pointer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.amf_region_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.amf_set_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.amf_pointer.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct GUAMIType(pub u8);
impl GUAMIType {
    pub const NATIVE: u8 = 0u8;
    pub const MAPPED: u8 = 1u8;
}
impl entropic::Entropic for GUAMIType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(GUAMIType(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct GlobalCable_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalENB_ID {
    pub plm_nidentity: PLMNIdentity,
    pub enb_id: ENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalENB_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plm_nidentity: PLMNIdentity = source.get_entropic()?;
        let enb_id: ENB_ID = source.get_entropic()?;
        let ie_extensions: Option<GlobalENB_IDIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            enb_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plm_nidentity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.enb_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalGNB_ID {
    pub plmn_identity: PLMNIdentity,
    pub gnb_id: GNB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalGNB_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalGNB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let gnb_id: GNB_ID = source.get_entropic()?;
        let ie_extensions: Option<GlobalGNB_IDIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            gnb_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.gnb_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct GlobalLine_ID {
    pub global_line_identity: GlobalLineIdentity,
    #[asn(optional_idx = 0)]
    pub line_type: Option<LineType>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<GlobalLine_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalLine_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let global_line_identity: GlobalLineIdentity = source.get_entropic()?;
        let line_type: Option<LineType> = source.get_entropic()?;
        let ie_extensions: Option<GlobalLine_IDIE_Extensions> = None;
        Ok(Self {
            global_line_identity,
            line_type,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.global_line_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.line_type.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct GlobalLineIdentity(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalN3IWF_ID {
    pub plmn_identity: PLMNIdentity,
    pub n3iwf_id: N3IWF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalN3IWF_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalN3IWF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let n3iwf_id: N3IWF_ID = source.get_entropic()?;
        let ie_extensions: Option<GlobalN3IWF_IDIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            n3iwf_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.n3iwf_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalNgENB_ID {
    pub plmn_identity: PLMNIdentity,
    pub ng_enb_id: NgENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalNgENB_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalNgENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let ng_enb_id: NgENB_ID = source.get_entropic()?;
        let ie_extensions: Option<GlobalNgENB_IDIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            ng_enb_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ng_enb_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum GlobalRANNodeID {
    #[asn(key = 0, extended = false)]
    GlobalGNB_ID(GlobalGNB_ID),
    #[asn(key = 1, extended = false)]
    GlobalNgENB_ID(GlobalNgENB_ID),
    #[asn(key = 2, extended = false)]
    GlobalN3IWF_ID(GlobalN3IWF_ID),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(GlobalRANNodeID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for GlobalRANNodeID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            GlobalRANNodeID::GlobalGNB_ID(_) => 0u128.try_into().unwrap(),
            GlobalRANNodeID::GlobalNgENB_ID(_) => 1u128.try_into().unwrap(),
            GlobalRANNodeID::GlobalN3IWF_ID(_) => 2u128.try_into().unwrap(),
            GlobalRANNodeID::Choice_Extensions(_) => 3u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalTNGF_ID {
    pub plmn_identity: PLMNIdentity,
    pub tngf_id: TNGF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalTNGF_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalTNGF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let tngf_id: TNGF_ID = source.get_entropic()?;
        let ie_extensions: Option<GlobalTNGF_IDIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            tngf_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tngf_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalTWIF_ID {
    pub plmn_identity: PLMNIdentity,
    pub twif_id: TWIF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalTWIF_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalTWIF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let twif_id: TWIF_ID = source.get_entropic()?;
        let ie_extensions: Option<GlobalTWIF_IDIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            twif_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.twif_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalW_AGF_ID {
    pub plmn_identity: PLMNIdentity,
    pub w_agf_id: W_AGF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalW_AGF_IDIE_Extensions>,
}
impl entropic::Entropic for GlobalW_AGF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let w_agf_id: W_AGF_ID = source.get_entropic()?;
        let ie_extensions: Option<GlobalW_AGF_IDIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            w_agf_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.w_agf_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HFCNode_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct HOReport {
    pub handover_report_type: HOReportHandoverReportType,
    pub handover_cause: Cause,
    pub sourcecell_cgi: NGRAN_CGI,
    pub targetcell_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub reestablishmentcell_cgi: Option<NGRAN_CGI>,
    #[asn(optional_idx = 1)]
    pub sourcecell_c_rnti: Option<HOReportSourcecellC_RNTI>,
    #[asn(optional_idx = 2)]
    pub targetcellin_e_utran: Option<EUTRA_CGI>,
    #[asn(optional_idx = 3)]
    pub mobility_information: Option<MobilityInformation>,
    #[asn(optional_idx = 4)]
    pub uerlf_report_container: Option<UERLFReportContainer>,
    #[asn(optional_idx = 5)]
    pub ie_extensions: Option<HOReportIE_Extensions>,
}
impl entropic::Entropic for HOReport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let handover_report_type: HOReportHandoverReportType = source.get_entropic()?;
        let handover_cause: Cause = source.get_entropic()?;
        let sourcecell_cgi: NGRAN_CGI = source.get_entropic()?;
        let targetcell_cgi: NGRAN_CGI = source.get_entropic()?;
        let reestablishmentcell_cgi: Option<NGRAN_CGI> = source.get_entropic()?;
        let sourcecell_c_rnti: Option<HOReportSourcecellC_RNTI> = source.get_entropic()?;
        let targetcellin_e_utran: Option<EUTRA_CGI> = source.get_entropic()?;
        let mobility_information: Option<MobilityInformation> = source.get_entropic()?;
        let uerlf_report_container: Option<UERLFReportContainer> = source.get_entropic()?;
        let ie_extensions: Option<HOReportIE_Extensions> = None;
        Ok(Self {
            handover_report_type,
            handover_cause,
            sourcecell_cgi,
            targetcell_cgi,
            reestablishmentcell_cgi,
            sourcecell_c_rnti,
            targetcellin_e_utran,
            mobility_information,
            uerlf_report_container,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.handover_report_type.to_entropy_sink(sink)?;
        __entropic_internal_length += self.handover_cause.to_entropy_sink(sink)?;
        __entropic_internal_length += self.sourcecell_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.targetcell_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.reestablishmentcell_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.sourcecell_c_rnti.to_entropy_sink(sink)?;
        __entropic_internal_length += self.targetcellin_e_utran.to_entropy_sink(sink)?;
        __entropic_internal_length += self.mobility_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.uerlf_report_container.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancel {
    pub protocol_i_es: HandoverCancelProtocolIEs,
}
impl entropic::Entropic for HandoverCancel {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverCancelProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancelAcknowledge {
    pub protocol_i_es: HandoverCancelAcknowledgeProtocolIEs,
}
impl entropic::Entropic for HandoverCancelAcknowledge {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverCancelAcknowledgeProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCommand {
    pub protocol_i_es: HandoverCommandProtocolIEs,
}
impl entropic::Entropic for HandoverCommand {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverCommandProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct HandoverCommandTransfer {
    #[asn(optional_idx = 0)]
    pub dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub qos_flow_to_be_forwarded_list: Option<QosFlowToBeForwardedList>,
    #[asn(optional_idx = 2)]
    pub data_forwarding_response_drb_list: Option<DataForwardingResponseDRBList>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<HandoverCommandTransferIE_Extensions>,
}
impl entropic::Entropic for HandoverCommandTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let qos_flow_to_be_forwarded_list: Option<QosFlowToBeForwardedList> =
            source.get_entropic()?;
        let data_forwarding_response_drb_list: Option<DataForwardingResponseDRBList> =
            source.get_entropic()?;
        let ie_extensions: Option<HandoverCommandTransferIE_Extensions> = None;
        Ok(Self {
            dl_forwarding_up_tnl_information,
            qos_flow_to_be_forwarded_list,
            data_forwarding_response_drb_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .dl_forwarding_up_tnl_information
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_to_be_forwarded_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .data_forwarding_response_drb_list
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverFailure {
    pub protocol_i_es: HandoverFailureProtocolIEs,
}
impl entropic::Entropic for HandoverFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct HandoverFlag(pub u8);
impl HandoverFlag {
    pub const HANDOVER_PREPARATION: u8 = 0u8;
}
impl entropic::Entropic for HandoverFlag {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(HandoverFlag(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverNotify {
    pub protocol_i_es: HandoverNotifyProtocolIEs,
}
impl entropic::Entropic for HandoverNotify {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverNotifyProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverPreparationFailure {
    pub protocol_i_es: HandoverPreparationFailureProtocolIEs,
}
impl entropic::Entropic for HandoverPreparationFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverPreparationFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct HandoverPreparationUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<HandoverPreparationUnsuccessfulTransferIE_Extensions>,
}
impl entropic::Entropic for HandoverPreparationUnsuccessfulTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<HandoverPreparationUnsuccessfulTransferIE_Extensions> = None;
        Ok(Self {
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequest {
    pub protocol_i_es: HandoverRequestProtocolIEs,
}
impl entropic::Entropic for HandoverRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequestAcknowledge {
    pub protocol_i_es: HandoverRequestAcknowledgeProtocolIEs,
}
impl entropic::Entropic for HandoverRequestAcknowledge {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverRequestAcknowledgeProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct HandoverRequestAcknowledgeTransfer {
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub security_result: Option<SecurityResult>,
    pub qos_flow_setup_response_list: QosFlowListWithDataForwarding,
    #[asn(optional_idx = 2)]
    pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 3)]
    pub data_forwarding_response_drb_list: Option<DataForwardingResponseDRBList>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<HandoverRequestAcknowledgeTransferIE_Extensions>,
}
impl entropic::Entropic for HandoverRequestAcknowledgeTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_ngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let security_result: Option<SecurityResult> = source.get_entropic()?;
        let qos_flow_setup_response_list: QosFlowListWithDataForwarding = source.get_entropic()?;
        let qos_flow_failed_to_setup_list: Option<QosFlowListWithCause> = source.get_entropic()?;
        let data_forwarding_response_drb_list: Option<DataForwardingResponseDRBList> =
            source.get_entropic()?;
        let ie_extensions: Option<HandoverRequestAcknowledgeTransferIE_Extensions> = None;
        Ok(Self {
            dl_ngu_up_tnl_information,
            dl_forwarding_up_tnl_information,
            security_result,
            qos_flow_setup_response_list,
            qos_flow_failed_to_setup_list,
            data_forwarding_response_drb_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_ngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .dl_forwarding_up_tnl_information
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.security_result.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_setup_response_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_failed_to_setup_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .data_forwarding_response_drb_list
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequired {
    pub protocol_i_es: HandoverRequiredProtocolIEs,
}
impl entropic::Entropic for HandoverRequired {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverRequiredProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct HandoverRequiredTransfer {
    #[asn(optional_idx = 0)]
    pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<HandoverRequiredTransferIE_Extensions>,
}
impl entropic::Entropic for HandoverRequiredTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let direct_forwarding_path_availability: Option<DirectForwardingPathAvailability> =
            source.get_entropic()?;
        let ie_extensions: Option<HandoverRequiredTransferIE_Extensions> = None;
        Ok(Self {
            direct_forwarding_path_availability,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .direct_forwarding_path_availability
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct HandoverResourceAllocationUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<HandoverResourceAllocationUnsuccessfulTransferIE_Extensions>,
}
impl entropic::Entropic for HandoverResourceAllocationUnsuccessfulTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let criticality_diagnostics: Option<CriticalityDiagnostics> = source.get_entropic()?;
        let ie_extensions: Option<HandoverResourceAllocationUnsuccessfulTransferIE_Extensions> =
            None;
        Ok(Self {
            cause,
            criticality_diagnostics,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        __entropic_internal_length += self.criticality_diagnostics.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverSuccess {
    pub protocol_i_es: HandoverSuccessProtocolIEs,
}
impl entropic::Entropic for HandoverSuccess {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: HandoverSuccessProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct HandoverType(pub u8);
impl HandoverType {
    pub const INTRA5GS: u8 = 0u8;
    pub const FIVEGS_TO_EPS: u8 = 1u8;
    pub const EPS_TO_5GS: u8 = 2u8;
}
impl entropic::Entropic for HandoverType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(HandoverType(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "30")]
pub struct Hysteresis(pub u8);
impl entropic::Entropic for Hysteresis {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Hysteresis(source.get_uniform_range(0..=30)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=30 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IAB_Authorized(pub u8);
impl IAB_Authorized {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for IAB_Authorized {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IAB_Authorized(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IAB_Supported(pub u8);
impl IAB_Supported {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for IAB_Supported {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IAB_Supported(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IABNodeIndication(pub u8);
impl IABNodeIndication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for IABNodeIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IABNodeIndication(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IMSVoiceSupportIndicator(pub u8);
impl IMSVoiceSupportIndicator {
    pub const SUPPORTED: u8 = 0u8;
    pub const NOT_SUPPORTED: u8 = 1u8;
}
impl entropic::Entropic for IMSVoiceSupportIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IMSVoiceSupportIndicator(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct ImmediateMDTNr {
    pub measurements_to_activate: MeasurementsToActivate,
    #[asn(optional_idx = 0)]
    pub m1_configuration: Option<M1Configuration>,
    #[asn(optional_idx = 1)]
    pub m4_configuration: Option<M4Configuration>,
    #[asn(optional_idx = 2)]
    pub m5_configuration: Option<M5Configuration>,
    #[asn(optional_idx = 3)]
    pub m6_configuration: Option<M6Configuration>,
    #[asn(optional_idx = 4)]
    pub m7_configuration: Option<M7Configuration>,
    #[asn(optional_idx = 5)]
    pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
    #[asn(optional_idx = 6)]
    pub wlan_measurement_configuration: Option<WLANMeasurementConfiguration>,
    #[asn(optional_idx = 7)]
    pub mdt_location_info: Option<MDT_Location_Info>,
    #[asn(optional_idx = 8)]
    pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
    #[asn(optional_idx = 9)]
    pub ie_extensions: Option<ImmediateMDTNrIE_Extensions>,
}
impl entropic::Entropic for ImmediateMDTNr {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let measurements_to_activate: MeasurementsToActivate = source.get_entropic()?;
        let m1_configuration: Option<M1Configuration> = source.get_entropic()?;
        let m4_configuration: Option<M4Configuration> = source.get_entropic()?;
        let m5_configuration: Option<M5Configuration> = source.get_entropic()?;
        let m6_configuration: Option<M6Configuration> = source.get_entropic()?;
        let m7_configuration: Option<M7Configuration> = source.get_entropic()?;
        let bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration> =
            source.get_entropic()?;
        let wlan_measurement_configuration: Option<WLANMeasurementConfiguration> =
            source.get_entropic()?;
        let mdt_location_info: Option<MDT_Location_Info> = source.get_entropic()?;
        let sensor_measurement_configuration: Option<SensorMeasurementConfiguration> =
            source.get_entropic()?;
        let ie_extensions: Option<ImmediateMDTNrIE_Extensions> = None;
        Ok(Self {
            measurements_to_activate,
            m1_configuration,
            m4_configuration,
            m5_configuration,
            m6_configuration,
            m7_configuration,
            bluetooth_measurement_configuration,
            wlan_measurement_configuration,
            mdt_location_info,
            sensor_measurement_configuration,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.measurements_to_activate.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m1_configuration.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m4_configuration.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m5_configuration.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m6_configuration.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m7_configuration.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .bluetooth_measurement_configuration
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.wlan_measurement_configuration.to_entropy_sink(sink)?;
        __entropic_internal_length += self.mdt_location_info.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .sensor_measurement_configuration
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256", extensible = true)]
pub struct IndexToRFSP(pub u16);
impl entropic::Entropic for IndexToRFSP {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IndexToRFSP(source.get_uniform_range(1..=256)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=256 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct InfoOnRecommendedCellsAndRANNodesForPaging {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    pub recommend_ran_nodes_for_paging: RecommendedRANNodesForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions>,
}
impl entropic::Entropic for InfoOnRecommendedCellsAndRANNodesForPaging {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let recommended_cells_for_paging: RecommendedCellsForPaging = source.get_entropic()?;
        let recommend_ran_nodes_for_paging: RecommendedRANNodesForPaging = source.get_entropic()?;
        let ie_extensions: Option<InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions> = None;
        Ok(Self {
            recommended_cells_for_paging,
            recommend_ran_nodes_for_paging,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.recommended_cells_for_paging.to_entropy_sink(sink)?;
        __entropic_internal_length += self.recommend_ran_nodes_for_paging.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupFailure {
    pub protocol_i_es: InitialContextSetupFailureProtocolIEs,
}
impl entropic::Entropic for InitialContextSetupFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: InitialContextSetupFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupRequest {
    pub protocol_i_es: InitialContextSetupRequestProtocolIEs,
}
impl entropic::Entropic for InitialContextSetupRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: InitialContextSetupRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupResponse {
    pub protocol_i_es: InitialContextSetupResponseProtocolIEs,
}
impl entropic::Entropic for InitialContextSetupResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: InitialContextSetupResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialUEMessage {
    pub protocol_i_es: InitialUEMessageProtocolIEs,
}
impl entropic::Entropic for InitialUEMessage {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: InitialUEMessageProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingMessage {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: InitiatingMessageValue,
}
impl entropic::Entropic for InitiatingMessage {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: InitiatingMessageValue = source.get_entropic()?;
        let procedure_code: ProcedureCode = ProcedureCode(value.choice_key());
        Ok(Self {
            procedure_code,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct IntegrityProtectionIndication(pub u8);
impl IntegrityProtectionIndication {
    pub const REQUIRED: u8 = 0u8;
    pub const PREFERRED: u8 = 1u8;
    pub const NOT_NEEDED: u8 = 2u8;
}
impl entropic::Entropic for IntegrityProtectionIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IntegrityProtectionIndication(
            source.get_uniform_range(0..=2)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IntegrityProtectionResult(pub u8);
impl IntegrityProtectionResult {
    pub const PERFORMED: u8 = 0u8;
    pub const NOT_PERFORMED: u8 = 1u8;
}
impl entropic::Entropic for IntegrityProtectionResult {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IntegrityProtectionResult(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct IntendedNumberOfPagingAttempts(pub u8);
impl entropic::Entropic for IntendedNumberOfPagingAttempts {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IntendedNumberOfPagingAttempts(
            source.get_uniform_range(1..=16)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=16 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct InterSystemFailureIndication {
    #[asn(optional_idx = 0)]
    pub uerlf_report_container: Option<UERLFReportContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<InterSystemFailureIndicationIE_Extensions>,
}
impl entropic::Entropic for InterSystemFailureIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let uerlf_report_container: Option<UERLFReportContainer> = source.get_entropic()?;
        let ie_extensions: Option<InterSystemFailureIndicationIE_Extensions> = None;
        Ok(Self {
            uerlf_report_container,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.uerlf_report_container.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct InterSystemHOReport {
    pub handover_report_type: InterSystemHandoverReportType,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<InterSystemHOReportIE_Extensions>,
}
impl entropic::Entropic for InterSystemHOReport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let handover_report_type: InterSystemHandoverReportType = source.get_entropic()?;
        let ie_extensions: Option<InterSystemHOReportIE_Extensions> = None;
        Ok(Self {
            handover_report_type,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.handover_report_type.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum InterSystemHandoverReportType {
    #[asn(key = 0, extended = false)]
    TooearlyIntersystemHO(TooearlyIntersystemHO),
    #[asn(key = 1, extended = false)]
    IntersystemUnnecessaryHO(IntersystemUnnecessaryHO),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(InterSystemHandoverReportType_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for InterSystemHandoverReportType {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            InterSystemHandoverReportType::TooearlyIntersystemHO(_) => 0u128.try_into().unwrap(),
            InterSystemHandoverReportType::IntersystemUnnecessaryHO(_) => 1u128.try_into().unwrap(),
            InterSystemHandoverReportType::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct InterfacesToTrace(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for InterfacesToTrace {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(InterfacesToTrace(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemSONConfigurationTransfer {
    pub transfer_type: IntersystemSONTransferType,
    pub intersystem_son_information: IntersystemSONInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemSONConfigurationTransferIE_Extensions>,
}
impl entropic::Entropic for IntersystemSONConfigurationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let transfer_type: IntersystemSONTransferType = source.get_entropic()?;
        let intersystem_son_information: IntersystemSONInformation = source.get_entropic()?;
        let ie_extensions: Option<IntersystemSONConfigurationTransferIE_Extensions> = None;
        Ok(Self {
            transfer_type,
            intersystem_son_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.transfer_type.to_entropy_sink(sink)?;
        __entropic_internal_length += self.intersystem_son_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum IntersystemSONInformation {
    #[asn(key = 0, extended = false)]
    IntersystemSONInformationReport(IntersystemSONInformationReport),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(IntersystemSONInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for IntersystemSONInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            IntersystemSONInformation::IntersystemSONInformationReport(_) => {
                0u128.try_into().unwrap()
            }
            IntersystemSONInformation::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum IntersystemSONInformationReport {
    #[asn(key = 0, extended = false)]
    HOReportInformation(InterSystemHOReport),
    #[asn(key = 1, extended = false)]
    FailureIndicationInformation(InterSystemFailureIndication),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(IntersystemSONInformationReport_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for IntersystemSONInformationReport {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            IntersystemSONInformationReport::HOReportInformation(_) => 0u128.try_into().unwrap(),
            IntersystemSONInformationReport::FailureIndicationInformation(_) => {
                1u128.try_into().unwrap()
            }
            IntersystemSONInformationReport::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemSONNGRANnodeID {
    pub global_ran_node_id: GlobalRANNodeID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemSONNGRANnodeIDIE_Extensions>,
}
impl entropic::Entropic for IntersystemSONNGRANnodeID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let global_ran_node_id: GlobalRANNodeID = source.get_entropic()?;
        let selected_tai: TAI = source.get_entropic()?;
        let ie_extensions: Option<IntersystemSONNGRANnodeIDIE_Extensions> = None;
        Ok(Self {
            global_ran_node_id,
            selected_tai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.global_ran_node_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.selected_tai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum IntersystemSONTransferType {
    #[asn(key = 0, extended = false)]
    FromEUTRANtoNGRAN(FromEUTRANtoNGRAN),
    #[asn(key = 1, extended = false)]
    FromNGRANtoEUTRAN(FromNGRANtoEUTRAN),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(IntersystemSONTransferType_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for IntersystemSONTransferType {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            IntersystemSONTransferType::FromEUTRANtoNGRAN(_) => 0u128.try_into().unwrap(),
            IntersystemSONTransferType::FromNGRANtoEUTRAN(_) => 1u128.try_into().unwrap(),
            IntersystemSONTransferType::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemSONeNBID {
    pub globale_nbid: GlobalENB_ID,
    pub selected_epstai: EPS_TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemSONeNBIDIE_Extensions>,
}
impl entropic::Entropic for IntersystemSONeNBID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let globale_nbid: GlobalENB_ID = source.get_entropic()?;
        let selected_epstai: EPS_TAI = source.get_entropic()?;
        let ie_extensions: Option<IntersystemSONeNBIDIE_Extensions> = None;
        Ok(Self {
            globale_nbid,
            selected_epstai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.globale_nbid.to_entropy_sink(sink)?;
        __entropic_internal_length += self.selected_epstai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemUnnecessaryHO {
    pub sourcecell_id: NGRAN_CGI,
    pub targetcell_id: EUTRA_CGI,
    pub early_iratho: IntersystemUnnecessaryHOEarlyIRATHO,
    pub candidate_cell_list: CandidateCellList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemUnnecessaryHOIE_Extensions>,
}
impl entropic::Entropic for IntersystemUnnecessaryHO {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let sourcecell_id: NGRAN_CGI = source.get_entropic()?;
        let targetcell_id: EUTRA_CGI = source.get_entropic()?;
        let early_iratho: IntersystemUnnecessaryHOEarlyIRATHO = source.get_entropic()?;
        let candidate_cell_list: CandidateCellList = source.get_entropic()?;
        let ie_extensions: Option<IntersystemUnnecessaryHOIE_Extensions> = None;
        Ok(Self {
            sourcecell_id,
            targetcell_id,
            early_iratho,
            candidate_cell_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.sourcecell_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.targetcell_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.early_iratho.to_entropy_sink(sink)?;
        __entropic_internal_length += self.candidate_cell_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct LAC(pub Vec<u8>);
impl entropic::Entropic for LAC {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(LAC(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LAI {
    pub plm_nidentity: PLMNIdentity,
    pub lac: LAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LAIIE_Extensions>,
}
impl entropic::Entropic for LAI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plm_nidentity: PLMNIdentity = source.get_entropic()?;
        let lac: LAC = source.get_entropic()?;
        let ie_extensions: Option<LAIIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            lac,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plm_nidentity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.lac.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct LTEM_Indication(pub u8);
impl LTEM_Indication {
    pub const LTE_M: u8 = 0u8;
}
impl entropic::Entropic for LTEM_Indication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(LTEM_Indication(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LTEUERLFReportContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LTEUESidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LTEUESidelinkAggregateMaximumBitrateIE_Extensions>,
}
impl entropic::Entropic for LTEUESidelinkAggregateMaximumBitrate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ue_sidelink_aggregate_maximum_bit_rate: BitRate = source.get_entropic()?;
        let ie_extensions: Option<LTEUESidelinkAggregateMaximumBitrateIE_Extensions> = None;
        Ok(Self {
            ue_sidelink_aggregate_maximum_bit_rate,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ue_sidelink_aggregate_maximum_bit_rate
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct LTEV2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<LTEV2XServicesAuthorizedIE_Extensions>,
}
impl entropic::Entropic for LTEV2XServicesAuthorized {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let vehicle_ue: Option<VehicleUE> = source.get_entropic()?;
        let pedestrian_ue: Option<PedestrianUE> = source.get_entropic()?;
        let ie_extensions: Option<LTEV2XServicesAuthorizedIE_Extensions> = None;
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.vehicle_ue.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pedestrian_ue.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum LastVisitedCellInformation {
    #[asn(key = 0, extended = false)]
    NGRANCell(LastVisitedNGRANCellInformation),
    #[asn(key = 1, extended = false)]
    EUTRANCell(LastVisitedEUTRANCellInformation),
    #[asn(key = 2, extended = false)]
    UTRANCell(LastVisitedUTRANCellInformation),
    #[asn(key = 3, extended = false)]
    GERANCell(LastVisitedGERANCellInformation),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(LastVisitedCellInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for LastVisitedCellInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            LastVisitedCellInformation::NGRANCell(_) => 0u128.try_into().unwrap(),
            LastVisitedCellInformation::EUTRANCell(_) => 1u128.try_into().unwrap(),
            LastVisitedCellInformation::UTRANCell(_) => 2u128.try_into().unwrap(),
            LastVisitedCellInformation::GERANCell(_) => 3u128.try_into().unwrap(),
            LastVisitedCellInformation::Choice_Extensions(_) => 4u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LastVisitedCellItem {
    pub last_visited_cell_information: LastVisitedCellInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LastVisitedCellItemIE_Extensions>,
}
impl entropic::Entropic for LastVisitedCellItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let last_visited_cell_information: LastVisitedCellInformation = source.get_entropic()?;
        let ie_extensions: Option<LastVisitedCellItemIE_Extensions> = None;
        Ok(Self {
            last_visited_cell_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.last_visited_cell_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedEUTRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedGERANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct LastVisitedNGRANCellInformation {
    pub global_cell_id: NGRAN_CGI,
    pub cell_type: CellType,
    pub time_ue_stayed_in_cell: TimeUEStayedInCell,
    #[asn(optional_idx = 0)]
    pub time_ue_stayed_in_cell_enhanced_granularity: Option<TimeUEStayedInCellEnhancedGranularity>,
    #[asn(optional_idx = 1)]
    pub ho_cause_value: Option<Cause>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<LastVisitedNGRANCellInformationIE_Extensions>,
}
impl entropic::Entropic for LastVisitedNGRANCellInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let global_cell_id: NGRAN_CGI = source.get_entropic()?;
        let cell_type: CellType = source.get_entropic()?;
        let time_ue_stayed_in_cell: TimeUEStayedInCell = source.get_entropic()?;
        let time_ue_stayed_in_cell_enhanced_granularity: Option<
            TimeUEStayedInCellEnhancedGranularity,
        > = source.get_entropic()?;
        let ho_cause_value: Option<Cause> = source.get_entropic()?;
        let ie_extensions: Option<LastVisitedNGRANCellInformationIE_Extensions> = None;
        Ok(Self {
            global_cell_id,
            cell_type,
            time_ue_stayed_in_cell,
            time_ue_stayed_in_cell_enhanced_granularity,
            ho_cause_value,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.global_cell_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cell_type.to_entropy_sink(sink)?;
        __entropic_internal_length += self.time_ue_stayed_in_cell.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .time_ue_stayed_in_cell_enhanced_granularity
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.ho_cause_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedUTRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct LineType(pub u8);
impl LineType {
    pub const DSL: u8 = 0u8;
    pub const PON: u8 = 1u8;
}
impl entropic::Entropic for LineType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(LineType(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Links_to_log(pub u8);
impl Links_to_log {
    pub const UPLINK: u8 = 0u8;
    pub const DOWNLINK: u8 = 1u8;
    pub const BOTH_UPLINK_AND_DOWNLINK: u8 = 2u8;
}
impl entropic::Entropic for Links_to_log {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Links_to_log(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReport {
    pub protocol_i_es: LocationReportProtocolIEs,
}
impl entropic::Entropic for LocationReport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: LocationReportProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct LocationReportingAdditionalInfo(pub u8);
impl LocationReportingAdditionalInfo {
    pub const INCLUDE_PS_CELL: u8 = 0u8;
}
impl entropic::Entropic for LocationReportingAdditionalInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(LocationReportingAdditionalInfo(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingControl {
    pub protocol_i_es: LocationReportingControlProtocolIEs,
}
impl entropic::Entropic for LocationReportingControl {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: LocationReportingControlProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingFailureIndication {
    pub protocol_i_es: LocationReportingFailureIndicationProtocolIEs,
}
impl entropic::Entropic for LocationReportingFailureIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: LocationReportingFailureIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "64", extensible = true)]
pub struct LocationReportingReferenceID(pub u8);
impl entropic::Entropic for LocationReportingReferenceID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(LocationReportingReferenceID(
            source.get_uniform_range(1..=64)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=64 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct LocationReportingRequestType {
    pub event_type: EventType,
    pub report_area: ReportArea,
    #[asn(optional_idx = 0)]
    pub area_of_interest_list: Option<AreaOfInterestList>,
    #[asn(optional_idx = 1)]
    pub location_reporting_reference_id_to_be_cancelled: Option<LocationReportingReferenceID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<LocationReportingRequestTypeIE_Extensions>,
}
impl entropic::Entropic for LocationReportingRequestType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let event_type: EventType = source.get_entropic()?;
        let report_area: ReportArea = source.get_entropic()?;
        let area_of_interest_list: Option<AreaOfInterestList> = source.get_entropic()?;
        let location_reporting_reference_id_to_be_cancelled: Option<LocationReportingReferenceID> =
            source.get_entropic()?;
        let ie_extensions: Option<LocationReportingRequestTypeIE_Extensions> = None;
        Ok(Self {
            event_type,
            report_area,
            area_of_interest_list,
            location_reporting_reference_id_to_be_cancelled,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.event_type.to_entropy_sink(sink)?;
        __entropic_internal_length += self.report_area.to_entropy_sink(sink)?;
        __entropic_internal_length += self.area_of_interest_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .location_reporting_reference_id_to_be_cancelled
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct LoggedMDTNr {
    pub logging_interval: LoggingInterval,
    pub logging_duration: LoggingDuration,
    pub logged_mdt_trigger: LoggedMDTTrigger,
    #[asn(optional_idx = 0)]
    pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
    #[asn(optional_idx = 1)]
    pub wlan_measurement_configuration: Option<WLANMeasurementConfiguration>,
    #[asn(optional_idx = 2)]
    pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
    #[asn(optional_idx = 3)]
    pub area_scope_of_neigh_cells_list: Option<AreaScopeOfNeighCellsList>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<LoggedMDTNrIE_Extensions>,
}
impl entropic::Entropic for LoggedMDTNr {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let logging_interval: LoggingInterval = source.get_entropic()?;
        let logging_duration: LoggingDuration = source.get_entropic()?;
        let logged_mdt_trigger: LoggedMDTTrigger = source.get_entropic()?;
        let bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration> =
            source.get_entropic()?;
        let wlan_measurement_configuration: Option<WLANMeasurementConfiguration> =
            source.get_entropic()?;
        let sensor_measurement_configuration: Option<SensorMeasurementConfiguration> =
            source.get_entropic()?;
        let area_scope_of_neigh_cells_list: Option<AreaScopeOfNeighCellsList> =
            source.get_entropic()?;
        let ie_extensions: Option<LoggedMDTNrIE_Extensions> = None;
        Ok(Self {
            logging_interval,
            logging_duration,
            logged_mdt_trigger,
            bluetooth_measurement_configuration,
            wlan_measurement_configuration,
            sensor_measurement_configuration,
            area_scope_of_neigh_cells_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.logging_interval.to_entropy_sink(sink)?;
        __entropic_internal_length += self.logging_duration.to_entropy_sink(sink)?;
        __entropic_internal_length += self.logged_mdt_trigger.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .bluetooth_measurement_configuration
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.wlan_measurement_configuration.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .sensor_measurement_configuration
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.area_scope_of_neigh_cells_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum LoggedMDTTrigger {
    #[asn(key = 0, extended = false)]
    Periodical(LoggedMDTTrigger_periodical),
    #[asn(key = 1, extended = false)]
    EventTrigger(EventTrigger),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(LoggedMDTTrigger_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for LoggedMDTTrigger {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            LoggedMDTTrigger::Periodical(_) => 0u128.try_into().unwrap(),
            LoggedMDTTrigger::EventTrigger(_) => 1u128.try_into().unwrap(),
            LoggedMDTTrigger::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct LoggingDuration(pub u8);
impl LoggingDuration {
    pub const M10: u8 = 0u8;
    pub const M20: u8 = 1u8;
    pub const M40: u8 = 2u8;
    pub const M60: u8 = 3u8;
    pub const M90: u8 = 4u8;
    pub const M120: u8 = 5u8;
}
impl entropic::Entropic for LoggingDuration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(LoggingDuration(source.get_uniform_range(0..=5)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "10")]
pub struct LoggingInterval(pub u8);
impl LoggingInterval {
    pub const MS320: u8 = 0u8;
    pub const MS640: u8 = 1u8;
    pub const MS1280: u8 = 2u8;
    pub const MS2560: u8 = 3u8;
    pub const MS5120: u8 = 4u8;
    pub const MS10240: u8 = 5u8;
    pub const MS20480: u8 = 6u8;
    pub const MS30720: u8 = 7u8;
    pub const MS40960: u8 = 8u8;
    pub const MS61440: u8 = 9u8;
    pub const INFINITY: u8 = 10u8;
}
impl entropic::Entropic for LoggingInterval {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(LoggingInterval(source.get_uniform_range(0..=10)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=10 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct M1Configuration {
    pub m1reporting_trigger: M1ReportingTrigger,
    #[asn(optional_idx = 0)]
    pub m1threshold_event_a2: Option<M1ThresholdEventA2>,
    #[asn(optional_idx = 1)]
    pub m1periodic_reporting: Option<M1PeriodicReporting>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<M1ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M1Configuration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let m1reporting_trigger: M1ReportingTrigger = source.get_entropic()?;
        let m1threshold_event_a2: Option<M1ThresholdEventA2> = source.get_entropic()?;
        let m1periodic_reporting: Option<M1PeriodicReporting> = source.get_entropic()?;
        let ie_extensions: Option<M1ConfigurationIE_Extensions> = None;
        Ok(Self {
            m1reporting_trigger,
            m1threshold_event_a2,
            m1periodic_reporting,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m1reporting_trigger.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m1threshold_event_a2.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m1periodic_reporting.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1PeriodicReporting {
    pub report_interval: ReportIntervalMDT,
    pub report_amount: ReportAmountMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1PeriodicReportingIE_Extensions>,
}
impl entropic::Entropic for M1PeriodicReporting {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let report_interval: ReportIntervalMDT = source.get_entropic()?;
        let report_amount: ReportAmountMDT = source.get_entropic()?;
        let ie_extensions: Option<M1PeriodicReportingIE_Extensions> = None;
        Ok(Self {
            report_interval,
            report_amount,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.report_interval.to_entropy_sink(sink)?;
        __entropic_internal_length += self.report_amount.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct M1ReportingTrigger(pub u8);
impl M1ReportingTrigger {
    pub const PERIODIC: u8 = 0u8;
    pub const A2EVENTTRIGGERED: u8 = 1u8;
    pub const A2EVENTTRIGGERED_PERIODIC: u8 = 2u8;
}
impl entropic::Entropic for M1ReportingTrigger {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(M1ReportingTrigger(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1ThresholdEventA2 {
    pub m1_threshold_type: M1ThresholdType,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1ThresholdEventA2IE_Extensions>,
}
impl entropic::Entropic for M1ThresholdEventA2 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let m1_threshold_type: M1ThresholdType = source.get_entropic()?;
        let ie_extensions: Option<M1ThresholdEventA2IE_Extensions> = None;
        Ok(Self {
            m1_threshold_type,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m1_threshold_type.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum M1ThresholdType {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(Threshold_RSRP),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(Threshold_RSRQ),
    #[asn(key = 2, extended = false)]
    Threshold_SINR(Threshold_SINR),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(M1ThresholdType_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for M1ThresholdType {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            M1ThresholdType::Threshold_RSRP(_) => 0u128.try_into().unwrap(),
            M1ThresholdType::Threshold_RSRQ(_) => 1u128.try_into().unwrap(),
            M1ThresholdType::Threshold_SINR(_) => 2u128.try_into().unwrap(),
            M1ThresholdType::Choice_Extensions(_) => 3u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M4Configuration {
    pub m4period: M4period,
    pub m4_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M4ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M4Configuration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let m4period: M4period = source.get_entropic()?;
        let m4_links_to_log: Links_to_log = source.get_entropic()?;
        let ie_extensions: Option<M4ConfigurationIE_Extensions> = None;
        Ok(Self {
            m4period,
            m4_links_to_log,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m4period.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m4_links_to_log.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M4period(pub u8);
impl M4period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}
impl entropic::Entropic for M4period {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(M4period(source.get_uniform_range(0..=4)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M5ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M5Configuration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let m5period: M5period = source.get_entropic()?;
        let m5_links_to_log: Links_to_log = source.get_entropic()?;
        let ie_extensions: Option<M5ConfigurationIE_Extensions> = None;
        Ok(Self {
            m5period,
            m5_links_to_log,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m5period.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m5_links_to_log.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M5period(pub u8);
impl M5period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}
impl entropic::Entropic for M5period {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(M5period(source.get_uniform_range(0..=4)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M6Configuration {
    pub m6report_interval: M6report_Interval,
    pub m6_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M6ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M6Configuration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let m6report_interval: M6report_Interval = source.get_entropic()?;
        let m6_links_to_log: Links_to_log = source.get_entropic()?;
        let ie_extensions: Option<M6ConfigurationIE_Extensions> = None;
        Ok(Self {
            m6report_interval,
            m6_links_to_log,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m6report_interval.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m6_links_to_log.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct M6report_Interval(pub u8);
impl M6report_Interval {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MS20480: u8 = 8u8;
    pub const MS40960: u8 = 9u8;
    pub const MIN1: u8 = 10u8;
    pub const MIN6: u8 = 11u8;
    pub const MIN12: u8 = 12u8;
    pub const MIN30: u8 = 13u8;
}
impl entropic::Entropic for M6report_Interval {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(M6report_Interval(source.get_uniform_range(0..=13)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=13 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M7ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M7Configuration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let m7period: M7period = source.get_entropic()?;
        let m7_links_to_log: Links_to_log = source.get_entropic()?;
        let ie_extensions: Option<M7ConfigurationIE_Extensions> = None;
        Ok(Self {
            m7period,
            m7_links_to_log,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m7period.to_entropy_sink(sink)?;
        __entropic_internal_length += self.m7_links_to_log.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "60", extensible = true)]
pub struct M7period(pub u8);
impl entropic::Entropic for M7period {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(M7period(source.get_uniform_range(1..=60)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=60 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct MDT_Activation(pub u8);
impl MDT_Activation {
    pub const IMMEDIATE_MDT_ONLY: u8 = 0u8;
    pub const LOGGED_MDT_ONLY: u8 = 1u8;
    pub const IMMEDIATE_MDT_AND_TRACE: u8 = 2u8;
}
impl entropic::Entropic for MDT_Activation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(MDT_Activation(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MDT_Configuration {
    #[asn(optional_idx = 0)]
    pub mdt_config_nr: Option<MDT_Configuration_NR>,
    #[asn(optional_idx = 1)]
    pub mdt_config_eutra: Option<MDT_Configuration_EUTRA>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<MDT_ConfigurationIE_Extensions>,
}
impl entropic::Entropic for MDT_Configuration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mdt_config_nr: Option<MDT_Configuration_NR> = source.get_entropic()?;
        let mdt_config_eutra: Option<MDT_Configuration_EUTRA> = source.get_entropic()?;
        let ie_extensions: Option<MDT_ConfigurationIE_Extensions> = None;
        Ok(Self {
            mdt_config_nr,
            mdt_config_eutra,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.mdt_config_nr.to_entropy_sink(sink)?;
        __entropic_internal_length += self.mdt_config_eutra.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MDT_Configuration_EUTRA {
    pub mdt_activation: MDT_Activation,
    pub area_scope_of_mdt: AreaScopeOfMDT_EUTRA,
    pub mdt_mode: MDTModeEutra,
    #[asn(optional_idx = 0)]
    pub signalling_based_mdtplmn_list: Option<MDTPLMNList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MDT_Configuration_EUTRAIE_Extensions>,
}
impl entropic::Entropic for MDT_Configuration_EUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mdt_activation: MDT_Activation = source.get_entropic()?;
        let area_scope_of_mdt: AreaScopeOfMDT_EUTRA = source.get_entropic()?;
        let mdt_mode: MDTModeEutra = source.get_entropic()?;
        let signalling_based_mdtplmn_list: Option<MDTPLMNList> = source.get_entropic()?;
        let ie_extensions: Option<MDT_Configuration_EUTRAIE_Extensions> = None;
        Ok(Self {
            mdt_activation,
            area_scope_of_mdt,
            mdt_mode,
            signalling_based_mdtplmn_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.mdt_activation.to_entropy_sink(sink)?;
        __entropic_internal_length += self.area_scope_of_mdt.to_entropy_sink(sink)?;
        __entropic_internal_length += self.mdt_mode.to_entropy_sink(sink)?;
        __entropic_internal_length += self.signalling_based_mdtplmn_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MDT_Configuration_NR {
    pub mdt_activation: MDT_Activation,
    pub area_scope_of_mdt: AreaScopeOfMDT_NR,
    pub mdt_mode_nr: MDTModeNr,
    #[asn(optional_idx = 0)]
    pub signalling_based_mdtplmn_list: Option<MDTPLMNList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MDT_Configuration_NRIE_Extensions>,
}
impl entropic::Entropic for MDT_Configuration_NR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mdt_activation: MDT_Activation = source.get_entropic()?;
        let area_scope_of_mdt: AreaScopeOfMDT_NR = source.get_entropic()?;
        let mdt_mode_nr: MDTModeNr = source.get_entropic()?;
        let signalling_based_mdtplmn_list: Option<MDTPLMNList> = source.get_entropic()?;
        let ie_extensions: Option<MDT_Configuration_NRIE_Extensions> = None;
        Ok(Self {
            mdt_activation,
            area_scope_of_mdt,
            mdt_mode_nr,
            signalling_based_mdtplmn_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.mdt_activation.to_entropy_sink(sink)?;
        __entropic_internal_length += self.area_scope_of_mdt.to_entropy_sink(sink)?;
        __entropic_internal_length += self.mdt_mode_nr.to_entropy_sink(sink)?;
        __entropic_internal_length += self.signalling_based_mdtplmn_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MDT_Location_Info {
    pub mdt_location_information: MDT_Location_Information,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MDT_Location_InfoIE_Extensions>,
}
impl entropic::Entropic for MDT_Location_Info {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mdt_location_information: MDT_Location_Information = source.get_entropic()?;
        let ie_extensions: Option<MDT_Location_InfoIE_Extensions> = None;
        Ok(Self {
            mdt_location_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.mdt_location_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MDT_Location_Information(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MDT_Location_Information {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(MDT_Location_Information(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MDTModeEutra(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum MDTModeNr {
    #[asn(key = 0, extended = false)]
    ImmediateMDTNr(ImmediateMDTNr),
    #[asn(key = 1, extended = false)]
    LoggedMDTNr(LoggedMDTNr),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(MDTModeNr_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for MDTModeNr {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            MDTModeNr::ImmediateMDTNr(_) => 0u128.try_into().unwrap(),
            MDTModeNr::LoggedMDTNr(_) => 1u128.try_into().unwrap(),
            MDTModeNr::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct MDTPLMNList(pub Vec<PLMNIdentity>);
impl entropic::Entropic for MDTPLMNList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNIdentity::from_entropy_source(source)?);
        }
        Ok(MDTPLMNList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct MICOModeIndication(pub u8);
impl MICOModeIndication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for MICOModeIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(MICOModeIndication(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct MaskedIMEISV(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MaskedIMEISV {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(64, 16383);
        let total_bitlen = source.get_bounded_len(64..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(MaskedIMEISV(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 64);
        let capped_max = std::cmp::min(64, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(64..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095", extensible = true)]
pub struct MaximumDataBurstVolume(pub u16);
impl entropic::Entropic for MaximumDataBurstVolume {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(MaximumDataBurstVolume(source.get_uniform_range(0..=4095)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct MaximumIntegrityProtectedDataRate(pub u8);
impl MaximumIntegrityProtectedDataRate {
    pub const BITRATE64KBS: u8 = 0u8;
    pub const MAXIMUM_UE_RATE: u8 = 1u8;
}
impl entropic::Entropic for MaximumIntegrityProtectedDataRate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(MaximumIntegrityProtectedDataRate(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum MeasurementThresholdL1LoggedMDT {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(Threshold_RSRP),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(Threshold_RSRQ),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(MeasurementThresholdL1LoggedMDT_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for MeasurementThresholdL1LoggedMDT {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            MeasurementThresholdL1LoggedMDT::Threshold_RSRP(_) => 0u128.try_into().unwrap(),
            MeasurementThresholdL1LoggedMDT::Threshold_RSRQ(_) => 1u128.try_into().unwrap(),
            MeasurementThresholdL1LoggedMDT::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasurementsToActivate(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MeasurementsToActivate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(MeasurementsToActivate(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct MessageIdentifier(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MessageIdentifier {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(MessageIdentifier(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct MobilityInformation(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MobilityInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(MobilityInformation(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct MobilityRestrictionList {
    pub serving_plmn: PLMNIdentity,
    #[asn(optional_idx = 0)]
    pub equivalent_plm_ns: Option<EquivalentPLMNs>,
    #[asn(optional_idx = 1)]
    pub rat_restrictions: Option<RATRestrictions>,
    #[asn(optional_idx = 2)]
    pub forbidden_area_information: Option<ForbiddenAreaInformation>,
    #[asn(optional_idx = 3)]
    pub service_area_information: Option<ServiceAreaInformation>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<MobilityRestrictionListIE_Extensions>,
}
impl entropic::Entropic for MobilityRestrictionList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let serving_plmn: PLMNIdentity = source.get_entropic()?;
        let equivalent_plm_ns: Option<EquivalentPLMNs> = source.get_entropic()?;
        let rat_restrictions: Option<RATRestrictions> = source.get_entropic()?;
        let forbidden_area_information: Option<ForbiddenAreaInformation> = source.get_entropic()?;
        let service_area_information: Option<ServiceAreaInformation> = source.get_entropic()?;
        let ie_extensions: Option<MobilityRestrictionListIE_Extensions> = None;
        Ok(Self {
            serving_plmn,
            equivalent_plm_ns,
            rat_restrictions,
            forbidden_area_information,
            service_area_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.serving_plmn.to_entropy_sink(sink)?;
        __entropic_internal_length += self.equivalent_plm_ns.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rat_restrictions.to_entropy_sink(sink)?;
        __entropic_internal_length += self.forbidden_area_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.service_area_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum N3IWF_ID {
    #[asn(key = 0, extended = false)]
    N3IWF_ID(N3IWF_ID_n3IWF_ID),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(N3IWF_ID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for N3IWF_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            N3IWF_ID::N3IWF_ID(_) => 0u128.try_into().unwrap(),
            N3IWF_ID::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NAS_PDU(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NASNonDeliveryIndication {
    pub protocol_i_es: NASNonDeliveryIndicationProtocolIEs,
}
impl entropic::Entropic for NASNonDeliveryIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: NASNonDeliveryIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NASSecurityParametersFromNGRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct NB_IoT_DefaultPagingDRX(pub u8);
impl NB_IoT_DefaultPagingDRX {
    pub const RF128: u8 = 0u8;
    pub const RF256: u8 = 1u8;
    pub const RF512: u8 = 2u8;
    pub const RF1024: u8 = 3u8;
}
impl entropic::Entropic for NB_IoT_DefaultPagingDRX {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NB_IoT_DefaultPagingDRX(source.get_uniform_range(0..=3)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct NB_IoT_Paging_TimeWindow(pub u8);
impl NB_IoT_Paging_TimeWindow {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}
impl entropic::Entropic for NB_IoT_Paging_TimeWindow {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NB_IoT_Paging_TimeWindow(source.get_uniform_range(0..=15)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct NB_IoT_Paging_eDRXCycle(pub u8);
impl NB_IoT_Paging_eDRXCycle {
    pub const HF2: u8 = 0u8;
    pub const HF4: u8 = 1u8;
    pub const HF6: u8 = 2u8;
    pub const HF8: u8 = 3u8;
    pub const HF10: u8 = 4u8;
    pub const HF12: u8 = 5u8;
    pub const HF14: u8 = 6u8;
    pub const HF16: u8 = 7u8;
    pub const HF32: u8 = 8u8;
    pub const HF64: u8 = 9u8;
    pub const HF128: u8 = 10u8;
    pub const HF256: u8 = 11u8;
    pub const HF512: u8 = 12u8;
    pub const HF1024: u8 = 13u8;
}
impl entropic::Entropic for NB_IoT_Paging_eDRXCycle {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NB_IoT_Paging_eDRXCycle(source.get_uniform_range(0..=13)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=13 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NB_IoT_Paging_eDRXInfo {
    pub nb_io_t_paging_e_drx_cycle: NB_IoT_Paging_eDRXCycle,
    #[asn(optional_idx = 0)]
    pub nb_io_t_paging_time_window: Option<NB_IoT_Paging_TimeWindow>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NB_IoT_Paging_eDRXInfoIE_Extensions>,
}
impl entropic::Entropic for NB_IoT_Paging_eDRXInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nb_io_t_paging_e_drx_cycle: NB_IoT_Paging_eDRXCycle = source.get_entropic()?;
        let nb_io_t_paging_time_window: Option<NB_IoT_Paging_TimeWindow> = source.get_entropic()?;
        let ie_extensions: Option<NB_IoT_Paging_eDRXInfoIE_Extensions> = None;
        Ok(Self {
            nb_io_t_paging_e_drx_cycle,
            nb_io_t_paging_time_window,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nb_io_t_paging_e_drx_cycle.to_entropy_sink(sink)?;
        __entropic_internal_length += self.nb_io_t_paging_time_window.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct NB_IoT_PagingDRX(pub u8);
impl NB_IoT_PagingDRX {
    pub const RF32: u8 = 0u8;
    pub const RF64: u8 = 1u8;
    pub const RF128: u8 = 2u8;
    pub const RF256: u8 = 3u8;
    pub const RF512: u8 = 4u8;
    pub const RF1024: u8 = 5u8;
}
impl entropic::Entropic for NB_IoT_PagingDRX {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NB_IoT_PagingDRX(source.get_uniform_range(0..=5)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct NB_IoT_UEPriority(pub u8);
impl entropic::Entropic for NB_IoT_UEPriority {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NB_IoT_UEPriority(source.get_uniform_range(0..=255)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum NGAP_PDU {
    #[asn(key = 0, extended = false)]
    InitiatingMessage(InitiatingMessage),
    #[asn(key = 1, extended = false)]
    SuccessfulOutcome(SuccessfulOutcome),
    #[asn(key = 2, extended = false)]
    UnsuccessfulOutcome(UnsuccessfulOutcome),
}
impl asn1_codecs::Asn1Choice for NGAP_PDU {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            NGAP_PDU::InitiatingMessage(_) => 0u128.try_into().unwrap(),
            NGAP_PDU::SuccessfulOutcome(_) => 1u128.try_into().unwrap(),
            NGAP_PDU::UnsuccessfulOutcome(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum NGRAN_CGI {
    #[asn(key = 0, extended = false)]
    NR_CGI(NR_CGI),
    #[asn(key = 1, extended = false)]
    EUTRA_CGI(EUTRA_CGI),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(NGRAN_CGI_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for NGRAN_CGI {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            NGRAN_CGI::NR_CGI(_) => 0u128.try_into().unwrap(),
            NGRAN_CGI::EUTRA_CGI(_) => 1u128.try_into().unwrap(),
            NGRAN_CGI::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct NGRAN_TNLAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub tnl_association_transport_layer_address_amf: Option<CPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NGRAN_TNLAssociationToRemoveItemIE_Extensions>,
}
impl entropic::Entropic for NGRAN_TNLAssociationToRemoveItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tnl_association_transport_layer_address: CPTransportLayerInformation =
            source.get_entropic()?;
        let tnl_association_transport_layer_address_amf: Option<CPTransportLayerInformation> =
            source.get_entropic()?;
        let ie_extensions: Option<NGRAN_TNLAssociationToRemoveItemIE_Extensions> = None;
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_amf,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .tnl_association_transport_layer_address
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .tnl_association_transport_layer_address_amf
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct NGRAN_TNLAssociationToRemoveList(pub Vec<NGRAN_TNLAssociationToRemoveItem>);
impl entropic::Entropic for NGRAN_TNLAssociationToRemoveList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NGRAN_TNLAssociationToRemoveItem::from_entropy_source(
                source,
            )?);
        }
        Ok(NGRAN_TNLAssociationToRemoveList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct NGRANTraceID(pub Vec<u8>);
impl entropic::Entropic for NGRANTraceID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(8..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(NGRANTraceID(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGReset {
    pub protocol_i_es: NGResetProtocolIEs,
}
impl entropic::Entropic for NGReset {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: NGResetProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGResetAcknowledge {
    pub protocol_i_es: NGResetAcknowledgeProtocolIEs,
}
impl entropic::Entropic for NGResetAcknowledge {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: NGResetAcknowledgeProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGSetupFailure {
    pub protocol_i_es: NGSetupFailureProtocolIEs,
}
impl entropic::Entropic for NGSetupFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: NGSetupFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGSetupRequest {
    pub protocol_i_es: NGSetupRequestProtocolIEs,
}
impl entropic::Entropic for NGSetupRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: NGSetupRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGSetupResponse {
    pub protocol_i_es: NGSetupResponseProtocolIEs,
}
impl entropic::Entropic for NGSetupResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: NGSetupResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "44", sz_ub = "44")]
pub struct NID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(44, 16383);
        let total_bitlen = source.get_bounded_len(44..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(NID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 44);
        let capped_max = std::cmp::min(44, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(44..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NPN_AccessInformation {
    #[asn(key = 0, extended = false)]
    PNI_NPN_Access_Information(CellCAGList),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(NPN_AccessInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for NPN_AccessInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            NPN_AccessInformation::PNI_NPN_Access_Information(_) => 0u128.try_into().unwrap(),
            NPN_AccessInformation::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum NPN_MobilityInformation {
    #[asn(key = 0, extended = false)]
    SNPN_MobilityInformation(SNPN_MobilityInformation),
    #[asn(key = 1, extended = false)]
    PNI_NPN_MobilityInformation(PNI_NPN_MobilityInformation),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(NPN_MobilityInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for NPN_MobilityInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            NPN_MobilityInformation::SNPN_MobilityInformation(_) => 0u128.try_into().unwrap(),
            NPN_MobilityInformation::PNI_NPN_MobilityInformation(_) => 1u128.try_into().unwrap(),
            NPN_MobilityInformation::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NPN_PagingAssistanceInformation {
    #[asn(key = 0, extended = false)]
    PNI_NPN_PagingAssistance(Allowed_PNI_NPN_List),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(NPN_PagingAssistanceInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for NPN_PagingAssistanceInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            NPN_PagingAssistanceInformation::PNI_NPN_PagingAssistance(_) => {
                0u128.try_into().unwrap()
            }
            NPN_PagingAssistanceInformation::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NPN_Support {
    #[asn(key = 0, extended = false)]
    SNPN(NID),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(NPN_Support_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for NPN_Support {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            NPN_Support::SNPN(_) => 0u128.try_into().unwrap(),
            NPN_Support::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NR_CGI {
    pub plmn_identity: PLMNIdentity,
    pub nr_cell_identity: NRCellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NR_CGIIE_Extensions>,
}
impl entropic::Entropic for NR_CGI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let nr_cell_identity: NRCellIdentity = source.get_entropic()?;
        let ie_extensions: Option<NR_CGIIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            nr_cell_identity,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.nr_cell_identity.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct NR_CGIList(pub Vec<NR_CGI>);
impl entropic::Entropic for NR_CGIList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16384, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NR_CGI::from_entropy_source(source)?);
        }
        Ok(NR_CGIList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16384, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NR_CGIListForWarning(pub Vec<NR_CGI>);
impl entropic::Entropic for NR_CGIListForWarning {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NR_CGI::from_entropy_source(source)?);
        }
        Ok(NR_CGIListForWarning(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1007", extensible = true)]
pub struct NR_PCI(pub u16);
impl entropic::Entropic for NR_PCI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NR_PCI(source.get_uniform_range(0..=1007)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1007 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3279165")]
pub struct NRARFCN(pub u32);
impl entropic::Entropic for NRARFCN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NRARFCN(source.get_uniform_range(0..=3279165)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3279165 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "36", sz_ub = "36")]
pub struct NRCellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NRCellIdentity {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(36, 16383);
        let total_bitlen = source.get_bounded_len(36..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(NRCellIdentity(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 36);
        let capped_max = std::cmp::min(36, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(36..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1024", extensible = true)]
pub struct NRFrequencyBand(pub u16);
impl entropic::Entropic for NRFrequencyBand {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NRFrequencyBand(source.get_uniform_range(1..=1024)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=1024 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct NRFrequencyBand_List(pub Vec<NRFrequencyBandItem>);
impl entropic::Entropic for NRFrequencyBand_List {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NRFrequencyBandItem::from_entropy_source(source)?);
        }
        Ok(NRFrequencyBand_List(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRFrequencyBandItem {
    pub nr_frequency_band: NRFrequencyBand,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<NRFrequencyBandItemIE_Extension>,
}
impl entropic::Entropic for NRFrequencyBandItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_frequency_band: NRFrequencyBand = source.get_entropic()?;
        let ie_extension: Option<NRFrequencyBandItemIE_Extension> = source.get_entropic()?;
        Ok(Self {
            nr_frequency_band,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_frequency_band.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRFrequencyInfo {
    pub nr_arfcn: NRARFCN,
    pub frequency_band_list: NRFrequencyBand_List,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<NRFrequencyInfoIE_Extension>,
}
impl entropic::Entropic for NRFrequencyInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_arfcn: NRARFCN = source.get_entropic()?;
        let frequency_band_list: NRFrequencyBand_List = source.get_entropic()?;
        let ie_extension: Option<NRFrequencyInfoIE_Extension> = source.get_entropic()?;
        Ok(Self {
            nr_arfcn,
            frequency_band_list,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_arfcn.to_entropy_sink(sink)?;
        __entropic_internal_length += self.frequency_band_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRMobilityHistoryReport(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRPPa_PDU(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRUERLFReportContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESidelinkAggregateMaximumBitrateIE_Extensions>,
}
impl entropic::Entropic for NRUESidelinkAggregateMaximumBitrate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ue_sidelink_aggregate_maximum_bit_rate: BitRate = source.get_entropic()?;
        let ie_extensions: Option<NRUESidelinkAggregateMaximumBitrateIE_Extensions> = None;
        Ok(Self {
            ue_sidelink_aggregate_maximum_bit_rate,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ue_sidelink_aggregate_maximum_bit_rate
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct NRV2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<NRV2XServicesAuthorizedIE_Extensions>,
}
impl entropic::Entropic for NRV2XServicesAuthorized {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let vehicle_ue: Option<VehicleUE> = source.get_entropic()?;
        let pedestrian_ue: Option<PedestrianUE> = source.get_entropic()?;
        let ie_extensions: Option<NRV2XServicesAuthorizedIE_Extensions> = None;
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.vehicle_ue.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pedestrian_ue.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRencryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NRencryptionAlgorithms {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(NRencryptionAlgorithms(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRintegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NRintegrityProtectionAlgorithms {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(NRintegrityProtectionAlgorithms(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256", extensible = true)]
pub struct NetworkInstance(pub u16);
impl entropic::Entropic for NetworkInstance {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NetworkInstance(source.get_uniform_range(1..=256)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=256 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NewSecurityContextInd(pub u8);
impl NewSecurityContextInd {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for NewSecurityContextInd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NewSecurityContextInd(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct NextHopChainingCount(pub u8);
impl entropic::Entropic for NextHopChainingCount {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NextHopChainingCount(source.get_uniform_range(0..=7)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=7 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NextPagingAreaScope(pub u8);
impl NextPagingAreaScope {
    pub const SAME: u8 = 0u8;
    pub const CHANGED: u8 = 1u8;
}
impl entropic::Entropic for NextPagingAreaScope {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NextPagingAreaScope(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum NgENB_ID {
    #[asn(key = 0, extended = false)]
    MacroNgENB_ID(NgENB_ID_macroNgENB_ID),
    #[asn(key = 1, extended = false)]
    ShortMacroNgENB_ID(NgENB_ID_shortMacroNgENB_ID),
    #[asn(key = 2, extended = false)]
    LongMacroNgENB_ID(NgENB_ID_longMacroNgENB_ID),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(NgENB_ID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for NgENB_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            NgENB_ID::MacroNgENB_ID(_) => 0u128.try_into().unwrap(),
            NgENB_ID::ShortMacroNgENB_ID(_) => 1u128.try_into().unwrap(),
            NgENB_ID::LongMacroNgENB_ID(_) => 2u128.try_into().unwrap(),
            NgENB_ID::Choice_Extensions(_) => 3u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct NonDynamic5QIDescriptor {
    pub five_qi: FiveQI,
    #[asn(optional_idx = 0)]
    pub priority_level_qos: Option<PriorityLevelQos>,
    #[asn(optional_idx = 1)]
    pub averaging_window: Option<AveragingWindow>,
    #[asn(optional_idx = 2)]
    pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<NonDynamic5QIDescriptorIE_Extensions>,
}
impl entropic::Entropic for NonDynamic5QIDescriptor {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let five_qi: FiveQI = source.get_entropic()?;
        let priority_level_qos: Option<PriorityLevelQos> = source.get_entropic()?;
        let averaging_window: Option<AveragingWindow> = source.get_entropic()?;
        let maximum_data_burst_volume: Option<MaximumDataBurstVolume> = source.get_entropic()?;
        let ie_extensions: Option<NonDynamic5QIDescriptorIE_Extensions> = None;
        Ok(Self {
            five_qi,
            priority_level_qos,
            averaging_window,
            maximum_data_burst_volume,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.five_qi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.priority_level_qos.to_entropy_sink(sink)?;
        __entropic_internal_length += self.averaging_window.to_entropy_sink(sink)?;
        __entropic_internal_length += self.maximum_data_burst_volume.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct NotAllowedTACs(pub Vec<TAC>);
impl entropic::Entropic for NotAllowedTACs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAC::from_entropy_source(source)?);
        }
        Ok(NotAllowedTACs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NotificationCause(pub u8);
impl NotificationCause {
    pub const FULFILLED: u8 = 0u8;
    pub const NOT_FULFILLED: u8 = 1u8;
}
impl entropic::Entropic for NotificationCause {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NotificationCause(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NotificationControl(pub u8);
impl NotificationControl {
    pub const NOTIFICATION_REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for NotificationControl {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NotificationControl(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NotifySourceNGRANNode(pub u8);
impl NotifySourceNGRANNode {
    pub const NOTIFY_SOURCE: u8 = 0u8;
}
impl entropic::Entropic for NotifySourceNGRANNode {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NotifySourceNGRANNode(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberOfBroadcasts(pub u16);
impl entropic::Entropic for NumberOfBroadcasts {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NumberOfBroadcasts(source.get_uniform_range(0..=65535)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberOfBroadcastsRequested(pub u16);
impl entropic::Entropic for NumberOfBroadcastsRequested {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(NumberOfBroadcastsRequested(
            source.get_uniform_range(0..=65535)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct OverloadAction(pub u8);
impl OverloadAction {
    pub const REJECT_NON_EMERGENCY_MO_DT: u8 = 0u8;
    pub const REJECT_RRC_CR_SIGNALLING: u8 = 1u8;
    pub const PERMIT_EMERGENCY_SESSIONS_AND_MOBILE_TERMINATED_SERVICES_ONLY: u8 = 2u8;
    pub const PERMIT_HIGH_PRIORITY_SESSIONS_AND_MOBILE_TERMINATED_SERVICES_ONLY: u8 = 3u8;
}
impl entropic::Entropic for OverloadAction {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(OverloadAction(source.get_uniform_range(0..=3)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum OverloadResponse {
    #[asn(key = 0, extended = false)]
    OverloadAction(OverloadAction),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(OverloadResponse_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for OverloadResponse {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            OverloadResponse::OverloadAction(_) => 0u128.try_into().unwrap(),
            OverloadResponse::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStart {
    pub protocol_i_es: OverloadStartProtocolIEs,
}
impl entropic::Entropic for OverloadStart {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: OverloadStartProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct OverloadStartNSSAIItem {
    pub slice_overload_list: SliceOverloadList,
    #[asn(optional_idx = 0)]
    pub slice_overload_response: Option<OverloadResponse>,
    #[asn(optional_idx = 1)]
    pub slice_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<OverloadStartNSSAIItemIE_Extensions>,
}
impl entropic::Entropic for OverloadStartNSSAIItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let slice_overload_list: SliceOverloadList = source.get_entropic()?;
        let slice_overload_response: Option<OverloadResponse> = source.get_entropic()?;
        let slice_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication> =
            source.get_entropic()?;
        let ie_extensions: Option<OverloadStartNSSAIItemIE_Extensions> = None;
        Ok(Self {
            slice_overload_list,
            slice_overload_response,
            slice_traffic_load_reduction_indication,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.slice_overload_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.slice_overload_response.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .slice_traffic_load_reduction_indication
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct OverloadStartNSSAIList(pub Vec<OverloadStartNSSAIItem>);
impl entropic::Entropic for OverloadStartNSSAIList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1024, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(OverloadStartNSSAIItem::from_entropy_source(source)?);
        }
        Ok(OverloadStartNSSAIList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(1024, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStop {
    pub protocol_i_es: OverloadStopProtocolIEs,
}
impl entropic::Entropic for OverloadStop {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: OverloadStopProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PC5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PC5FlowBitRatesIE_Extensions>,
}
impl entropic::Entropic for PC5FlowBitRates {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let guaranteed_flow_bit_rate: BitRate = source.get_entropic()?;
        let maximum_flow_bit_rate: BitRate = source.get_entropic()?;
        let ie_extensions: Option<PC5FlowBitRatesIE_Extensions> = None;
        Ok(Self {
            guaranteed_flow_bit_rate,
            maximum_flow_bit_rate,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.guaranteed_flow_bit_rate.to_entropy_sink(sink)?;
        __entropic_internal_length += self.maximum_flow_bit_rate.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PC5QoSFlowItem {
    pub pqi: FiveQI,
    #[asn(optional_idx = 0)]
    pub pc5_flow_bit_rates: Option<PC5FlowBitRates>,
    #[asn(optional_idx = 1)]
    pub range: Option<Range>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PC5QoSFlowItemIE_Extensions>,
}
impl entropic::Entropic for PC5QoSFlowItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pqi: FiveQI = source.get_entropic()?;
        let pc5_flow_bit_rates: Option<PC5FlowBitRates> = source.get_entropic()?;
        let range: Option<Range> = source.get_entropic()?;
        let ie_extensions: Option<PC5QoSFlowItemIE_Extensions> = None;
        Ok(Self {
            pqi,
            pc5_flow_bit_rates,
            range,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pqi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pc5_flow_bit_rates.to_entropy_sink(sink)?;
        __entropic_internal_length += self.range.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct PC5QoSFlowList(pub Vec<PC5QoSFlowItem>);
impl entropic::Entropic for PC5QoSFlowList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2048, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5QoSFlowItem::from_entropy_source(source)?);
        }
        Ok(PC5QoSFlowList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2048, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PC5QoSParameters {
    pub pc5_qo_s_flow_list: PC5QoSFlowList,
    #[asn(optional_idx = 0)]
    pub pc5_link_aggregate_bit_rates: Option<BitRate>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PC5QoSParametersIE_Extensions>,
}
impl entropic::Entropic for PC5QoSParameters {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pc5_qo_s_flow_list: PC5QoSFlowList = source.get_entropic()?;
        let pc5_link_aggregate_bit_rates: Option<BitRate> = source.get_entropic()?;
        let ie_extensions: Option<PC5QoSParametersIE_Extensions> = None;
        Ok(Self {
            pc5_qo_s_flow_list,
            pc5_link_aggregate_bit_rates,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pc5_qo_s_flow_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pc5_link_aggregate_bit_rates.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct PCIListForMDT(pub Vec<NR_PCI>);
impl entropic::Entropic for PCIListForMDT {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NR_PCI::from_entropy_source(source)?);
        }
        Ok(PCIListForMDT(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionAggregateMaximumBitRate {
    pub pdu_session_aggregate_maximum_bit_rate_dl: BitRate,
    pub pdu_session_aggregate_maximum_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionAggregateMaximumBitRateIE_Extensions>,
}
impl entropic::Entropic for PDUSessionAggregateMaximumBitRate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_aggregate_maximum_bit_rate_dl: BitRate = source.get_entropic()?;
        let pdu_session_aggregate_maximum_bit_rate_ul: BitRate = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionAggregateMaximumBitRateIE_Extensions> = None;
        Ok(Self {
            pdu_session_aggregate_maximum_bit_rate_dl,
            pdu_session_aggregate_maximum_bit_rate_ul,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .pdu_session_aggregate_maximum_bit_rate_dl
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_aggregate_maximum_bit_rate_ul
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct PDUSessionID(pub u8);
impl entropic::Entropic for PDUSessionID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PDUSessionID(source.get_uniform_range(0..=255)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceAdmittedItem {
    pub pdu_session_id: PDUSessionID,
    pub handover_request_acknowledge_transfer:
        PDUSessionResourceAdmittedItemHandoverRequestAcknowledgeTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceAdmittedItemIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceAdmittedItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let handover_request_acknowledge_transfer : PDUSessionResourceAdmittedItemHandoverRequestAcknowledgeTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceAdmittedItemIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            handover_request_acknowledge_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .handover_request_acknowledge_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceAdmittedList(pub Vec<PDUSessionResourceAdmittedItem>);
impl entropic::Entropic for PDUSessionResourceAdmittedList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceAdmittedItem::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceAdmittedList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToModifyItemModCfm { pub pdu_session_id : PDUSessionID , pub pdu_session_resource_modify_indication_unsuccessful_transfer : PDUSessionResourceFailedToModifyItemModCfmPDUSessionResourceModifyIndicationUnsuccessfulTransfer , # [asn (optional_idx = 0 ,)] pub ie_extensions : Option < PDUSessionResourceFailedToModifyItemModCfmIE_Extensions > , }
impl entropic::Entropic for PDUSessionResourceFailedToModifyItemModCfm {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_modify_indication_unsuccessful_transfer : PDUSessionResourceFailedToModifyItemModCfmPDUSessionResourceModifyIndicationUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceFailedToModifyItemModCfmIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_indication_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_modify_indication_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToModifyItemModRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_unsuccessful_transfer:
        PDUSessionResourceFailedToModifyItemModResPDUSessionResourceModifyUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToModifyItemModResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToModifyItemModRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_modify_unsuccessful_transfer : PDUSessionResourceFailedToModifyItemModResPDUSessionResourceModifyUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceFailedToModifyItemModResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_modify_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToModifyListModCfm(
    pub Vec<PDUSessionResourceFailedToModifyItemModCfm>,
);
impl entropic::Entropic for PDUSessionResourceFailedToModifyListModCfm {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToModifyItemModCfm::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToModifyListModCfm(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToModifyListModRes(
    pub Vec<PDUSessionResourceFailedToModifyItemModRes>,
);
impl entropic::Entropic for PDUSessionResourceFailedToModifyListModRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToModifyItemModRes::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToModifyListModRes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToResumeItemRESReq {
    pub pdu_session_id: PDUSessionID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToResumeItemRESReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToResumeItemRESReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceFailedToResumeItemRESReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToResumeItemRESRes {
    pub pdu_session_id: PDUSessionID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToResumeItemRESResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToResumeItemRESRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceFailedToResumeItemRESResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToResumeListRESReq(
    pub Vec<PDUSessionResourceFailedToResumeItemRESReq>,
);
impl entropic::Entropic for PDUSessionResourceFailedToResumeListRESReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToResumeItemRESReq::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToResumeListRESReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToResumeListRESRes(
    pub Vec<PDUSessionResourceFailedToResumeItemRESRes>,
);
impl entropic::Entropic for PDUSessionResourceFailedToResumeListRESRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToResumeItemRESRes::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToResumeListRESRes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemCxtFail {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_unsuccessful_transfer:
        PDUSessionResourceFailedToSetupItemCxtFailPDUSessionResourceSetupUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemCxtFail {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_setup_unsuccessful_transfer : PDUSessionResourceFailedToSetupItemCxtFailPDUSessionResourceSetupUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_setup_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemCxtRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_unsuccessful_transfer:
        PDUSessionResourceFailedToSetupItemCxtResPDUSessionResourceSetupUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemCxtResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemCxtRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_setup_unsuccessful_transfer : PDUSessionResourceFailedToSetupItemCxtResPDUSessionResourceSetupUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceFailedToSetupItemCxtResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_setup_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemHOAck {
    pub pdu_session_id: PDUSessionID,
    pub handover_resource_allocation_unsuccessful_transfer:
        PDUSessionResourceFailedToSetupItemHOAckHandoverResourceAllocationUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemHOAckIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemHOAck {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let handover_resource_allocation_unsuccessful_transfer : PDUSessionResourceFailedToSetupItemHOAckHandoverResourceAllocationUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceFailedToSetupItemHOAckIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            handover_resource_allocation_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .handover_resource_allocation_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemPSReq {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_setup_failed_transfer:
        PDUSessionResourceFailedToSetupItemPSReqPathSwitchRequestSetupFailedTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemPSReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemPSReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let path_switch_request_setup_failed_transfer : PDUSessionResourceFailedToSetupItemPSReqPathSwitchRequestSetupFailedTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceFailedToSetupItemPSReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            path_switch_request_setup_failed_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .path_switch_request_setup_failed_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemSURes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_unsuccessful_transfer:
        PDUSessionResourceFailedToSetupItemSUResPDUSessionResourceSetupUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemSUResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemSURes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_setup_unsuccessful_transfer : PDUSessionResourceFailedToSetupItemSUResPDUSessionResourceSetupUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceFailedToSetupItemSUResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_setup_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListCxtFail(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtFail>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupListCxtFail {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToSetupItemCxtFail::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToSetupListCxtFail(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListCxtRes(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtRes>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupListCxtRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToSetupItemCxtRes::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToSetupListCxtRes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListHOAck(
    pub Vec<PDUSessionResourceFailedToSetupItemHOAck>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupListHOAck {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToSetupItemHOAck::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToSetupListHOAck(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListPSReq(
    pub Vec<PDUSessionResourceFailedToSetupItemPSReq>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupListPSReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToSetupItemPSReq::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToSetupListPSReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListSURes(
    pub Vec<PDUSessionResourceFailedToSetupItemSURes>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupListSURes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceFailedToSetupItemSURes::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceFailedToSetupListSURes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceHandoverItem {
    pub pdu_session_id: PDUSessionID,
    pub handover_command_transfer: PDUSessionResourceHandoverItemHandoverCommandTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceHandoverItemIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceHandoverItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let handover_command_transfer: PDUSessionResourceHandoverItemHandoverCommandTransfer =
            source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceHandoverItemIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            handover_command_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.handover_command_transfer.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceHandoverList(pub Vec<PDUSessionResourceHandoverItem>);
impl entropic::Entropic for PDUSessionResourceHandoverList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceHandoverItem::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceHandoverList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceInformationItem {
    pub pdu_session_id: PDUSessionID,
    pub qos_flow_information_list: QosFlowInformationList,
    #[asn(optional_idx = 0)]
    pub dr_bs_to_qos_flows_mapping_list: Option<DRBsToQosFlowsMappingList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceInformationItemIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceInformationItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let qos_flow_information_list: QosFlowInformationList = source.get_entropic()?;
        let dr_bs_to_qos_flows_mapping_list: Option<DRBsToQosFlowsMappingList> =
            source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceInformationItemIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            qos_flow_information_list,
            dr_bs_to_qos_flows_mapping_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_information_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.dr_bs_to_qos_flows_mapping_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceInformationList(pub Vec<PDUSessionResourceInformationItem>);
impl entropic::Entropic for PDUSessionResourceInformationList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceInformationItem::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceInformationList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceItemCxtRelCpl {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceItemCxtRelCplIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceItemCxtRelCpl {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceItemCxtRelCplIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceItemCxtRelReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceItemCxtRelReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceItemCxtRelReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceItemCxtRelReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceItemHORqd {
    pub pdu_session_id: PDUSessionID,
    pub handover_required_transfer: PDUSessionResourceItemHORqdHandoverRequiredTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceItemHORqdIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceItemHORqd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let handover_required_transfer: PDUSessionResourceItemHORqdHandoverRequiredTransfer =
            source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceItemHORqdIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            handover_required_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.handover_required_transfer.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceListCxtRelCpl(pub Vec<PDUSessionResourceItemCxtRelCpl>);
impl entropic::Entropic for PDUSessionResourceListCxtRelCpl {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceItemCxtRelCpl::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceListCxtRelCpl(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceListCxtRelReq(pub Vec<PDUSessionResourceItemCxtRelReq>);
impl entropic::Entropic for PDUSessionResourceListCxtRelReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceItemCxtRelReq::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceListCxtRelReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceListHORqd(pub Vec<PDUSessionResourceItemHORqd>);
impl entropic::Entropic for PDUSessionResourceListHORqd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceItemHORqd::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceListHORqd(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyConfirm {
    pub protocol_i_es: PDUSessionResourceModifyConfirmProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceModifyConfirm {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceModifyConfirmProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PDUSessionResourceModifyConfirmTransfer {
    pub qos_flow_modify_confirm_list: QosFlowModifyConfirmList,
    pub ulngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub additional_ng_uuptnl_information: Option<UPTransportLayerInformationPairList>,
    #[asn(optional_idx = 1)]
    pub qos_flow_failed_to_modify_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PDUSessionResourceModifyConfirmTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyConfirmTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_modify_confirm_list: QosFlowModifyConfirmList = source.get_entropic()?;
        let ulngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let additional_ng_uuptnl_information: Option<UPTransportLayerInformationPairList> =
            source.get_entropic()?;
        let qos_flow_failed_to_modify_list: Option<QosFlowListWithCause> = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceModifyConfirmTransferIE_Extensions> = None;
        Ok(Self {
            qos_flow_modify_confirm_list,
            ulngu_up_tnl_information,
            additional_ng_uuptnl_information,
            qos_flow_failed_to_modify_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_modify_confirm_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ulngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .additional_ng_uuptnl_information
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_failed_to_modify_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyIndication {
    pub protocol_i_es: PDUSessionResourceModifyIndicationProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceModifyIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceModifyIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceModifyIndicationTransfer {
    pub dl_qos_flow_per_tnl_information: QosFlowPerTNLInformation,
    #[asn(optional_idx = 0)]
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceModifyIndicationTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyIndicationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_qos_flow_per_tnl_information: QosFlowPerTNLInformation = source.get_entropic()?;
        let additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList> =
            source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceModifyIndicationTransferIE_Extensions> = None;
        Ok(Self {
            dl_qos_flow_per_tnl_information,
            additional_dl_qos_flow_per_tnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_qos_flow_per_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .additional_dl_qos_flow_per_tnl_information
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyIndicationUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyIndicationUnsuccessfulTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<
            PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions,
        > = None;
        Ok(Self {
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyItemModCfm {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_confirm_transfer:
        PDUSessionResourceModifyItemModCfmPDUSessionResourceModifyConfirmTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModCfmIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyItemModCfm {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_modify_confirm_transfer : PDUSessionResourceModifyItemModCfmPDUSessionResourceModifyConfirmTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceModifyItemModCfmIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_confirm_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_modify_confirm_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyItemModInd {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_indication_transfer:
        PDUSessionResourceModifyItemModIndPDUSessionResourceModifyIndicationTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModIndIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyItemModInd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_modify_indication_transfer : PDUSessionResourceModifyItemModIndPDUSessionResourceModifyIndicationTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceModifyItemModIndIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_indication_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_modify_indication_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceModifyItemModReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub nas_pdu: Option<NAS_PDU>,
    pub pdu_session_resource_modify_request_transfer:
        PDUSessionResourceModifyItemModReqPDUSessionResourceModifyRequestTransfer,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyItemModReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let nas_pdu: Option<NAS_PDU> = source.get_entropic()?;
        let pdu_session_resource_modify_request_transfer : PDUSessionResourceModifyItemModReqPDUSessionResourceModifyRequestTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceModifyItemModReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            nas_pdu,
            pdu_session_resource_modify_request_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.nas_pdu.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_modify_request_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyItemModRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_response_transfer:
        PDUSessionResourceModifyItemModResPDUSessionResourceModifyResponseTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyItemModRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_modify_response_transfer : PDUSessionResourceModifyItemModResPDUSessionResourceModifyResponseTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceModifyItemModResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_response_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_modify_response_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModCfm(pub Vec<PDUSessionResourceModifyItemModCfm>);
impl entropic::Entropic for PDUSessionResourceModifyListModCfm {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceModifyItemModCfm::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceModifyListModCfm(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModInd(pub Vec<PDUSessionResourceModifyItemModInd>);
impl entropic::Entropic for PDUSessionResourceModifyListModInd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceModifyItemModInd::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceModifyListModInd(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModReq(pub Vec<PDUSessionResourceModifyItemModReq>);
impl entropic::Entropic for PDUSessionResourceModifyListModReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceModifyItemModReq::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceModifyListModReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModRes(pub Vec<PDUSessionResourceModifyItemModRes>);
impl entropic::Entropic for PDUSessionResourceModifyListModRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceModifyItemModRes::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceModifyListModRes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyRequest {
    pub protocol_i_es: PDUSessionResourceModifyRequestProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceModifyRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceModifyRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyRequestTransfer {
    pub protocol_i_es: PDUSessionResourceModifyRequestTransferProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceModifyRequestTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceModifyRequestTransferProtocolIEs =
            source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyResponse {
    pub protocol_i_es: PDUSessionResourceModifyResponseProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceModifyResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceModifyResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct PDUSessionResourceModifyResponseTransfer {
    #[asn(optional_idx = 0)]
    pub dl_ngu_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ul_ngu_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 2)]
    pub qos_flow_add_or_modify_response_list: Option<QosFlowAddOrModifyResponseList>,
    #[asn(optional_idx = 3)]
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList>,
    #[asn(optional_idx = 4)]
    pub qos_flow_failed_to_add_or_modify_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 5)]
    pub ie_extensions: Option<PDUSessionResourceModifyResponseTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyResponseTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_ngu_up_tnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let ul_ngu_up_tnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let qos_flow_add_or_modify_response_list: Option<QosFlowAddOrModifyResponseList> =
            source.get_entropic()?;
        let additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList> =
            source.get_entropic()?;
        let qos_flow_failed_to_add_or_modify_list: Option<QosFlowListWithCause> =
            source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceModifyResponseTransferIE_Extensions> = None;
        Ok(Self {
            dl_ngu_up_tnl_information,
            ul_ngu_up_tnl_information,
            qos_flow_add_or_modify_response_list,
            additional_dl_qos_flow_per_tnl_information,
            qos_flow_failed_to_add_or_modify_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_ngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ul_ngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .qos_flow_add_or_modify_response_list
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .additional_dl_qos_flow_per_tnl_information
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .qos_flow_failed_to_add_or_modify_list
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceModifyUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceModifyUnsuccessfulTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let criticality_diagnostics: Option<CriticalityDiagnostics> = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions> = None;
        Ok(Self {
            cause,
            criticality_diagnostics,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        __entropic_internal_length += self.criticality_diagnostics.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceNotify {
    pub protocol_i_es: PDUSessionResourceNotifyProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceNotify {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceNotifyProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceNotifyItem {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_notify_transfer:
        PDUSessionResourceNotifyItemPDUSessionResourceNotifyTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceNotifyItemIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceNotifyItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_notify_transfer : PDUSessionResourceNotifyItemPDUSessionResourceNotifyTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceNotifyItemIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_notify_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_notify_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceNotifyList(pub Vec<PDUSessionResourceNotifyItem>);
impl entropic::Entropic for PDUSessionResourceNotifyList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceNotifyItem::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceNotifyList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceNotifyReleasedTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceNotifyReleasedTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceNotifyReleasedTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceNotifyReleasedTransferIE_Extensions> = None;
        Ok(Self {
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PDUSessionResourceNotifyTransfer {
    #[asn(optional_idx = 0)]
    pub qos_flow_notify_list: Option<QosFlowNotifyList>,
    #[asn(optional_idx = 1)]
    pub qos_flow_released_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PDUSessionResourceNotifyTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceNotifyTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_notify_list: Option<QosFlowNotifyList> = source.get_entropic()?;
        let qos_flow_released_list: Option<QosFlowListWithCause> = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceNotifyTransferIE_Extensions> = None;
        Ok(Self {
            qos_flow_notify_list,
            qos_flow_released_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_notify_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_released_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceReleaseCommand {
    pub protocol_i_es: PDUSessionResourceReleaseCommandProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceReleaseCommand {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceReleaseCommandProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleaseCommandTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleaseCommandTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceReleaseCommandTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceReleaseCommandTransferIE_Extensions> = None;
        Ok(Self {
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceReleaseResponse {
    pub protocol_i_es: PDUSessionResourceReleaseResponseProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceReleaseResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceReleaseResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleaseResponseTransfer {
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleaseResponseTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceReleaseResponseTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ie_extensions: Option<PDUSessionResourceReleaseResponseTransferIE_Extensions> = None;
        Ok(Self { ie_extensions })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemNot {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_notify_released_transfer:
        PDUSessionResourceReleasedItemNotPDUSessionResourceNotifyReleasedTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemNotIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceReleasedItemNot {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_notify_released_transfer : PDUSessionResourceReleasedItemNotPDUSessionResourceNotifyReleasedTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceReleasedItemNotIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_notify_released_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_notify_released_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemPSAck {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_unsuccessful_transfer:
        PDUSessionResourceReleasedItemPSAckPathSwitchRequestUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemPSAckIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceReleasedItemPSAck {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let path_switch_request_unsuccessful_transfer : PDUSessionResourceReleasedItemPSAckPathSwitchRequestUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceReleasedItemPSAckIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            path_switch_request_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .path_switch_request_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemPSFail {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_unsuccessful_transfer:
        PDUSessionResourceReleasedItemPSFailPathSwitchRequestUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemPSFailIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceReleasedItemPSFail {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let path_switch_request_unsuccessful_transfer : PDUSessionResourceReleasedItemPSFailPathSwitchRequestUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceReleasedItemPSFailIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            path_switch_request_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .path_switch_request_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemRelRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_release_response_transfer:
        PDUSessionResourceReleasedItemRelResPDUSessionResourceReleaseResponseTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemRelResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceReleasedItemRelRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_release_response_transfer : PDUSessionResourceReleasedItemRelResPDUSessionResourceReleaseResponseTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceReleasedItemRelResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_release_response_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_release_response_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListNot(pub Vec<PDUSessionResourceReleasedItemNot>);
impl entropic::Entropic for PDUSessionResourceReleasedListNot {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceReleasedItemNot::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceReleasedListNot(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListPSAck(pub Vec<PDUSessionResourceReleasedItemPSAck>);
impl entropic::Entropic for PDUSessionResourceReleasedListPSAck {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceReleasedItemPSAck::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceReleasedListPSAck(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListPSFail(pub Vec<PDUSessionResourceReleasedItemPSFail>);
impl entropic::Entropic for PDUSessionResourceReleasedListPSFail {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceReleasedItemPSFail::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceReleasedListPSFail(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListRelRes(pub Vec<PDUSessionResourceReleasedItemRelRes>);
impl entropic::Entropic for PDUSessionResourceReleasedListRelRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceReleasedItemRelRes::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceReleasedListRelRes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceResumeItemRESReq {
    pub pdu_session_id: PDUSessionID,
    pub ue_context_resume_request_transfer:
        PDUSessionResourceResumeItemRESReqUEContextResumeRequestTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceResumeItemRESReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceResumeItemRESReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let ue_context_resume_request_transfer : PDUSessionResourceResumeItemRESReqUEContextResumeRequestTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceResumeItemRESReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            ue_context_resume_request_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .ue_context_resume_request_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceResumeItemRESRes {
    pub pdu_session_id: PDUSessionID,
    pub ue_context_resume_response_transfer:
        PDUSessionResourceResumeItemRESResUEContextResumeResponseTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceResumeItemRESResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceResumeItemRESRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let ue_context_resume_response_transfer : PDUSessionResourceResumeItemRESResUEContextResumeResponseTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceResumeItemRESResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            ue_context_resume_response_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .ue_context_resume_response_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceResumeListRESReq(pub Vec<PDUSessionResourceResumeItemRESReq>);
impl entropic::Entropic for PDUSessionResourceResumeListRESReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceResumeItemRESReq::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceResumeListRESReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceResumeListRESRes(pub Vec<PDUSessionResourceResumeItemRESRes>);
impl entropic::Entropic for PDUSessionResourceResumeListRESRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceResumeItemRESRes::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceResumeListRESRes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSecondaryRATUsageItem {
    pub pdu_session_id: PDUSessionID,
    pub secondary_rat_data_usage_report_transfer:
        PDUSessionResourceSecondaryRATUsageItemSecondaryRATDataUsageReportTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSecondaryRATUsageItemIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSecondaryRATUsageItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let secondary_rat_data_usage_report_transfer : PDUSessionResourceSecondaryRATUsageItemSecondaryRATDataUsageReportTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceSecondaryRATUsageItemIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            secondary_rat_data_usage_report_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .secondary_rat_data_usage_report_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSecondaryRATUsageList(
    pub Vec<PDUSessionResourceSecondaryRATUsageItem>,
);
impl entropic::Entropic for PDUSessionResourceSecondaryRATUsageList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSecondaryRATUsageItem::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceSecondaryRATUsageList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceSetupItemCxtReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub nas_pdu: Option<NAS_PDU>,
    pub s_nssai: S_NSSAI,
    pub pdu_session_resource_setup_request_transfer:
        PDUSessionResourceSetupItemCxtReqPDUSessionResourceSetupRequestTransfer,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemCxtReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSetupItemCxtReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let nas_pdu: Option<NAS_PDU> = source.get_entropic()?;
        let s_nssai: S_NSSAI = source.get_entropic()?;
        let pdu_session_resource_setup_request_transfer : PDUSessionResourceSetupItemCxtReqPDUSessionResourceSetupRequestTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceSetupItemCxtReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            nas_pdu,
            s_nssai,
            pdu_session_resource_setup_request_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.nas_pdu.to_entropy_sink(sink)?;
        __entropic_internal_length += self.s_nssai.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_setup_request_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSetupItemCxtRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_response_transfer:
        PDUSessionResourceSetupItemCxtResPDUSessionResourceSetupResponseTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemCxtResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSetupItemCxtRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_setup_response_transfer : PDUSessionResourceSetupItemCxtResPDUSessionResourceSetupResponseTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceSetupItemCxtResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_response_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_setup_response_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSetupItemHOReq {
    pub pdu_session_id: PDUSessionID,
    pub s_nssai: S_NSSAI,
    pub handover_request_transfer: PDUSessionResourceSetupItemHOReqHandoverRequestTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemHOReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSetupItemHOReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let s_nssai: S_NSSAI = source.get_entropic()?;
        let handover_request_transfer: PDUSessionResourceSetupItemHOReqHandoverRequestTransfer =
            source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceSetupItemHOReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            s_nssai,
            handover_request_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.s_nssai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.handover_request_transfer.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceSetupItemSUReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub pdu_session_nas_pdu: Option<NAS_PDU>,
    pub s_nssai: S_NSSAI,
    pub pdu_session_resource_setup_request_transfer:
        PDUSessionResourceSetupItemSUReqPDUSessionResourceSetupRequestTransfer,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemSUReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSetupItemSUReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_nas_pdu: Option<NAS_PDU> = source.get_entropic()?;
        let s_nssai: S_NSSAI = source.get_entropic()?;
        let pdu_session_resource_setup_request_transfer : PDUSessionResourceSetupItemSUReqPDUSessionResourceSetupRequestTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceSetupItemSUReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_nas_pdu,
            s_nssai,
            pdu_session_resource_setup_request_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pdu_session_nas_pdu.to_entropy_sink(sink)?;
        __entropic_internal_length += self.s_nssai.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_setup_request_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSetupItemSURes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_response_transfer:
        PDUSessionResourceSetupItemSUResPDUSessionResourceSetupResponseTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemSUResIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSetupItemSURes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_setup_response_transfer : PDUSessionResourceSetupItemSUResPDUSessionResourceSetupResponseTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceSetupItemSUResIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_response_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_setup_response_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListCxtReq(pub Vec<PDUSessionResourceSetupItemCxtReq>);
impl entropic::Entropic for PDUSessionResourceSetupListCxtReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSetupItemCxtReq::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceSetupListCxtReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListCxtRes(pub Vec<PDUSessionResourceSetupItemCxtRes>);
impl entropic::Entropic for PDUSessionResourceSetupListCxtRes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSetupItemCxtRes::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceSetupListCxtRes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListHOReq(pub Vec<PDUSessionResourceSetupItemHOReq>);
impl entropic::Entropic for PDUSessionResourceSetupListHOReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSetupItemHOReq::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceSetupListHOReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListSUReq(pub Vec<PDUSessionResourceSetupItemSUReq>);
impl entropic::Entropic for PDUSessionResourceSetupListSUReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSetupItemSUReq::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceSetupListSUReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListSURes(pub Vec<PDUSessionResourceSetupItemSURes>);
impl entropic::Entropic for PDUSessionResourceSetupListSURes {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSetupItemSURes::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceSetupListSURes(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceSetupRequest {
    pub protocol_i_es: PDUSessionResourceSetupRequestProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceSetupRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceSetupRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceSetupRequestTransfer {
    pub protocol_i_es: PDUSessionResourceSetupRequestTransferProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceSetupRequestTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceSetupRequestTransferProtocolIEs =
            source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceSetupResponse {
    pub protocol_i_es: PDUSessionResourceSetupResponseProtocolIEs,
}
impl entropic::Entropic for PDUSessionResourceSetupResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PDUSessionResourceSetupResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct PDUSessionResourceSetupResponseTransfer {
    pub dl_qos_flow_per_tnl_information: QosFlowPerTNLInformation,
    #[asn(optional_idx = 0)]
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList>,
    #[asn(optional_idx = 1)]
    pub security_result: Option<SecurityResult>,
    #[asn(optional_idx = 2)]
    pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<PDUSessionResourceSetupResponseTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSetupResponseTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_qos_flow_per_tnl_information: QosFlowPerTNLInformation = source.get_entropic()?;
        let additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList> =
            source.get_entropic()?;
        let security_result: Option<SecurityResult> = source.get_entropic()?;
        let qos_flow_failed_to_setup_list: Option<QosFlowListWithCause> = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceSetupResponseTransferIE_Extensions> = None;
        Ok(Self {
            dl_qos_flow_per_tnl_information,
            additional_dl_qos_flow_per_tnl_information,
            security_result,
            qos_flow_failed_to_setup_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_qos_flow_per_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .additional_dl_qos_flow_per_tnl_information
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.security_result.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_failed_to_setup_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceSetupUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSetupUnsuccessfulTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let criticality_diagnostics: Option<CriticalityDiagnostics> = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions> = None;
        Ok(Self {
            cause,
            criticality_diagnostics,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        __entropic_internal_length += self.criticality_diagnostics.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSuspendItemSUSReq {
    pub pdu_session_id: PDUSessionID,
    pub ue_context_suspend_request_transfer:
        PDUSessionResourceSuspendItemSUSReqUEContextSuspendRequestTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSuspendItemSUSReqIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSuspendItemSUSReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let ue_context_suspend_request_transfer : PDUSessionResourceSuspendItemSUSReqUEContextSuspendRequestTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceSuspendItemSUSReqIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            ue_context_suspend_request_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .ue_context_suspend_request_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSuspendListSUSReq(pub Vec<PDUSessionResourceSuspendItemSUSReq>);
impl entropic::Entropic for PDUSessionResourceSuspendListSUSReq {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSuspendItemSUSReq::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceSuspendListSUSReq(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSwitchedItem {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_acknowledge_transfer:
        PDUSessionResourceSwitchedItemPathSwitchRequestAcknowledgeTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSwitchedItemIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceSwitchedItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let path_switch_request_acknowledge_transfer : PDUSessionResourceSwitchedItemPathSwitchRequestAcknowledgeTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceSwitchedItemIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            path_switch_request_acknowledge_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .path_switch_request_acknowledge_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSwitchedList(pub Vec<PDUSessionResourceSwitchedItem>);
impl entropic::Entropic for PDUSessionResourceSwitchedList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSwitchedItem::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceSwitchedList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceToBeSwitchedDLItem {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_transfer: PDUSessionResourceToBeSwitchedDLItemPathSwitchRequestTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceToBeSwitchedDLItemIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceToBeSwitchedDLItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let path_switch_request_transfer : PDUSessionResourceToBeSwitchedDLItemPathSwitchRequestTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceToBeSwitchedDLItemIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            path_switch_request_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.path_switch_request_transfer.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceToBeSwitchedDLList(pub Vec<PDUSessionResourceToBeSwitchedDLItem>);
impl entropic::Entropic for PDUSessionResourceToBeSwitchedDLList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceToBeSwitchedDLItem::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceToBeSwitchedDLList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceToReleaseItemHOCmd {
    pub pdu_session_id: PDUSessionID,
    pub handover_preparation_unsuccessful_transfer:
        PDUSessionResourceToReleaseItemHOCmdHandoverPreparationUnsuccessfulTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceToReleaseItemHOCmdIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceToReleaseItemHOCmd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let handover_preparation_unsuccessful_transfer : PDUSessionResourceToReleaseItemHOCmdHandoverPreparationUnsuccessfulTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceToReleaseItemHOCmdIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            handover_preparation_unsuccessful_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .handover_preparation_unsuccessful_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceToReleaseItemRelCmd {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_release_command_transfer:
        PDUSessionResourceToReleaseItemRelCmdPDUSessionResourceReleaseCommandTransfer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceToReleaseItemRelCmdIE_Extensions>,
}
impl entropic::Entropic for PDUSessionResourceToReleaseItemRelCmd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_id: PDUSessionID = source.get_entropic()?;
        let pdu_session_resource_release_command_transfer : PDUSessionResourceToReleaseItemRelCmdPDUSessionResourceReleaseCommandTransfer = source . get_entropic () ? ;
        let ie_extensions: Option<PDUSessionResourceToReleaseItemRelCmdIE_Extensions> = None;
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_release_command_transfer,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_release_command_transfer
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceToReleaseListHOCmd(pub Vec<PDUSessionResourceToReleaseItemHOCmd>);
impl entropic::Entropic for PDUSessionResourceToReleaseListHOCmd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceToReleaseItemHOCmd::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceToReleaseListHOCmd(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceToReleaseListRelCmd(pub Vec<PDUSessionResourceToReleaseItemRelCmd>);
impl entropic::Entropic for PDUSessionResourceToReleaseListRelCmd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceToReleaseItemRelCmd::from_entropy_source(
                source,
            )?);
        }
        Ok(PDUSessionResourceToReleaseListRelCmd(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct PDUSessionType(pub u8);
impl PDUSessionType {
    pub const IPV4: u8 = 0u8;
    pub const IPV6: u8 = 1u8;
    pub const IPV4V6: u8 = 2u8;
    pub const ETHERNET: u8 = 3u8;
    pub const UNSTRUCTURED: u8 = 4u8;
}
impl entropic::Entropic for PDUSessionType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PDUSessionType(source.get_uniform_range(0..=4)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionUsageReport {
    pub rat_type: PDUSessionUsageReportRATType,
    pub pdu_session_timed_report_list: VolumeTimedReportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionUsageReportIE_Extensions>,
}
impl entropic::Entropic for PDUSessionUsageReport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let rat_type: PDUSessionUsageReportRATType = source.get_entropic()?;
        let pdu_session_timed_report_list: VolumeTimedReportList = source.get_entropic()?;
        let ie_extensions: Option<PDUSessionUsageReportIE_Extensions> = None;
        Ok(Self {
            rat_type,
            pdu_session_timed_report_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.rat_type.to_entropy_sink(sink)?;
        __entropic_internal_length += self.pdu_session_timed_report_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct PLMNIdentity(pub Vec<u8>);
impl entropic::Entropic for PLMNIdentity {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(PLMNIdentity(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PLMNSupportItem {
    pub plmn_identity: PLMNIdentity,
    pub slice_support_list: SliceSupportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PLMNSupportItemIE_Extensions>,
}
impl entropic::Entropic for PLMNSupportItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let slice_support_list: SliceSupportList = source.get_entropic()?;
        let ie_extensions: Option<PLMNSupportItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            slice_support_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.slice_support_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct PLMNSupportList(pub Vec<PLMNSupportItem>);
impl entropic::Entropic for PLMNSupportList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(12, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNSupportItem::from_entropy_source(source)?);
        }
        Ok(PLMNSupportList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(12, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PNI_NPN_MobilityInformation {
    pub allowed_pni_npi_list: Allowed_PNI_NPN_List,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PNI_NPN_MobilityInformationIE_Extensions>,
}
impl entropic::Entropic for PNI_NPN_MobilityInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let allowed_pni_npi_list: Allowed_PNI_NPN_List = source.get_entropic()?;
        let ie_extensions: Option<PNI_NPN_MobilityInformationIE_Extensions> = None;
        Ok(Self {
            allowed_pni_npi_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.allowed_pni_npi_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSCancelRequest {
    pub protocol_i_es: PWSCancelRequestProtocolIEs,
}
impl entropic::Entropic for PWSCancelRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PWSCancelRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSCancelResponse {
    pub protocol_i_es: PWSCancelResponseProtocolIEs,
}
impl entropic::Entropic for PWSCancelResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PWSCancelResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum PWSFailedCellIDList {
    #[asn(key = 0, extended = false)]
    EUTRA_CGI_PWSFailedList(EUTRA_CGIList),
    #[asn(key = 1, extended = false)]
    NR_CGI_PWSFailedList(NR_CGIList),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(PWSFailedCellIDList_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for PWSFailedCellIDList {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            PWSFailedCellIDList::EUTRA_CGI_PWSFailedList(_) => 0u128.try_into().unwrap(),
            PWSFailedCellIDList::NR_CGI_PWSFailedList(_) => 1u128.try_into().unwrap(),
            PWSFailedCellIDList::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSFailureIndication {
    pub protocol_i_es: PWSFailureIndicationProtocolIEs,
}
impl entropic::Entropic for PWSFailureIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PWSFailureIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSRestartIndication {
    pub protocol_i_es: PWSRestartIndicationProtocolIEs,
}
impl entropic::Entropic for PWSRestartIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PWSRestartIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023", extensible = true)]
pub struct PacketDelayBudget(pub u16);
impl entropic::Entropic for PacketDelayBudget {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PacketDelayBudget(source.get_uniform_range(0..=1023)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1023 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PacketErrorRate {
    pub per_scalar: PacketErrorRatePERScalar,
    pub per_exponent: PacketErrorRatePERExponent,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PacketErrorRateIE_Extensions>,
}
impl entropic::Entropic for PacketErrorRate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let per_scalar: PacketErrorRatePERScalar = source.get_entropic()?;
        let per_exponent: PacketErrorRatePERExponent = source.get_entropic()?;
        let ie_extensions: Option<PacketErrorRateIE_Extensions> = None;
        Ok(Self {
            per_scalar,
            per_exponent,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.per_scalar.to_entropy_sink(sink)?;
        __entropic_internal_length += self.per_exponent.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1000", extensible = true)]
pub struct PacketLossRate(pub u16);
impl entropic::Entropic for PacketLossRate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PacketLossRate(source.get_uniform_range(0..=1000)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1000 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct Paging {
    pub protocol_i_es: PagingProtocolIEs,
}
impl entropic::Entropic for Paging {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PagingProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct Paging_Time_Window(pub u8);
impl Paging_Time_Window {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}
impl entropic::Entropic for Paging_Time_Window {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Paging_Time_Window(source.get_uniform_range(0..=15)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct Paging_eDRX_Cycle(pub u8);
impl Paging_eDRX_Cycle {
    pub const HFHALF: u8 = 0u8;
    pub const HF1: u8 = 1u8;
    pub const HF2: u8 = 2u8;
    pub const HF4: u8 = 3u8;
    pub const HF6: u8 = 4u8;
    pub const HF8: u8 = 5u8;
    pub const HF10: u8 = 6u8;
    pub const HF12: u8 = 7u8;
    pub const HF14: u8 = 8u8;
    pub const HF16: u8 = 9u8;
    pub const HF32: u8 = 10u8;
    pub const HF64: u8 = 11u8;
    pub const HF128: u8 = 12u8;
    pub const HF256: u8 = 13u8;
}
impl entropic::Entropic for Paging_eDRX_Cycle {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Paging_eDRX_Cycle(source.get_uniform_range(0..=13)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=13 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PagingAssisDataforCEcapabUE {
    pub eutra_cgi: EUTRA_CGI,
    pub coverage_enhancement_level: CoverageEnhancementLevel,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PagingAssisDataforCEcapabUEIE_Extensions>,
}
impl entropic::Entropic for PagingAssisDataforCEcapabUE {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let coverage_enhancement_level: CoverageEnhancementLevel = source.get_entropic()?;
        let ie_extensions: Option<PagingAssisDataforCEcapabUEIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            coverage_enhancement_level,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.coverage_enhancement_level.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct PagingAttemptCount(pub u8);
impl entropic::Entropic for PagingAttemptCount {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PagingAttemptCount(source.get_uniform_range(1..=16)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=16 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PagingAttemptInformation {
    pub paging_attempt_count: PagingAttemptCount,
    pub intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts,
    #[asn(optional_idx = 0)]
    pub next_paging_area_scope: Option<NextPagingAreaScope>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PagingAttemptInformationIE_Extensions>,
}
impl entropic::Entropic for PagingAttemptInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let paging_attempt_count: PagingAttemptCount = source.get_entropic()?;
        let intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts =
            source.get_entropic()?;
        let next_paging_area_scope: Option<NextPagingAreaScope> = source.get_entropic()?;
        let ie_extensions: Option<PagingAttemptInformationIE_Extensions> = None;
        Ok(Self {
            paging_attempt_count,
            intended_number_of_paging_attempts,
            next_paging_area_scope,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.paging_attempt_count.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .intended_number_of_paging_attempts
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.next_paging_area_scope.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct PagingDRX(pub u8);
impl PagingDRX {
    pub const V32: u8 = 0u8;
    pub const V64: u8 = 1u8;
    pub const V128: u8 = 2u8;
    pub const V256: u8 = 3u8;
}
impl entropic::Entropic for PagingDRX {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PagingDRX(source.get_uniform_range(0..=3)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PagingOrigin(pub u8);
impl PagingOrigin {
    pub const NON_3GPP: u8 = 0u8;
}
impl entropic::Entropic for PagingOrigin {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PagingOrigin(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct PagingPriority(pub u8);
impl PagingPriority {
    pub const PRIOLEVEL1: u8 = 0u8;
    pub const PRIOLEVEL2: u8 = 1u8;
    pub const PRIOLEVEL3: u8 = 2u8;
    pub const PRIOLEVEL4: u8 = 3u8;
    pub const PRIOLEVEL5: u8 = 4u8;
    pub const PRIOLEVEL6: u8 = 5u8;
    pub const PRIOLEVEL7: u8 = 6u8;
    pub const PRIOLEVEL8: u8 = 7u8;
}
impl entropic::Entropic for PagingPriority {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PagingPriority(source.get_uniform_range(0..=7)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=7 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "20")]
pub struct PagingProbabilityInformation(pub u8);
impl PagingProbabilityInformation {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P35: u8 = 7u8;
    pub const P40: u8 = 8u8;
    pub const P45: u8 = 9u8;
    pub const P50: u8 = 10u8;
    pub const P55: u8 = 11u8;
    pub const P60: u8 = 12u8;
    pub const P65: u8 = 13u8;
    pub const P70: u8 = 14u8;
    pub const P75: u8 = 15u8;
    pub const P80: u8 = 16u8;
    pub const P85: u8 = 17u8;
    pub const P90: u8 = 18u8;
    pub const P95: u8 = 19u8;
    pub const P100: u8 = 20u8;
}
impl entropic::Entropic for PagingProbabilityInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PagingProbabilityInformation(
            source.get_uniform_range(0..=20)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=20 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PagingeDRXInformation {
    pub paging_e_drx_cycle: Paging_eDRX_Cycle,
    #[asn(optional_idx = 0)]
    pub paging_time_window: Option<Paging_Time_Window>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PagingeDRXInformationIE_Extensions>,
}
impl entropic::Entropic for PagingeDRXInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let paging_e_drx_cycle: Paging_eDRX_Cycle = source.get_entropic()?;
        let paging_time_window: Option<Paging_Time_Window> = source.get_entropic()?;
        let ie_extensions: Option<PagingeDRXInformationIE_Extensions> = None;
        Ok(Self {
            paging_e_drx_cycle,
            paging_time_window,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.paging_e_drx_cycle.to_entropy_sink(sink)?;
        __entropic_internal_length += self.paging_time_window.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequest {
    pub protocol_i_es: PathSwitchRequestProtocolIEs,
}
impl entropic::Entropic for PathSwitchRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PathSwitchRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestAcknowledge {
    pub protocol_i_es: PathSwitchRequestAcknowledgeProtocolIEs,
}
impl entropic::Entropic for PathSwitchRequestAcknowledge {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PathSwitchRequestAcknowledgeProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PathSwitchRequestAcknowledgeTransfer {
    #[asn(optional_idx = 0)]
    pub ul_ngu_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub security_indication: Option<SecurityIndication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PathSwitchRequestAcknowledgeTransferIE_Extensions>,
}
impl entropic::Entropic for PathSwitchRequestAcknowledgeTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ul_ngu_up_tnl_information: Option<UPTransportLayerInformation> =
            source.get_entropic()?;
        let security_indication: Option<SecurityIndication> = source.get_entropic()?;
        let ie_extensions: Option<PathSwitchRequestAcknowledgeTransferIE_Extensions> = None;
        Ok(Self {
            ul_ngu_up_tnl_information,
            security_indication,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ul_ngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.security_indication.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestFailure {
    pub protocol_i_es: PathSwitchRequestFailureProtocolIEs,
}
impl entropic::Entropic for PathSwitchRequestFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: PathSwitchRequestFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PathSwitchRequestSetupFailedTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PathSwitchRequestSetupFailedTransferIE_Extensions>,
}
impl entropic::Entropic for PathSwitchRequestSetupFailedTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<PathSwitchRequestSetupFailedTransferIE_Extensions> = None;
        Ok(Self {
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PathSwitchRequestTransfer {
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub dl_ngu_tnl_information_reused: Option<DL_NGU_TNLInformationReused>,
    #[asn(optional_idx = 1)]
    pub user_plane_security_information: Option<UserPlaneSecurityInformation>,
    pub qos_flow_accepted_list: QosFlowAcceptedList,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PathSwitchRequestTransferIE_Extensions>,
}
impl entropic::Entropic for PathSwitchRequestTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dl_ngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let dl_ngu_tnl_information_reused: Option<DL_NGU_TNLInformationReused> =
            source.get_entropic()?;
        let user_plane_security_information: Option<UserPlaneSecurityInformation> =
            source.get_entropic()?;
        let qos_flow_accepted_list: QosFlowAcceptedList = source.get_entropic()?;
        let ie_extensions: Option<PathSwitchRequestTransferIE_Extensions> = None;
        Ok(Self {
            dl_ngu_up_tnl_information,
            dl_ngu_tnl_information_reused,
            user_plane_security_information,
            qos_flow_accepted_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dl_ngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.dl_ngu_tnl_information_reused.to_entropy_sink(sink)?;
        __entropic_internal_length += self.user_plane_security_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_accepted_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PathSwitchRequestUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PathSwitchRequestUnsuccessfulTransferIE_Extensions>,
}
impl entropic::Entropic for PathSwitchRequestUnsuccessfulTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<PathSwitchRequestUnsuccessfulTransferIE_Extensions> = None;
        Ok(Self {
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PedestrianUE(pub u8);
impl PedestrianUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for PedestrianUE {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PedestrianUE(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct PeriodicRegistrationUpdateTimer(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for PeriodicRegistrationUpdateTimer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(PeriodicRegistrationUpdateTimer(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "640000", extensible = true)]
pub struct Periodicity(pub u32);
impl entropic::Entropic for Periodicity {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Periodicity(source.get_uniform_range(0..=640000)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=640000 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct PortNumber(pub Vec<u8>);
impl entropic::Entropic for PortNumber {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(PortNumber(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Pre_emptionCapability(pub u8);
impl Pre_emptionCapability {
    pub const SHALL_NOT_TRIGGER_PRE_EMPTION: u8 = 0u8;
    pub const MAY_TRIGGER_PRE_EMPTION: u8 = 1u8;
}
impl entropic::Entropic for Pre_emptionCapability {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Pre_emptionCapability(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Pre_emptionVulnerability(pub u8);
impl Pre_emptionVulnerability {
    pub const NOT_PRE_EMPTABLE: u8 = 0u8;
    pub const PRE_EMPTABLE: u8 = 1u8;
}
impl entropic::Entropic for Pre_emptionVulnerability {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Pre_emptionVulnerability(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Presence(pub u8);
impl Presence {
    pub const OPTIONAL: u8 = 0u8;
    pub const CONDITIONAL: u8 = 1u8;
    pub const MANDATORY: u8 = 2u8;
}
impl entropic::Entropic for Presence {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Presence(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "15")]
pub struct PriorityLevelARP(pub u8);
impl entropic::Entropic for PriorityLevelARP {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PriorityLevelARP(source.get_uniform_range(1..=15)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "127", extensible = true)]
pub struct PriorityLevelQos(pub u8);
impl entropic::Entropic for PriorityLevelQos {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PriorityLevelQos(source.get_uniform_range(1..=127)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=127 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PrivacyIndicator(pub u8);
impl PrivacyIndicator {
    pub const IMMEDIATE_MDT: u8 = 0u8;
    pub const LOGGED_MDT: u8 = 1u8;
}
impl entropic::Entropic for PrivacyIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PrivacyIndicator(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PrivateIE_ID {
    #[asn(key = 0, extended = false)]
    Local(PrivateIE_ID_local),
    #[asn(key = 1, extended = false)]
    Global(PrivateIE_ID_global),
}
impl asn1_codecs::Asn1Choice for PrivateIE_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            PrivateIE_ID::Local(_) => 0u128.try_into().unwrap(),
            PrivateIE_ID::Global(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PrivateMessage {
    pub private_i_es: PrivateMessagePrivateIEs,
}
impl entropic::Entropic for PrivateMessage {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let private_i_es: PrivateMessagePrivateIEs = source.get_entropic()?;
        Ok(Self { private_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.private_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct ProcedureCode(pub u8);
impl entropic::Entropic for ProcedureCode {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ProcedureCode(source.get_uniform_range(0..=255)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ProcedureStageChoice {
    #[asn(key = 0, extended = false)]
    First_dl_count(FirstDLCount),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(ProcedureStageChoice_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for ProcedureStageChoice {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            ProcedureStageChoice::First_dl_count(_) => 0u128.try_into().unwrap(),
            ProcedureStageChoice::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolExtensionID(pub u16);
impl entropic::Entropic for ProtocolExtensionID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ProtocolExtensionID(source.get_uniform_range(0..=65535)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolIE_ID(pub u16);
impl entropic::Entropic for ProtocolIE_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ProtocolIE_ID(source.get_uniform_range(0..=65535)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QoSFlowsUsageReport_Item {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub rat_type: QoSFlowsUsageReport_ItemRATType,
    pub qo_s_flows_timed_report_list: VolumeTimedReportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QoSFlowsUsageReport_ItemIE_Extensions>,
}
impl entropic::Entropic for QoSFlowsUsageReport_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let rat_type: QoSFlowsUsageReport_ItemRATType = source.get_entropic()?;
        let qo_s_flows_timed_report_list: VolumeTimedReportList = source.get_entropic()?;
        let ie_extensions: Option<QoSFlowsUsageReport_ItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            rat_type,
            qo_s_flows_timed_report_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rat_type.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qo_s_flows_timed_report_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QoSFlowsUsageReportList(pub Vec<QoSFlowsUsageReport_Item>);
impl entropic::Entropic for QoSFlowsUsageReportList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QoSFlowsUsageReport_Item::from_entropy_source(source)?);
        }
        Ok(QoSFlowsUsageReportList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum QosCharacteristics {
    #[asn(key = 0, extended = false)]
    NonDynamic5QI(NonDynamic5QIDescriptor),
    #[asn(key = 1, extended = false)]
    Dynamic5QI(Dynamic5QIDescriptor),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(QosCharacteristics_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for QosCharacteristics {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            QosCharacteristics::NonDynamic5QI(_) => 0u128.try_into().unwrap(),
            QosCharacteristics::Dynamic5QI(_) => 1u128.try_into().unwrap(),
            QosCharacteristics::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowAcceptedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowAcceptedItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowAcceptedItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let ie_extensions: Option<QosFlowAcceptedItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowAcceptedList(pub Vec<QosFlowAcceptedItem>);
impl entropic::Entropic for QosFlowAcceptedList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowAcceptedItem::from_entropy_source(source)?);
        }
        Ok(QosFlowAcceptedList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct QosFlowAddOrModifyRequestItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub qos_flow_level_qos_parameters: Option<QosFlowLevelQosParameters>,
    #[asn(optional_idx = 1)]
    pub e_rab_id: Option<E_RAB_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<QosFlowAddOrModifyRequestItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowAddOrModifyRequestItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let qos_flow_level_qos_parameters: Option<QosFlowLevelQosParameters> =
            source.get_entropic()?;
        let e_rab_id: Option<E_RAB_ID> = source.get_entropic()?;
        let ie_extensions: Option<QosFlowAddOrModifyRequestItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
            e_rab_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_level_qos_parameters.to_entropy_sink(sink)?;
        __entropic_internal_length += self.e_rab_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowAddOrModifyRequestList(pub Vec<QosFlowAddOrModifyRequestItem>);
impl entropic::Entropic for QosFlowAddOrModifyRequestList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowAddOrModifyRequestItem::from_entropy_source(source)?);
        }
        Ok(QosFlowAddOrModifyRequestList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowAddOrModifyResponseItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowAddOrModifyResponseItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowAddOrModifyResponseItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let ie_extensions: Option<QosFlowAddOrModifyResponseItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowAddOrModifyResponseList(pub Vec<QosFlowAddOrModifyResponseItem>);
impl entropic::Entropic for QosFlowAddOrModifyResponseList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowAddOrModifyResponseItem::from_entropy_source(source)?);
        }
        Ok(QosFlowAddOrModifyResponseList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct QosFlowFeedbackItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub update_feedback: Option<UpdateFeedback>,
    #[asn(optional_idx = 1)]
    pub c_npacket_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
    #[asn(optional_idx = 2)]
    pub c_npacket_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<QosFlowFeedbackItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowFeedbackItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let update_feedback: Option<UpdateFeedback> = source.get_entropic()?;
        let c_npacket_delay_budget_dl: Option<ExtendedPacketDelayBudget> = source.get_entropic()?;
        let c_npacket_delay_budget_ul: Option<ExtendedPacketDelayBudget> = source.get_entropic()?;
        let ie_extensions: Option<QosFlowFeedbackItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            update_feedback,
            c_npacket_delay_budget_dl,
            c_npacket_delay_budget_ul,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.update_feedback.to_entropy_sink(sink)?;
        __entropic_internal_length += self.c_npacket_delay_budget_dl.to_entropy_sink(sink)?;
        __entropic_internal_length += self.c_npacket_delay_budget_ul.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowFeedbackList(pub Vec<QosFlowFeedbackItem>);
impl entropic::Entropic for QosFlowFeedbackList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowFeedbackItem::from_entropy_source(source)?);
        }
        Ok(QosFlowFeedbackList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63", extensible = true)]
pub struct QosFlowIdentifier(pub u8);
impl entropic::Entropic for QosFlowIdentifier {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(QosFlowIdentifier(source.get_uniform_range(0..=63)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=63 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowInformationItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DLForwarding>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowInformationItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowInformationItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let dl_forwarding: Option<DLForwarding> = source.get_entropic()?;
        let ie_extensions: Option<QosFlowInformationItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            dl_forwarding,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.dl_forwarding.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowInformationList(pub Vec<QosFlowInformationItem>);
impl entropic::Entropic for QosFlowInformationList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowInformationItem::from_entropy_source(source)?);
        }
        Ok(QosFlowInformationList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowItemWithDataForwarding {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub data_forwarding_accepted: Option<DataForwardingAccepted>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowItemWithDataForwardingIE_Extensions>,
}
impl entropic::Entropic for QosFlowItemWithDataForwarding {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let data_forwarding_accepted: Option<DataForwardingAccepted> = source.get_entropic()?;
        let ie_extensions: Option<QosFlowItemWithDataForwardingIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            data_forwarding_accepted,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.data_forwarding_accepted.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct QosFlowLevelQosParameters {
    pub qos_characteristics: QosCharacteristics,
    pub allocation_and_retention_priority: AllocationAndRetentionPriority,
    #[asn(optional_idx = 0)]
    pub gbr_qos_information: Option<GBR_QosInformation>,
    #[asn(optional_idx = 1)]
    pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
    #[asn(optional_idx = 2)]
    pub additional_qos_flow_information: Option<AdditionalQosFlowInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<QosFlowLevelQosParametersIE_Extensions>,
}
impl entropic::Entropic for QosFlowLevelQosParameters {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_characteristics: QosCharacteristics = source.get_entropic()?;
        let allocation_and_retention_priority: AllocationAndRetentionPriority =
            source.get_entropic()?;
        let gbr_qos_information: Option<GBR_QosInformation> = source.get_entropic()?;
        let reflective_qos_attribute: Option<ReflectiveQosAttribute> = source.get_entropic()?;
        let additional_qos_flow_information: Option<AdditionalQosFlowInformation> =
            source.get_entropic()?;
        let ie_extensions: Option<QosFlowLevelQosParametersIE_Extensions> = None;
        Ok(Self {
            qos_characteristics,
            allocation_and_retention_priority,
            gbr_qos_information,
            reflective_qos_attribute,
            additional_qos_flow_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_characteristics.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .allocation_and_retention_priority
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.gbr_qos_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.reflective_qos_attribute.to_entropy_sink(sink)?;
        __entropic_internal_length += self.additional_qos_flow_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowListWithCause(pub Vec<QosFlowWithCauseItem>);
impl entropic::Entropic for QosFlowListWithCause {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowWithCauseItem::from_entropy_source(source)?);
        }
        Ok(QosFlowListWithCause(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowListWithDataForwarding(pub Vec<QosFlowItemWithDataForwarding>);
impl entropic::Entropic for QosFlowListWithDataForwarding {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowItemWithDataForwarding::from_entropy_source(source)?);
        }
        Ok(QosFlowListWithDataForwarding(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowModifyConfirmItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowModifyConfirmItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowModifyConfirmItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let ie_extensions: Option<QosFlowModifyConfirmItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowModifyConfirmList(pub Vec<QosFlowModifyConfirmItem>);
impl entropic::Entropic for QosFlowModifyConfirmList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowModifyConfirmItem::from_entropy_source(source)?);
        }
        Ok(QosFlowModifyConfirmList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowNotifyItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub notification_cause: NotificationCause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowNotifyItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowNotifyItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let notification_cause: NotificationCause = source.get_entropic()?;
        let ie_extensions: Option<QosFlowNotifyItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            notification_cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.notification_cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowNotifyList(pub Vec<QosFlowNotifyItem>);
impl entropic::Entropic for QosFlowNotifyList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowNotifyItem::from_entropy_source(source)?);
        }
        Ok(QosFlowNotifyList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowParametersItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub alternative_qo_s_para_set_list: Option<AlternativeQoSParaSetList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowParametersItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowParametersItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let alternative_qo_s_para_set_list: Option<AlternativeQoSParaSetList> =
            source.get_entropic()?;
        let ie_extensions: Option<QosFlowParametersItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            alternative_qo_s_para_set_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.alternative_qo_s_para_set_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowParametersList(pub Vec<QosFlowParametersItem>);
impl entropic::Entropic for QosFlowParametersList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowParametersItem::from_entropy_source(source)?);
        }
        Ok(QosFlowParametersList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowPerTNLInformation {
    pub up_transport_layer_information: UPTransportLayerInformation,
    pub associated_qos_flow_list: AssociatedQosFlowList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowPerTNLInformationIE_Extensions>,
}
impl entropic::Entropic for QosFlowPerTNLInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let up_transport_layer_information: UPTransportLayerInformation = source.get_entropic()?;
        let associated_qos_flow_list: AssociatedQosFlowList = source.get_entropic()?;
        let ie_extensions: Option<QosFlowPerTNLInformationIE_Extensions> = None;
        Ok(Self {
            up_transport_layer_information,
            associated_qos_flow_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.up_transport_layer_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.associated_qos_flow_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowPerTNLInformationItem {
    pub qos_flow_per_tnl_information: QosFlowPerTNLInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowPerTNLInformationItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowPerTNLInformationItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_per_tnl_information: QosFlowPerTNLInformation = source.get_entropic()?;
        let ie_extensions: Option<QosFlowPerTNLInformationItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_per_tnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_per_tnl_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct QosFlowPerTNLInformationList(pub Vec<QosFlowPerTNLInformationItem>);
impl entropic::Entropic for QosFlowPerTNLInformationList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowPerTNLInformationItem::from_entropy_source(source)?);
        }
        Ok(QosFlowPerTNLInformationList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(3, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowSetupRequestItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
    #[asn(optional_idx = 0)]
    pub e_rab_id: Option<E_RAB_ID>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowSetupRequestItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowSetupRequestItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let qos_flow_level_qos_parameters: QosFlowLevelQosParameters = source.get_entropic()?;
        let e_rab_id: Option<E_RAB_ID> = source.get_entropic()?;
        let ie_extensions: Option<QosFlowSetupRequestItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
            e_rab_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flow_level_qos_parameters.to_entropy_sink(sink)?;
        __entropic_internal_length += self.e_rab_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowSetupRequestList(pub Vec<QosFlowSetupRequestItem>);
impl entropic::Entropic for QosFlowSetupRequestList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowSetupRequestItem::from_entropy_source(source)?);
        }
        Ok(QosFlowSetupRequestList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowToBeForwardedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowToBeForwardedItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowToBeForwardedItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let ie_extensions: Option<QosFlowToBeForwardedItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowToBeForwardedList(pub Vec<QosFlowToBeForwardedItem>);
impl entropic::Entropic for QosFlowToBeForwardedList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowToBeForwardedItem::from_entropy_source(source)?);
        }
        Ok(QosFlowToBeForwardedList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowWithCauseItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowWithCauseItemIE_Extensions>,
}
impl entropic::Entropic for QosFlowWithCauseItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_identifier: QosFlowIdentifier = source.get_entropic()?;
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<QosFlowWithCauseItemIE_Extensions> = None;
        Ok(Self {
            qos_flow_identifier,
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_identifier.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1800", extensible = true)]
pub struct QosMonitoringReportingFrequency(pub u16);
impl entropic::Entropic for QosMonitoringReportingFrequency {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(QosMonitoringReportingFrequency(
            source.get_uniform_range(1..=1800)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=1800 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct QosMonitoringRequest(pub u8);
impl QosMonitoringRequest {
    pub const UL: u8 = 0u8;
    pub const DL: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}
impl entropic::Entropic for QosMonitoringRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(QosMonitoringRequest(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct RAN_UE_NGAP_ID(pub u32);
impl entropic::Entropic for RAN_UE_NGAP_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RAN_UE_NGAP_ID(source.get_uniform_range(0..=4294967295)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4294967295 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANCPRelocationIndication {
    pub protocol_i_es: RANCPRelocationIndicationProtocolIEs,
}
impl entropic::Entropic for RANCPRelocationIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: RANCPRelocationIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANConfigurationUpdate {
    pub protocol_i_es: RANConfigurationUpdateProtocolIEs,
}
impl entropic::Entropic for RANConfigurationUpdate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: RANConfigurationUpdateProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANConfigurationUpdateAcknowledge {
    pub protocol_i_es: RANConfigurationUpdateAcknowledgeProtocolIEs,
}
impl entropic::Entropic for RANConfigurationUpdateAcknowledge {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: RANConfigurationUpdateAcknowledgeProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANConfigurationUpdateFailure {
    pub protocol_i_es: RANConfigurationUpdateFailureProtocolIEs,
}
impl entropic::Entropic for RANConfigurationUpdateFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: RANConfigurationUpdateFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct RANNodeName(pub String);
impl entropic::Entropic for RANNodeName {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_entropy_source(source)?);
        }
        Ok(Self(s))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_entropy_sink(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "UTF8String", sz_extensible = true, sz_lb = "1", sz_ub = "150")]
pub struct RANNodeNameUTF8String(pub String);
impl entropic::Entropic for RANNodeNameUTF8String {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_entropy_source(source)?);
        }
        Ok(Self(s))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_entropy_sink(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "VisibleString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct RANNodeNameVisibleString(pub String);
impl entropic::Entropic for RANNodeNameVisibleString {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_entropy_source(source)?);
        }
        Ok(Self(s))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_entropy_sink(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct RANPagingPriority(pub u16);
impl entropic::Entropic for RANPagingPriority {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RANPagingPriority(source.get_uniform_range(1..=256)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=256 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RANStatusTransfer_TransparentContainer {
    pub dr_bs_subject_to_status_transfer_list: DRBsSubjectToStatusTransferList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RANStatusTransfer_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for RANStatusTransfer_TransparentContainer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dr_bs_subject_to_status_transfer_list: DRBsSubjectToStatusTransferList =
            source.get_entropic()?;
        let ie_extensions: Option<RANStatusTransfer_TransparentContainerIE_Extensions> = None;
        Ok(Self {
            dr_bs_subject_to_status_transfer_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .dr_bs_subject_to_status_transfer_list
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RAT_Information(pub u8);
impl RAT_Information {
    pub const UNLICENSED: u8 = 0u8;
    pub const NB_IO_T: u8 = 1u8;
}
impl entropic::Entropic for RAT_Information {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RAT_Information(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct RATRestrictionInformation(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for RATRestrictionInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(RATRestrictionInformation(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RATRestrictions(pub Vec<RATRestrictions_Item>);
impl entropic::Entropic for RATRestrictions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RATRestrictions_Item::from_entropy_source(source)?);
        }
        Ok(RATRestrictions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RATRestrictions_Item {
    pub plmn_identity: PLMNIdentity,
    pub rat_restriction_information: RATRestrictionInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RATRestrictions_ItemIE_Extensions>,
}
impl entropic::Entropic for RATRestrictions_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let rat_restriction_information: RATRestrictionInformation = source.get_entropic()?;
        let ie_extensions: Option<RATRestrictions_ItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            rat_restriction_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rat_restriction_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RGLevelWirelineAccessCharacteristics(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RIMInformation {
    pub targetg_nb_set_id: GNBSetID,
    pub rim_rs_detection: RIMInformationRIM_RSDetection,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RIMInformationIE_Extensions>,
}
impl entropic::Entropic for RIMInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let targetg_nb_set_id: GNBSetID = source.get_entropic()?;
        let rim_rs_detection: RIMInformationRIM_RSDetection = source.get_entropic()?;
        let ie_extensions: Option<RIMInformationIE_Extensions> = None;
        Ok(Self {
            targetg_nb_set_id,
            rim_rs_detection,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.targetg_nb_set_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rim_rs_detection.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RIMInformationTransfer {
    pub target_ran_node_id: TargetRANNodeID,
    pub source_ran_node_id: SourceRANNodeID,
    pub rim_information: RIMInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RIMInformationTransferIE_Extensions>,
}
impl entropic::Entropic for RIMInformationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let target_ran_node_id: TargetRANNodeID = source.get_entropic()?;
        let source_ran_node_id: SourceRANNodeID = source.get_entropic()?;
        let rim_information: RIMInformation = source.get_entropic()?;
        let ie_extensions: Option<RIMInformationTransferIE_Extensions> = None;
        Ok(Self {
            target_ran_node_id,
            source_ran_node_id,
            rim_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.target_ran_node_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.source_ran_node_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rim_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RNC_ID(pub u16);
impl entropic::Entropic for RNC_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RNC_ID(source.get_uniform_range(0..=4095)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "9")]
pub struct RRCEstablishmentCause(pub u8);
impl RRCEstablishmentCause {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
    pub const MO_VOICE_CALL: u8 = 5u8;
    pub const MO_VIDEO_CALL: u8 = 6u8;
    pub const MO_SMS: u8 = 7u8;
    pub const MPS_PRIORITY_ACCESS: u8 = 8u8;
    pub const MCS_PRIORITY_ACCESS: u8 = 9u8;
}
impl entropic::Entropic for RRCEstablishmentCause {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RRCEstablishmentCause(source.get_uniform_range(0..=9)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=9 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RRCInactiveTransitionReport {
    pub protocol_i_es: RRCInactiveTransitionReportProtocolIEs,
}
impl entropic::Entropic for RRCInactiveTransitionReport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: RRCInactiveTransitionReportProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct RRCInactiveTransitionReportRequest(pub u8);
impl RRCInactiveTransitionReportRequest {
    pub const SUBSEQUENT_STATE_TRANSITION_REPORT: u8 = 0u8;
    pub const SINGLE_RRC_CONNECTED_STATE_REPORT: u8 = 1u8;
    pub const CANCEL_REPORT: u8 = 2u8;
}
impl entropic::Entropic for RRCInactiveTransitionReportRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RRCInactiveTransitionReportRequest(
            source.get_uniform_range(0..=2)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RRCState(pub u8);
impl RRCState {
    pub const INACTIVE: u8 = 0u8;
    pub const CONNECTED: u8 = 1u8;
}
impl entropic::Entropic for RRCState {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RRCState(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RSN(pub u8);
impl RSN {
    pub const V1: u8 = 0u8;
    pub const V2: u8 = 1u8;
}
impl entropic::Entropic for RSN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RSN(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "8")]
pub struct Range(pub u8);
impl Range {
    pub const M50: u8 = 0u8;
    pub const M80: u8 = 1u8;
    pub const M180: u8 = 2u8;
    pub const M200: u8 = 3u8;
    pub const M350: u8 = 4u8;
    pub const M400: u8 = 5u8;
    pub const M500: u8 = 6u8;
    pub const M700: u8 = 7u8;
    pub const M1000: u8 = 8u8;
}
impl entropic::Entropic for Range {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Range(source.get_uniform_range(0..=8)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=8 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RecommendedCellItem {
    pub ngran_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub time_stayed_in_cell: Option<RecommendedCellItemTimeStayedInCell>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RecommendedCellItemIE_Extensions>,
}
impl entropic::Entropic for RecommendedCellItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ngran_cgi: NGRAN_CGI = source.get_entropic()?;
        let time_stayed_in_cell: Option<RecommendedCellItemTimeStayedInCell> =
            source.get_entropic()?;
        let ie_extensions: Option<RecommendedCellItemIE_Extensions> = None;
        Ok(Self {
            ngran_cgi,
            time_stayed_in_cell,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ngran_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.time_stayed_in_cell.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedCellList(pub Vec<RecommendedCellItem>);
impl entropic::Entropic for RecommendedCellList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedCellItem::from_entropy_source(source)?);
        }
        Ok(RecommendedCellList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedCellsForPaging {
    pub recommended_cell_list: RecommendedCellList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedCellsForPagingIE_Extensions>,
}
impl entropic::Entropic for RecommendedCellsForPaging {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let recommended_cell_list: RecommendedCellList = source.get_entropic()?;
        let ie_extensions: Option<RecommendedCellsForPagingIE_Extensions> = None;
        Ok(Self {
            recommended_cell_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.recommended_cell_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedRANNodeItem {
    pub amf_paging_target: AMFPagingTarget,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedRANNodeItemIE_Extensions>,
}
impl entropic::Entropic for RecommendedRANNodeItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_paging_target: AMFPagingTarget = source.get_entropic()?;
        let ie_extensions: Option<RecommendedRANNodeItemIE_Extensions> = None;
        Ok(Self {
            amf_paging_target,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_paging_target.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedRANNodeList(pub Vec<RecommendedRANNodeItem>);
impl entropic::Entropic for RecommendedRANNodeList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedRANNodeItem::from_entropy_source(source)?);
        }
        Ok(RecommendedRANNodeList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedRANNodesForPaging {
    pub recommended_ran_node_list: RecommendedRANNodeList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedRANNodesForPagingIE_Extensions>,
}
impl entropic::Entropic for RecommendedRANNodesForPaging {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let recommended_ran_node_list: RecommendedRANNodeList = source.get_entropic()?;
        let ie_extensions: Option<RecommendedRANNodesForPagingIE_Extensions> = None;
        Ok(Self {
            recommended_ran_node_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.recommended_ran_node_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RedirectionVoiceFallback(pub u8);
impl RedirectionVoiceFallback {
    pub const POSSIBLE: u8 = 0u8;
    pub const NOT_POSSIBLE: u8 = 1u8;
}
impl entropic::Entropic for RedirectionVoiceFallback {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RedirectionVoiceFallback(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RedundantPDUSessionInformation {
    pub rsn: RSN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RedundantPDUSessionInformationIE_Extensions>,
}
impl entropic::Entropic for RedundantPDUSessionInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let rsn: RSN = source.get_entropic()?;
        let ie_extensions: Option<RedundantPDUSessionInformationIE_Extensions> = None;
        Ok(Self { rsn, ie_extensions })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.rsn.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RedundantQosFlowIndicator(pub u8);
impl RedundantQosFlowIndicator {
    pub const TRUE: u8 = 0u8;
    pub const FALSE: u8 = 1u8;
}
impl entropic::Entropic for RedundantQosFlowIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RedundantQosFlowIndicator(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReflectiveQosAttribute(pub u8);
impl ReflectiveQosAttribute {
    pub const SUBJECT_TO: u8 = 0u8;
}
impl entropic::Entropic for ReflectiveQosAttribute {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ReflectiveQosAttribute(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "32",
    sz_ub = "32"
)]
pub struct RejectedNSSAIinPLMN(pub Vec<u8>);
impl entropic::Entropic for RejectedNSSAIinPLMN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 16383);
        let vec_len = source.get_bounded_len(32..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(RejectedNSSAIinPLMN(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "32",
    sz_ub = "32"
)]
pub struct RejectedNSSAIinTA(pub Vec<u8>);
impl entropic::Entropic for RejectedNSSAIinTA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 16383);
        let vec_len = source.get_bounded_len(32..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(RejectedNSSAIinTA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct RelativeAMFCapacity(pub u8);
impl entropic::Entropic for RelativeAMFCapacity {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RelativeAMFCapacity(source.get_uniform_range(0..=255)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "131071")]
pub struct RepetitionPeriod(pub u32);
impl entropic::Entropic for RepetitionPeriod {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RepetitionPeriod(source.get_uniform_range(0..=131071)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=131071 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ReportAmountMDT(pub u8);
impl ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const RINFINITY: u8 = 7u8;
}
impl entropic::Entropic for ReportAmountMDT {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ReportAmountMDT(source.get_uniform_range(0..=7)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=7 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReportArea(pub u8);
impl ReportArea {
    pub const CELL: u8 = 0u8;
}
impl entropic::Entropic for ReportArea {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ReportArea(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "12")]
pub struct ReportIntervalMDT(pub u8);
impl ReportIntervalMDT {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MIN1: u8 = 8u8;
    pub const MIN6: u8 = 9u8;
    pub const MIN12: u8 = 10u8;
    pub const MIN30: u8 = 11u8;
    pub const MIN60: u8 = 12u8;
}
impl entropic::Entropic for ReportIntervalMDT {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ReportIntervalMDT(source.get_uniform_range(0..=12)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=12 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RerouteNASRequest {
    pub protocol_i_es: RerouteNASRequestProtocolIEs,
}
impl entropic::Entropic for RerouteNASRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: RerouteNASRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ResetAll(pub u8);
impl ResetAll {
    pub const RESET_ALL: u8 = 0u8;
}
impl entropic::Entropic for ResetAll {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ResetAll(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ResetType {
    #[asn(key = 0, extended = false)]
    NG_Interface(ResetAll),
    #[asn(key = 1, extended = false)]
    PartOfNG_Interface(UE_associatedLogicalNG_connectionList),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(ResetType_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for ResetType {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            ResetType::NG_Interface(_) => 0u128.try_into().unwrap(),
            ResetType::PartOfNG_Interface(_) => 1u128.try_into().unwrap(),
            ResetType::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RetrieveUEInformation {
    pub protocol_i_es: RetrieveUEInformationProtocolIEs,
}
impl entropic::Entropic for RetrieveUEInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: RetrieveUEInformationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RoutingID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct S_NSSAI {
    pub sst: SST,
    #[asn(optional_idx = 0)]
    pub sd: Option<SD>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<S_NSSAIIE_Extensions>,
}
impl entropic::Entropic for S_NSSAI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let sst: SST = source.get_entropic()?;
        let sd: Option<SD> = source.get_entropic()?;
        let ie_extensions: Option<S_NSSAIIE_Extensions> = None;
        Ok(Self {
            sst,
            sd,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.sst.to_entropy_sink(sink)?;
        __entropic_internal_length += self.sd.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SCTP_TLAs(pub Vec<TransportLayerAddress>);
impl entropic::Entropic for SCTP_TLAs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TransportLayerAddress::from_entropy_source(source)?);
        }
        Ok(SCTP_TLAs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct SD(pub Vec<u8>);
impl entropic::Entropic for SD {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(SD(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SNPN_MobilityInformation {
    pub serving_nid: NID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SNPN_MobilityInformationIE_Extensions>,
}
impl entropic::Entropic for SNPN_MobilityInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let serving_nid: NID = source.get_entropic()?;
        let ie_extensions: Option<SNPN_MobilityInformationIE_Extensions> = None;
        Ok(Self {
            serving_nid,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.serving_nid.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SONConfigurationTransfer {
    pub target_ran_node_id: TargetRANNodeID,
    pub source_ran_node_id: SourceRANNodeID,
    pub son_information: SONInformation,
    #[asn(optional_idx = 0)]
    pub xn_tnl_configuration_info: Option<XnTNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SONConfigurationTransferIE_Extensions>,
}
impl entropic::Entropic for SONConfigurationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let target_ran_node_id: TargetRANNodeID = source.get_entropic()?;
        let source_ran_node_id: SourceRANNodeID = source.get_entropic()?;
        let son_information: SONInformation = source.get_entropic()?;
        let xn_tnl_configuration_info: Option<XnTNLConfigurationInfo> = source.get_entropic()?;
        let ie_extensions: Option<SONConfigurationTransferIE_Extensions> = None;
        Ok(Self {
            target_ran_node_id,
            source_ran_node_id,
            son_information,
            xn_tnl_configuration_info,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.target_ran_node_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.source_ran_node_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.son_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.xn_tnl_configuration_info.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum SONInformation {
    #[asn(key = 0, extended = false)]
    SONInformationRequest(SONInformationRequest),
    #[asn(key = 1, extended = false)]
    SONInformationReply(SONInformationReply),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(SONInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for SONInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SONInformation::SONInformationRequest(_) => 0u128.try_into().unwrap(),
            SONInformation::SONInformationReply(_) => 1u128.try_into().unwrap(),
            SONInformation::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SONInformationReply {
    #[asn(optional_idx = 0)]
    pub xn_tnl_configuration_info: Option<XnTNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SONInformationReplyIE_Extensions>,
}
impl entropic::Entropic for SONInformationReply {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let xn_tnl_configuration_info: Option<XnTNLConfigurationInfo> = source.get_entropic()?;
        let ie_extensions: Option<SONInformationReplyIE_Extensions> = None;
        Ok(Self {
            xn_tnl_configuration_info,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.xn_tnl_configuration_info.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum SONInformationReport {
    #[asn(key = 0, extended = false)]
    FailureIndicationInformation(FailureIndication),
    #[asn(key = 1, extended = false)]
    HOReportInformation(HOReport),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(SONInformationReport_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for SONInformationReport {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SONInformationReport::FailureIndicationInformation(_) => 0u128.try_into().unwrap(),
            SONInformationReport::HOReportInformation(_) => 1u128.try_into().unwrap(),
            SONInformationReport::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SONInformationRequest(pub u8);
impl SONInformationRequest {
    pub const XN_TNL_CONFIGURATION_INFO: u8 = 0u8;
}
impl entropic::Entropic for SONInformationRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SONInformationRequest(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SRVCCOperationPossible(pub u8);
impl SRVCCOperationPossible {
    pub const POSSIBLE: u8 = 0u8;
    pub const NOT_POSSIBLE: u8 = 1u8;
}
impl entropic::Entropic for SRVCCOperationPossible {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SRVCCOperationPossible(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct SST(pub Vec<u8>);
impl entropic::Entropic for SST {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(SST(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ScheduledCommunicationTime {
    #[asn(optional_idx = 0)]
    pub dayof_week: Option<ScheduledCommunicationTimeDayofWeek>,
    #[asn(optional_idx = 1)]
    pub timeof_day_start: Option<ScheduledCommunicationTimeTimeofDayStart>,
    #[asn(optional_idx = 2)]
    pub timeof_day_end: Option<ScheduledCommunicationTimeTimeofDayEnd>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ScheduledCommunicationTimeIE_Extensions>,
}
impl entropic::Entropic for ScheduledCommunicationTime {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let dayof_week: Option<ScheduledCommunicationTimeDayofWeek> = source.get_entropic()?;
        let timeof_day_start: Option<ScheduledCommunicationTimeTimeofDayStart> =
            source.get_entropic()?;
        let timeof_day_end: Option<ScheduledCommunicationTimeTimeofDayEnd> =
            source.get_entropic()?;
        let ie_extensions: Option<ScheduledCommunicationTimeIE_Extensions> = None;
        Ok(Self {
            dayof_week,
            timeof_day_start,
            timeof_day_end,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dayof_week.to_entropy_sink(sink)?;
        __entropic_internal_length += self.timeof_day_start.to_entropy_sink(sink)?;
        __entropic_internal_length += self.timeof_day_end.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecondaryRATDataUsageReport {
    pub protocol_i_es: SecondaryRATDataUsageReportProtocolIEs,
}
impl entropic::Entropic for SecondaryRATDataUsageReport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: SecondaryRATDataUsageReportProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SecondaryRATDataUsageReportTransfer {
    #[asn(optional_idx = 0)]
    pub secondary_rat_usage_information: Option<SecondaryRATUsageInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SecondaryRATDataUsageReportTransferIE_Extensions>,
}
impl entropic::Entropic for SecondaryRATDataUsageReportTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let secondary_rat_usage_information: Option<SecondaryRATUsageInformation> =
            source.get_entropic()?;
        let ie_extensions: Option<SecondaryRATDataUsageReportTransferIE_Extensions> = None;
        Ok(Self {
            secondary_rat_usage_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.secondary_rat_usage_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SecondaryRATUsageInformation {
    #[asn(optional_idx = 0)]
    pub pdu_session_usage_report: Option<PDUSessionUsageReport>,
    #[asn(optional_idx = 1)]
    pub qos_flows_usage_report_list: Option<QoSFlowsUsageReportList>,
    #[asn(optional_idx = 2)]
    pub ie_extension: Option<SecondaryRATUsageInformationIE_Extension>,
}
impl entropic::Entropic for SecondaryRATUsageInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let pdu_session_usage_report: Option<PDUSessionUsageReport> = source.get_entropic()?;
        let qos_flows_usage_report_list: Option<QoSFlowsUsageReportList> = source.get_entropic()?;
        let ie_extension: Option<SecondaryRATUsageInformationIE_Extension> =
            source.get_entropic()?;
        Ok(Self {
            pdu_session_usage_report,
            qos_flows_usage_report_list,
            ie_extension,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdu_session_usage_report.to_entropy_sink(sink)?;
        __entropic_internal_length += self.qos_flows_usage_report_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ie_extension.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityContext {
    pub next_hop_chaining_count: NextHopChainingCount,
    pub next_hop_nh: SecurityKey,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityContextIE_Extensions>,
}
impl entropic::Entropic for SecurityContext {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let next_hop_chaining_count: NextHopChainingCount = source.get_entropic()?;
        let next_hop_nh: SecurityKey = source.get_entropic()?;
        let ie_extensions: Option<SecurityContextIE_Extensions> = None;
        Ok(Self {
            next_hop_chaining_count,
            next_hop_nh,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.next_hop_chaining_count.to_entropy_sink(sink)?;
        __entropic_internal_length += self.next_hop_nh.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SecurityIndication {
    pub integrity_protection_indication: IntegrityProtectionIndication,
    pub confidentiality_protection_indication: ConfidentialityProtectionIndication,
    #[asn(optional_idx = 0)]
    pub maximum_integrity_protected_data_rate_ul: Option<MaximumIntegrityProtectedDataRate>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SecurityIndicationIE_Extensions>,
}
impl entropic::Entropic for SecurityIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let integrity_protection_indication: IntegrityProtectionIndication =
            source.get_entropic()?;
        let confidentiality_protection_indication: ConfidentialityProtectionIndication =
            source.get_entropic()?;
        let maximum_integrity_protected_data_rate_ul: Option<MaximumIntegrityProtectedDataRate> =
            source.get_entropic()?;
        let ie_extensions: Option<SecurityIndicationIE_Extensions> = None;
        Ok(Self {
            integrity_protection_indication,
            confidentiality_protection_indication,
            maximum_integrity_protected_data_rate_ul,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.integrity_protection_indication.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .confidentiality_protection_indication
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .maximum_integrity_protected_data_rate_ul
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct SecurityKey(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for SecurityKey {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(256, 16383);
        let total_bitlen = source.get_bounded_len(256..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(SecurityKey(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 256);
        let capped_max = std::cmp::min(256, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(256..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityResult {
    pub integrity_protection_result: IntegrityProtectionResult,
    pub confidentiality_protection_result: ConfidentialityProtectionResult,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityResultIE_Extensions>,
}
impl entropic::Entropic for SecurityResult {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let integrity_protection_result: IntegrityProtectionResult = source.get_entropic()?;
        let confidentiality_protection_result: ConfidentialityProtectionResult =
            source.get_entropic()?;
        let ie_extensions: Option<SecurityResultIE_Extensions> = None;
        Ok(Self {
            integrity_protection_result,
            confidentiality_protection_result,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.integrity_protection_result.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .confidentiality_protection_result
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SensorMeasConfig(pub u8);
impl SensorMeasConfig {
    pub const SETUP: u8 = 0u8;
}
impl entropic::Entropic for SensorMeasConfig {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SensorMeasConfig(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SensorMeasConfigNameItem {
    pub sensor_name_config: SensorNameConfig,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SensorMeasConfigNameItemIE_Extensions>,
}
impl entropic::Entropic for SensorMeasConfigNameItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let sensor_name_config: SensorNameConfig = source.get_entropic()?;
        let ie_extensions: Option<SensorMeasConfigNameItemIE_Extensions> = None;
        Ok(Self {
            sensor_name_config,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.sensor_name_config.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct SensorMeasConfigNameList(pub Vec<SensorMeasConfigNameItem>);
impl entropic::Entropic for SensorMeasConfigNameList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SensorMeasConfigNameItem::from_entropy_source(source)?);
        }
        Ok(SensorMeasConfigNameList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(3, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SensorMeasurementConfiguration {
    pub sensor_meas_config: SensorMeasConfig,
    #[asn(optional_idx = 0)]
    pub sensor_meas_config_name_list: Option<SensorMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SensorMeasurementConfigurationIE_Extensions>,
}
impl entropic::Entropic for SensorMeasurementConfiguration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let sensor_meas_config: SensorMeasConfig = source.get_entropic()?;
        let sensor_meas_config_name_list: Option<SensorMeasConfigNameList> =
            source.get_entropic()?;
        let ie_extensions: Option<SensorMeasurementConfigurationIE_Extensions> = None;
        Ok(Self {
            sensor_meas_config,
            sensor_meas_config_name_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.sensor_meas_config.to_entropy_sink(sink)?;
        __entropic_internal_length += self.sensor_meas_config_name_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SensorNameConfig {
    #[asn(key = 0, extended = false)]
    UncompensatedBarometricConfig(SensorNameConfig_uncompensatedBarometricConfig),
    #[asn(key = 1, extended = false)]
    UeSpeedConfig(SensorNameConfig_ueSpeedConfig),
    #[asn(key = 2, extended = false)]
    UeOrientationConfig(SensorNameConfig_ueOrientationConfig),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(SensorNameConfig_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for SensorNameConfig {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SensorNameConfig::UncompensatedBarometricConfig(_) => 0u128.try_into().unwrap(),
            SensorNameConfig::UeSpeedConfig(_) => 1u128.try_into().unwrap(),
            SensorNameConfig::UeOrientationConfig(_) => 2u128.try_into().unwrap(),
            SensorNameConfig::Choice_Extensions(_) => 3u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SerialNumber(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for SerialNumber {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(SerialNumber(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedGUAMIItem {
    pub guami: GUAMI,
    #[asn(optional_idx = 0)]
    pub backup_amf_name: Option<AMFName>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedGUAMIItemIE_Extensions>,
}
impl entropic::Entropic for ServedGUAMIItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let guami: GUAMI = source.get_entropic()?;
        let backup_amf_name: Option<AMFName> = source.get_entropic()?;
        let ie_extensions: Option<ServedGUAMIItemIE_Extensions> = None;
        Ok(Self {
            guami,
            backup_amf_name,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.guami.to_entropy_sink(sink)?;
        __entropic_internal_length += self.backup_amf_name.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedGUAMIList(pub Vec<ServedGUAMIItem>);
impl entropic::Entropic for ServedGUAMIList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServedGUAMIItem::from_entropy_source(source)?);
        }
        Ok(ServedGUAMIList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ServiceAreaInformation(pub Vec<ServiceAreaInformation_Item>);
impl entropic::Entropic for ServiceAreaInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServiceAreaInformation_Item::from_entropy_source(source)?);
        }
        Ok(ServiceAreaInformation(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ServiceAreaInformation_Item {
    pub plmn_identity: PLMNIdentity,
    #[asn(optional_idx = 0)]
    pub allowed_ta_cs: Option<AllowedTACs>,
    #[asn(optional_idx = 1)]
    pub not_allowed_ta_cs: Option<NotAllowedTACs>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ServiceAreaInformation_ItemIE_Extensions>,
}
impl entropic::Entropic for ServiceAreaInformation_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let allowed_ta_cs: Option<AllowedTACs> = source.get_entropic()?;
        let not_allowed_ta_cs: Option<NotAllowedTACs> = source.get_entropic()?;
        let ie_extensions: Option<ServiceAreaInformation_ItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            allowed_ta_cs,
            not_allowed_ta_cs,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.allowed_ta_cs.to_entropy_sink(sink)?;
        __entropic_internal_length += self.not_allowed_ta_cs.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct SgNB_UE_X2AP_ID(pub u32);
impl entropic::Entropic for SgNB_UE_X2AP_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SgNB_UE_X2AP_ID(source.get_uniform_range(0..=4294967295)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4294967295 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SliceOverloadItem {
    pub s_nssai: S_NSSAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SliceOverloadItemIE_Extensions>,
}
impl entropic::Entropic for SliceOverloadItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let s_nssai: S_NSSAI = source.get_entropic()?;
        let ie_extensions: Option<SliceOverloadItemIE_Extensions> = None;
        Ok(Self {
            s_nssai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.s_nssai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct SliceOverloadList(pub Vec<SliceOverloadItem>);
impl entropic::Entropic for SliceOverloadList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1024, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SliceOverloadItem::from_entropy_source(source)?);
        }
        Ok(SliceOverloadList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(1024, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SliceSupportItem {
    pub s_nssai: S_NSSAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SliceSupportItemIE_Extensions>,
}
impl entropic::Entropic for SliceSupportItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let s_nssai: S_NSSAI = source.get_entropic()?;
        let ie_extensions: Option<SliceSupportItemIE_Extensions> = None;
        Ok(Self {
            s_nssai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.s_nssai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct SliceSupportList(pub Vec<SliceSupportItem>);
impl entropic::Entropic for SliceSupportList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1024, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SliceSupportItem::from_entropy_source(source)?);
        }
        Ok(SliceSupportList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(1024, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SourceNGRANNode_ToTargetNGRANNode_TransparentContainer {
    pub rrc_container: RRCContainer,
    #[asn(optional_idx = 0)]
    pub pdu_session_resource_information_list: Option<PDUSessionResourceInformationList>,
    #[asn(optional_idx = 1)]
    pub e_rab_information_list: Option<E_RABInformationList>,
    pub target_cell_id: NGRAN_CGI,
    #[asn(optional_idx = 2)]
    pub index_to_rfsp: Option<IndexToRFSP>,
    pub ue_history_information: UEHistoryInformation,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for SourceNGRANNode_ToTargetNGRANNode_TransparentContainer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let rrc_container: RRCContainer = source.get_entropic()?;
        let pdu_session_resource_information_list: Option<PDUSessionResourceInformationList> =
            source.get_entropic()?;
        let e_rab_information_list: Option<E_RABInformationList> = source.get_entropic()?;
        let target_cell_id: NGRAN_CGI = source.get_entropic()?;
        let index_to_rfsp: Option<IndexToRFSP> = source.get_entropic()?;
        let ue_history_information: UEHistoryInformation = source.get_entropic()?;
        let ie_extensions: Option<
            SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions,
        > = None;
        Ok(Self {
            rrc_container,
            pdu_session_resource_information_list,
            e_rab_information_list,
            target_cell_id,
            index_to_rfsp,
            ue_history_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.rrc_container.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .pdu_session_resource_information_list
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.e_rab_information_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.target_cell_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.index_to_rfsp.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ue_history_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SourceOfUEActivityBehaviourInformation(pub u8);
impl SourceOfUEActivityBehaviourInformation {
    pub const SUBSCRIPTION_INFORMATION: u8 = 0u8;
    pub const STATISTICS: u8 = 1u8;
}
impl entropic::Entropic for SourceOfUEActivityBehaviourInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SourceOfUEActivityBehaviourInformation(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SourceRANNodeID {
    pub global_ran_node_id: GlobalRANNodeID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SourceRANNodeIDIE_Extensions>,
}
impl entropic::Entropic for SourceRANNodeID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let global_ran_node_id: GlobalRANNodeID = source.get_entropic()?;
        let selected_tai: TAI = source.get_entropic()?;
        let ie_extensions: Option<SourceRANNodeIDIE_Extensions> = None;
        Ok(Self {
            global_ran_node_id,
            selected_tai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.global_ran_node_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.selected_tai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SourceToTarget_AMFInformationReroute {
    #[asn(optional_idx = 0)]
    pub configured_nssai: Option<ConfiguredNSSAI>,
    #[asn(optional_idx = 1)]
    pub rejected_nssa_iin_plmn: Option<RejectedNSSAIinPLMN>,
    #[asn(optional_idx = 2)]
    pub rejected_nssa_iin_ta: Option<RejectedNSSAIinTA>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<SourceToTarget_AMFInformationRerouteIE_Extensions>,
}
impl entropic::Entropic for SourceToTarget_AMFInformationReroute {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let configured_nssai: Option<ConfiguredNSSAI> = source.get_entropic()?;
        let rejected_nssa_iin_plmn: Option<RejectedNSSAIinPLMN> = source.get_entropic()?;
        let rejected_nssa_iin_ta: Option<RejectedNSSAIinTA> = source.get_entropic()?;
        let ie_extensions: Option<SourceToTarget_AMFInformationRerouteIE_Extensions> = None;
        Ok(Self {
            configured_nssai,
            rejected_nssa_iin_plmn,
            rejected_nssa_iin_ta,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.configured_nssai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rejected_nssa_iin_plmn.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rejected_nssa_iin_ta.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SourceToTarget_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: SuccessfulOutcomeValue,
}
impl entropic::Entropic for SuccessfulOutcome {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: SuccessfulOutcomeValue = source.get_entropic()?;
        let procedure_code: ProcedureCode = ProcedureCode(value.choice_key());
        Ok(Self {
            procedure_code,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SupportedTAItem {
    pub tac: TAC,
    pub broadcast_plmn_list: BroadcastPLMNList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SupportedTAItemIE_Extensions>,
}
impl entropic::Entropic for SupportedTAItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tac: TAC = source.get_entropic()?;
        let broadcast_plmn_list: BroadcastPLMNList = source.get_entropic()?;
        let ie_extensions: Option<SupportedTAItemIE_Extensions> = None;
        Ok(Self {
            tac,
            broadcast_plmn_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tac.to_entropy_sink(sink)?;
        __entropic_internal_length += self.broadcast_plmn_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedTAList(pub Vec<SupportedTAItem>);
impl entropic::Entropic for SupportedTAList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SupportedTAItem::from_entropy_source(source)?);
        }
        Ok(SupportedTAList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Suspend_Request_Indication(pub u8);
impl Suspend_Request_Indication {
    pub const SUSPEND_REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for Suspend_Request_Indication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Suspend_Request_Indication(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Suspend_Response_Indication(pub u8);
impl Suspend_Response_Indication {
    pub const SUSPEND_INDICATED: u8 = 0u8;
}
impl entropic::Entropic for Suspend_Response_Indication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Suspend_Response_Indication(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SuspendIndicator(pub u8);
impl SuspendIndicator {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for SuspendIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SuspendIndicator(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedMDT {
    pub ta_listfor_mdt: TAListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedMDTIE_Extensions>,
}
impl entropic::Entropic for TABasedMDT {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ta_listfor_mdt: TAListforMDT = source.get_entropic()?;
        let ie_extensions: Option<TABasedMDTIE_Extensions> = None;
        Ok(Self {
            ta_listfor_mdt,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ta_listfor_mdt.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct TAC(pub Vec<u8>);
impl entropic::Entropic for TAC {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(TAC(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI {
    pub plmn_identity: PLMNIdentity,
    pub tac: TAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIIE_Extensions>,
}
impl entropic::Entropic for TAI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let plmn_identity: PLMNIdentity = source.get_entropic()?;
        let tac: TAC = source.get_entropic()?;
        let ie_extensions: Option<TAIIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            tac,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.plmn_identity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tac.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedMDT {
    pub tai_listfor_mdt: TAIListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedMDTIE_Extensions>,
}
impl entropic::Entropic for TAIBasedMDT {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai_listfor_mdt: TAIListforMDT = source.get_entropic()?;
        let ie_extensions: Option<TAIBasedMDTIE_Extensions> = None;
        Ok(Self {
            tai_listfor_mdt,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai_listfor_mdt.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastEUTRA(pub Vec<TAIBroadcastEUTRA_Item>);
impl entropic::Entropic for TAIBroadcastEUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIBroadcastEUTRA_Item::from_entropy_source(source)?);
        }
        Ok(TAIBroadcastEUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBroadcastEUTRA_Item {
    pub tai: TAI,
    pub completed_cells_in_tai_eutra: CompletedCellsInTAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBroadcastEUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for TAIBroadcastEUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai: TAI = source.get_entropic()?;
        let completed_cells_in_tai_eutra: CompletedCellsInTAI_EUTRA = source.get_entropic()?;
        let ie_extensions: Option<TAIBroadcastEUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            tai,
            completed_cells_in_tai_eutra,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.completed_cells_in_tai_eutra.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastNR(pub Vec<TAIBroadcastNR_Item>);
impl entropic::Entropic for TAIBroadcastNR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIBroadcastNR_Item::from_entropy_source(source)?);
        }
        Ok(TAIBroadcastNR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBroadcastNR_Item {
    pub tai: TAI,
    pub completed_cells_in_tai_nr: CompletedCellsInTAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBroadcastNR_ItemIE_Extensions>,
}
impl entropic::Entropic for TAIBroadcastNR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai: TAI = source.get_entropic()?;
        let completed_cells_in_tai_nr: CompletedCellsInTAI_NR = source.get_entropic()?;
        let ie_extensions: Option<TAIBroadcastNR_ItemIE_Extensions> = None;
        Ok(Self {
            tai,
            completed_cells_in_tai_nr,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.completed_cells_in_tai_nr.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledEUTRA(pub Vec<TAICancelledEUTRA_Item>);
impl entropic::Entropic for TAICancelledEUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAICancelledEUTRA_Item::from_entropy_source(source)?);
        }
        Ok(TAICancelledEUTRA(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAICancelledEUTRA_Item {
    pub tai: TAI,
    pub cancelled_cells_in_tai_eutra: CancelledCellsInTAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAICancelledEUTRA_ItemIE_Extensions>,
}
impl entropic::Entropic for TAICancelledEUTRA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai: TAI = source.get_entropic()?;
        let cancelled_cells_in_tai_eutra: CancelledCellsInTAI_EUTRA = source.get_entropic()?;
        let ie_extensions: Option<TAICancelledEUTRA_ItemIE_Extensions> = None;
        Ok(Self {
            tai,
            cancelled_cells_in_tai_eutra,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cancelled_cells_in_tai_eutra.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledNR(pub Vec<TAICancelledNR_Item>);
impl entropic::Entropic for TAICancelledNR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAICancelledNR_Item::from_entropy_source(source)?);
        }
        Ok(TAICancelledNR(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAICancelledNR_Item {
    pub tai: TAI,
    pub cancelled_cells_in_tai_nr: CancelledCellsInTAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAICancelledNR_ItemIE_Extensions>,
}
impl entropic::Entropic for TAICancelledNR_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai: TAI = source.get_entropic()?;
        let cancelled_cells_in_tai_nr: CancelledCellsInTAI_NR = source.get_entropic()?;
        let ie_extensions: Option<TAICancelledNR_ItemIE_Extensions> = None;
        Ok(Self {
            tai,
            cancelled_cells_in_tai_nr,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cancelled_cells_in_tai_nr.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct TAIListForInactive(pub Vec<TAIListForInactiveItem>);
impl entropic::Entropic for TAIListForInactive {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIListForInactiveItem::from_entropy_source(source)?);
        }
        Ok(TAIListForInactive(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIListForInactiveItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIListForInactiveItemIE_Extensions>,
}
impl entropic::Entropic for TAIListForInactiveItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai: TAI = source.get_entropic()?;
        let ie_extensions: Option<TAIListForInactiveItemIE_Extensions> = None;
        Ok(Self { tai, ie_extensions })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct TAIListForPaging(pub Vec<TAIListForPagingItem>);
impl entropic::Entropic for TAIListForPaging {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIListForPagingItem::from_entropy_source(source)?);
        }
        Ok(TAIListForPaging(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIListForPagingItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIListForPagingItemIE_Extensions>,
}
impl entropic::Entropic for TAIListForPagingItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tai: TAI = source.get_entropic()?;
        let ie_extensions: Option<TAIListForPagingItemIE_Extensions> = None;
        Ok(Self { tai, ie_extensions })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct TAIListForRestart(pub Vec<TAI>);
impl entropic::Entropic for TAIListForRestart {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2048, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI::from_entropy_source(source)?);
        }
        Ok(TAIListForRestart(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2048, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListForWarning(pub Vec<TAI>);
impl entropic::Entropic for TAIListForWarning {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI::from_entropy_source(source)?);
        }
        Ok(TAIListForWarning(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforMDT(pub Vec<TAI>);
impl entropic::Entropic for TAIListforMDT {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(8, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI::from_entropy_source(source)?);
        }
        Ok(TAIListforMDT(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforMDT(pub Vec<TAC>);
impl entropic::Entropic for TAListforMDT {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(8, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAC::from_entropy_source(source)?);
        }
        Ok(TAListforMDT(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TNAP_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TNGF_ID {
    #[asn(key = 0, extended = false)]
    TNGF_ID(TNGF_ID_tNGF_ID),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(TNGF_ID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for TNGF_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            TNGF_ID::TNGF_ID(_) => 0u128.try_into().unwrap(),
            TNGF_ID::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct TNLAddressWeightFactor(pub u8);
impl entropic::Entropic for TNLAddressWeightFactor {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TNLAddressWeightFactor(source.get_uniform_range(0..=255)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TNLAssociationItem {
    pub tnl_association_address: CPTransportLayerInformation,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TNLAssociationItemIE_Extensions>,
}
impl entropic::Entropic for TNLAssociationItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tnl_association_address: CPTransportLayerInformation = source.get_entropic()?;
        let cause: Cause = source.get_entropic()?;
        let ie_extensions: Option<TNLAssociationItemIE_Extensions> = None;
        Ok(Self {
            tnl_association_address,
            cause,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tnl_association_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.cause.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct TNLAssociationList(pub Vec<TNLAssociationItem>);
impl entropic::Entropic for TNLAssociationList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(32, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TNLAssociationItem::from_entropy_source(source)?);
        }
        Ok(TNLAssociationList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct TNLAssociationUsage(pub u8);
impl TNLAssociationUsage {
    pub const UE: u8 = 0u8;
    pub const NON_UE: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}
impl entropic::Entropic for TNLAssociationUsage {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TNLAssociationUsage(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TSCAssistanceInformation {
    pub periodicity: Periodicity,
    #[asn(optional_idx = 0)]
    pub burst_arrival_time: Option<BurstArrivalTime>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TSCAssistanceInformationIE_Extensions>,
}
impl entropic::Entropic for TSCAssistanceInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let periodicity: Periodicity = source.get_entropic()?;
        let burst_arrival_time: Option<BurstArrivalTime> = source.get_entropic()?;
        let ie_extensions: Option<TSCAssistanceInformationIE_Extensions> = None;
        Ok(Self {
            periodicity,
            burst_arrival_time,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.periodicity.to_entropy_sink(sink)?;
        __entropic_internal_length += self.burst_arrival_time.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct TSCTrafficCharacteristics {
    #[asn(optional_idx = 0)]
    pub tsc_assistance_information_dl: Option<TSCAssistanceInformation>,
    #[asn(optional_idx = 1)]
    pub tsc_assistance_information_ul: Option<TSCAssistanceInformation>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<TSCTrafficCharacteristicsIE_Extensions>,
}
impl entropic::Entropic for TSCTrafficCharacteristics {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tsc_assistance_information_dl: Option<TSCAssistanceInformation> =
            source.get_entropic()?;
        let tsc_assistance_information_ul: Option<TSCAssistanceInformation> =
            source.get_entropic()?;
        let ie_extensions: Option<TSCTrafficCharacteristicsIE_Extensions> = None;
        Ok(Self {
            tsc_assistance_information_dl,
            tsc_assistance_information_ul,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tsc_assistance_information_dl.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tsc_assistance_information_ul.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TWAP_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TWIF_ID {
    #[asn(key = 0, extended = false)]
    TWIF_ID(TWIF_ID_tWIF_ID),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(TWIF_ID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for TWIF_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            TWIF_ID::TWIF_ID(_) => 0u128.try_into().unwrap(),
            TWIF_ID::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum TargetID {
    #[asn(key = 0, extended = false)]
    TargetRANNodeID(TargetRANNodeID),
    #[asn(key = 1, extended = false)]
    TargeteNB_ID(TargeteNB_ID),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(TargetID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for TargetID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            TargetID::TargetRANNodeID(_) => 0u128.try_into().unwrap(),
            TargetID::TargeteNB_ID(_) => 1u128.try_into().unwrap(),
            TargetID::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainer {
    pub cell_cag_information: Cell_CAGInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions:
        Option<TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions>,
}
impl entropic::Entropic for TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let cell_cag_information: Cell_CAGInformation = source.get_entropic()?;
        let ie_extensions: Option<
            TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions,
        > = None;
        Ok(Self {
            cell_cag_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_cag_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetNGRANNode_ToSourceNGRANNode_TransparentContainer {
    pub rrc_container: RRCContainer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for TargetNGRANNode_ToSourceNGRANNode_TransparentContainer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let rrc_container: RRCContainer = source.get_entropic()?;
        let ie_extensions: Option<
            TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions,
        > = None;
        Ok(Self {
            rrc_container,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.rrc_container.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetRANNodeID {
    pub global_ran_node_id: GlobalRANNodeID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargetRANNodeIDIE_Extensions>,
}
impl entropic::Entropic for TargetRANNodeID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let global_ran_node_id: GlobalRANNodeID = source.get_entropic()?;
        let selected_tai: TAI = source.get_entropic()?;
        let ie_extensions: Option<TargetRANNodeIDIE_Extensions> = None;
        Ok(Self {
            global_ran_node_id,
            selected_tai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.global_ran_node_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.selected_tai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TargetRNC_ID {
    pub lai: LAI,
    pub rnc_id: RNC_ID,
    #[asn(optional_idx = 0)]
    pub extended_rnc_id: Option<ExtendedRNC_ID>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TargetRNC_IDIE_Extensions>,
}
impl entropic::Entropic for TargetRNC_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let lai: LAI = source.get_entropic()?;
        let rnc_id: RNC_ID = source.get_entropic()?;
        let extended_rnc_id: Option<ExtendedRNC_ID> = source.get_entropic()?;
        let ie_extensions: Option<TargetRNC_IDIE_Extensions> = None;
        Ok(Self {
            lai,
            rnc_id,
            extended_rnc_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.lai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.rnc_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extended_rnc_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargetToSource_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargeteNB_ID {
    pub global_enb_id: GlobalNgENB_ID,
    pub selected_eps_tai: EPS_TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargeteNB_IDIE_Extensions>,
}
impl entropic::Entropic for TargeteNB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let global_enb_id: GlobalNgENB_ID = source.get_entropic()?;
        let selected_eps_tai: EPS_TAI = source.get_entropic()?;
        let ie_extensions: Option<TargeteNB_IDIE_Extensions> = None;
        Ok(Self {
            global_enb_id,
            selected_eps_tai,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.global_enb_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.selected_eps_tai.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargettoSource_Failure_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct Threshold_RSRP(pub u8);
impl entropic::Entropic for Threshold_RSRP {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Threshold_RSRP(source.get_uniform_range(0..=127)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=127 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct Threshold_RSRQ(pub u8);
impl entropic::Entropic for Threshold_RSRQ {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Threshold_RSRQ(source.get_uniform_range(0..=127)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=127 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct Threshold_SINR(pub u8);
impl entropic::Entropic for Threshold_SINR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Threshold_SINR(source.get_uniform_range(0..=127)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=127 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct TimeStamp(pub Vec<u8>);
impl entropic::Entropic for TimeStamp {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(TimeStamp(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct TimeToTrigger(pub u8);
impl TimeToTrigger {
    pub const MS0: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS64: u8 = 2u8;
    pub const MS80: u8 = 3u8;
    pub const MS100: u8 = 4u8;
    pub const MS128: u8 = 5u8;
    pub const MS160: u8 = 6u8;
    pub const MS256: u8 = 7u8;
    pub const MS320: u8 = 8u8;
    pub const MS480: u8 = 9u8;
    pub const MS512: u8 = 10u8;
    pub const MS640: u8 = 11u8;
    pub const MS1024: u8 = 12u8;
    pub const MS1280: u8 = 13u8;
    pub const MS2560: u8 = 14u8;
    pub const MS5120: u8 = 15u8;
}
impl entropic::Entropic for TimeToTrigger {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TimeToTrigger(source.get_uniform_range(0..=15)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TimeToWait(pub u8);
impl TimeToWait {
    pub const V1S: u8 = 0u8;
    pub const V2S: u8 = 1u8;
    pub const V5S: u8 = 2u8;
    pub const V10S: u8 = 3u8;
    pub const V20S: u8 = 4u8;
    pub const V60S: u8 = 5u8;
}
impl entropic::Entropic for TimeToWait {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TimeToWait(source.get_uniform_range(0..=5)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct TimeUEStayedInCell(pub u16);
impl entropic::Entropic for TimeUEStayedInCell {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TimeUEStayedInCell(source.get_uniform_range(0..=4095)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "40950")]
pub struct TimeUEStayedInCellEnhancedGranularity(pub u16);
impl entropic::Entropic for TimeUEStayedInCellEnhancedGranularity {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TimeUEStayedInCellEnhancedGranularity(
            source.get_uniform_range(0..=40950)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=40950 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct TimerApproachForGUAMIRemoval(pub u8);
impl TimerApproachForGUAMIRemoval {
    pub const APPLY_TIMER: u8 = 0u8;
}
impl entropic::Entropic for TimerApproachForGUAMIRemoval {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TimerApproachForGUAMIRemoval(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TooearlyIntersystemHO {
    pub sourcecell_id: EUTRA_CGI,
    pub failurecell_id: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub uerlf_report_container: Option<UERLFReportContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TooearlyIntersystemHOIE_Extensions>,
}
impl entropic::Entropic for TooearlyIntersystemHO {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let sourcecell_id: EUTRA_CGI = source.get_entropic()?;
        let failurecell_id: NGRAN_CGI = source.get_entropic()?;
        let uerlf_report_container: Option<UERLFReportContainer> = source.get_entropic()?;
        let ie_extensions: Option<TooearlyIntersystemHOIE_Extensions> = None;
        Ok(Self {
            sourcecell_id,
            failurecell_id,
            uerlf_report_container,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.sourcecell_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.failurecell_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.uerlf_report_container.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TraceActivation {
    pub ngran_trace_id: NGRANTraceID,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TraceActivationIE_Extensions>,
}
impl entropic::Entropic for TraceActivation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ngran_trace_id: NGRANTraceID = source.get_entropic()?;
        let interfaces_to_trace: InterfacesToTrace = source.get_entropic()?;
        let trace_depth: TraceDepth = source.get_entropic()?;
        let trace_collection_entity_ip_address: TransportLayerAddress = source.get_entropic()?;
        let ie_extensions: Option<TraceActivationIE_Extensions> = None;
        Ok(Self {
            ngran_trace_id,
            interfaces_to_trace,
            trace_depth,
            trace_collection_entity_ip_address,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ngran_trace_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.interfaces_to_trace.to_entropy_sink(sink)?;
        __entropic_internal_length += self.trace_depth.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .trace_collection_entity_ip_address
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TraceDepth(pub u8);
impl TraceDepth {
    pub const MINIMUM: u8 = 0u8;
    pub const MEDIUM: u8 = 1u8;
    pub const MAXIMUM: u8 = 2u8;
    pub const MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 3u8;
    pub const MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 4u8;
    pub const MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 5u8;
}
impl entropic::Entropic for TraceDepth {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TraceDepth(source.get_uniform_range(0..=5)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceFailureIndication {
    pub protocol_i_es: TraceFailureIndicationProtocolIEs,
}
impl entropic::Entropic for TraceFailureIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: TraceFailureIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceStart {
    pub protocol_i_es: TraceStartProtocolIEs,
}
impl entropic::Entropic for TraceStart {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: TraceStartProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "99")]
pub struct TrafficLoadReductionIndication(pub u8);
impl entropic::Entropic for TrafficLoadReductionIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TrafficLoadReductionIndication(
            source.get_uniform_range(1..=99)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=99 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "160")]
pub struct TransportLayerAddress(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for TransportLayerAddress {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(160, 16383);
        let total_bitlen = source.get_bounded_len(1..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(TransportLayerAddress(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 1);
        let capped_max = std::cmp::min(160, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct TriggeringMessage(pub u8);
impl TriggeringMessage {
    pub const INITIATING_MESSAGE: u8 = 0u8;
    pub const SUCCESSFUL_OUTCOME: u8 = 1u8;
    pub const UNSUCCESSFULL_OUTCOME: u8 = 2u8;
}
impl entropic::Entropic for TriggeringMessage {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TriggeringMessage(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct TypeOfError(pub u8);
impl TypeOfError {
    pub const NOT_UNDERSTOOD: u8 = 0u8;
    pub const MISSING: u8 = 1u8;
}
impl entropic::Entropic for TypeOfError {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(TypeOfError(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct UE_DifferentiationInfo {
    #[asn(optional_idx = 0)]
    pub periodic_communication_indicator:
        Option<UE_DifferentiationInfoPeriodicCommunicationIndicator>,
    #[asn(optional_idx = 1)]
    pub periodic_time: Option<UE_DifferentiationInfoPeriodicTime>,
    #[asn(optional_idx = 2)]
    pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
    #[asn(optional_idx = 3)]
    pub stationary_indication: Option<UE_DifferentiationInfoStationaryIndication>,
    #[asn(optional_idx = 4)]
    pub traffic_profile: Option<UE_DifferentiationInfoTrafficProfile>,
    #[asn(optional_idx = 5)]
    pub battery_indication: Option<UE_DifferentiationInfoBatteryIndication>,
    #[asn(optional_idx = 6)]
    pub ie_extensions: Option<UE_DifferentiationInfoIE_Extensions>,
}
impl entropic::Entropic for UE_DifferentiationInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let periodic_communication_indicator: Option<
            UE_DifferentiationInfoPeriodicCommunicationIndicator,
        > = source.get_entropic()?;
        let periodic_time: Option<UE_DifferentiationInfoPeriodicTime> = source.get_entropic()?;
        let scheduled_communication_time: Option<ScheduledCommunicationTime> =
            source.get_entropic()?;
        let stationary_indication: Option<UE_DifferentiationInfoStationaryIndication> =
            source.get_entropic()?;
        let traffic_profile: Option<UE_DifferentiationInfoTrafficProfile> =
            source.get_entropic()?;
        let battery_indication: Option<UE_DifferentiationInfoBatteryIndication> =
            source.get_entropic()?;
        let ie_extensions: Option<UE_DifferentiationInfoIE_Extensions> = None;
        Ok(Self {
            periodic_communication_indicator,
            periodic_time,
            scheduled_communication_time,
            stationary_indication,
            traffic_profile,
            battery_indication,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .periodic_communication_indicator
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.periodic_time.to_entropy_sink(sink)?;
        __entropic_internal_length += self.scheduled_communication_time.to_entropy_sink(sink)?;
        __entropic_internal_length += self.stationary_indication.to_entropy_sink(sink)?;
        __entropic_internal_length += self.traffic_profile.to_entropy_sink(sink)?;
        __entropic_internal_length += self.battery_indication.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_NGAP_ID_pair {
    pub amf_ue_ngap_id: AMF_UE_NGAP_ID,
    pub ran_ue_ngap_id: RAN_UE_NGAP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UE_NGAP_ID_pairIE_Extensions>,
}
impl entropic::Entropic for UE_NGAP_ID_pair {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_ue_ngap_id: AMF_UE_NGAP_ID = source.get_entropic()?;
        let ran_ue_ngap_id: RAN_UE_NGAP_ID = source.get_entropic()?;
        let ie_extensions: Option<UE_NGAP_ID_pairIE_Extensions> = None;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_ue_ngap_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ran_ue_ngap_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum UE_NGAP_IDs {
    #[asn(key = 0, extended = false)]
    UE_NGAP_ID_pair(UE_NGAP_ID_pair),
    #[asn(key = 1, extended = false)]
    AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(UE_NGAP_IDs_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UE_NGAP_IDs {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UE_NGAP_IDs::UE_NGAP_ID_pair(_) => 0u128.try_into().unwrap(),
            UE_NGAP_IDs::AMF_UE_NGAP_ID(_) => 1u128.try_into().unwrap(),
            UE_NGAP_IDs::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UE_UP_CIoT_Support(pub u8);
impl UE_UP_CIoT_Support {
    pub const SUPPORTED: u8 = 0u8;
}
impl entropic::Entropic for UE_UP_CIoT_Support {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UE_UP_CIoT_Support(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UE_associatedLogicalNG_connectionItem {
    #[asn(optional_idx = 0)]
    pub amf_ue_ngap_id: Option<AMF_UE_NGAP_ID>,
    #[asn(optional_idx = 1)]
    pub ran_ue_ngap_id: Option<RAN_UE_NGAP_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UE_associatedLogicalNG_connectionItemIE_Extensions>,
}
impl entropic::Entropic for UE_associatedLogicalNG_connectionItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let amf_ue_ngap_id: Option<AMF_UE_NGAP_ID> = source.get_entropic()?;
        let ran_ue_ngap_id: Option<RAN_UE_NGAP_ID> = source.get_entropic()?;
        let ie_extensions: Option<UE_associatedLogicalNG_connectionItemIE_Extensions> = None;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.amf_ue_ngap_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ran_ue_ngap_id.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65536"
)]
pub struct UE_associatedLogicalNG_connectionList(pub Vec<UE_associatedLogicalNG_connectionItem>);
impl entropic::Entropic for UE_associatedLogicalNG_connectionList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65536, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UE_associatedLogicalNG_connectionItem::from_entropy_source(
                source,
            )?);
        }
        Ok(UE_associatedLogicalNG_connectionList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65536, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAggregateMaximumBitRate {
    pub ue_aggregate_maximum_bit_rate_dl: BitRate,
    pub ue_aggregate_maximum_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAggregateMaximumBitRateIE_Extensions>,
}
impl entropic::Entropic for UEAggregateMaximumBitRate {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ue_aggregate_maximum_bit_rate_dl: BitRate = source.get_entropic()?;
        let ue_aggregate_maximum_bit_rate_ul: BitRate = source.get_entropic()?;
        let ie_extensions: Option<UEAggregateMaximumBitRateIE_Extensions> = None;
        Ok(Self {
            ue_aggregate_maximum_bit_rate_dl,
            ue_aggregate_maximum_bit_rate_ul,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ue_aggregate_maximum_bit_rate_dl
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .ue_aggregate_maximum_bit_rate_ul
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UECapabilityInfoRequest(pub u8);
impl UECapabilityInfoRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for UECapabilityInfoRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UECapabilityInfoRequest(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationFailure {
    pub protocol_i_es: UEContextModificationFailureProtocolIEs,
}
impl entropic::Entropic for UEContextModificationFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextModificationFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationRequest {
    pub protocol_i_es: UEContextModificationRequestProtocolIEs,
}
impl entropic::Entropic for UEContextModificationRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextModificationRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationResponse {
    pub protocol_i_es: UEContextModificationResponseProtocolIEs,
}
impl entropic::Entropic for UEContextModificationResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextModificationResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseCommand {
    pub protocol_i_es: UEContextReleaseCommandProtocolIEs,
}
impl entropic::Entropic for UEContextReleaseCommand {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextReleaseCommandProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseComplete {
    pub protocol_i_es: UEContextReleaseCompleteProtocolIEs,
}
impl entropic::Entropic for UEContextReleaseComplete {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextReleaseCompleteProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseRequest {
    pub protocol_i_es: UEContextReleaseRequestProtocolIEs,
}
impl entropic::Entropic for UEContextReleaseRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextReleaseRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UEContextRequest(pub u8);
impl UEContextRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for UEContextRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UEContextRequest(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeFailure {
    pub protocol_i_es: UEContextResumeFailureProtocolIEs,
}
impl entropic::Entropic for UEContextResumeFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextResumeFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeRequest {
    pub protocol_i_es: UEContextResumeRequestProtocolIEs,
}
impl entropic::Entropic for UEContextResumeRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextResumeRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UEContextResumeRequestTransfer {
    #[asn(optional_idx = 0)]
    pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UEContextResumeRequestTransferIE_Extensions>,
}
impl entropic::Entropic for UEContextResumeRequestTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_failed_to_resume_list: Option<QosFlowListWithCause> = source.get_entropic()?;
        let ie_extensions: Option<UEContextResumeRequestTransferIE_Extensions> = None;
        Ok(Self {
            qos_flow_failed_to_resume_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_failed_to_resume_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeResponse {
    pub protocol_i_es: UEContextResumeResponseProtocolIEs,
}
impl entropic::Entropic for UEContextResumeResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextResumeResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UEContextResumeResponseTransfer {
    #[asn(optional_idx = 0)]
    pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UEContextResumeResponseTransferIE_Extensions>,
}
impl entropic::Entropic for UEContextResumeResponseTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let qos_flow_failed_to_resume_list: Option<QosFlowListWithCause> = source.get_entropic()?;
        let ie_extensions: Option<UEContextResumeResponseTransferIE_Extensions> = None;
        Ok(Self {
            qos_flow_failed_to_resume_list,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qos_flow_failed_to_resume_list.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendFailure {
    pub protocol_i_es: UEContextSuspendFailureProtocolIEs,
}
impl entropic::Entropic for UEContextSuspendFailure {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextSuspendFailureProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendRequest {
    pub protocol_i_es: UEContextSuspendRequestProtocolIEs,
}
impl entropic::Entropic for UEContextSuspendRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextSuspendRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UEContextSuspendRequestTransfer {
    #[asn(optional_idx = 0)]
    pub suspend_indicator: Option<SuspendIndicator>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UEContextSuspendRequestTransferIE_Extensions>,
}
impl entropic::Entropic for UEContextSuspendRequestTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let suspend_indicator: Option<SuspendIndicator> = source.get_entropic()?;
        let ie_extensions: Option<UEContextSuspendRequestTransferIE_Extensions> = None;
        Ok(Self {
            suspend_indicator,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.suspend_indicator.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendResponse {
    pub protocol_i_es: UEContextSuspendResponseProtocolIEs,
}
impl entropic::Entropic for UEContextSuspendResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEContextSuspendResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct UEHistoryInformation(pub Vec<LastVisitedCellItem>);
impl entropic::Entropic for UEHistoryInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LastVisitedCellItem::from_entropy_source(source)?);
        }
        Ok(UEHistoryInformation(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEHistoryInformationFromTheUE {
    #[asn(key = 0, extended = false)]
    NR(NRMobilityHistoryReport),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UEHistoryInformationFromTheUE_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UEHistoryInformationFromTheUE {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UEHistoryInformationFromTheUE::NR(_) => 0u128.try_into().unwrap(),
            UEHistoryInformationFromTheUE::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEIdentityIndexValue {
    #[asn(key = 0, extended = false)]
    IndexLength10(UEIdentityIndexValue_indexLength10),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UEIdentityIndexValue_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UEIdentityIndexValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UEIdentityIndexValue::IndexLength10(_) => 0u128.try_into().unwrap(),
            UEIdentityIndexValue::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEInformationTransfer {
    pub protocol_i_es: UEInformationTransferProtocolIEs,
}
impl entropic::Entropic for UEInformationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UEInformationTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEPagingIdentity {
    #[asn(key = 0, extended = false)]
    FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UEPagingIdentity_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UEPagingIdentity {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UEPagingIdentity::FiveG_S_TMSI(_) => 0u128.try_into().unwrap(),
            UEPagingIdentity::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct UEPresence(pub u8);
impl UEPresence {
    pub const IN: u8 = 0u8;
    pub const OUT: u8 = 1u8;
    pub const UNKNOWN: u8 = 2u8;
}
impl entropic::Entropic for UEPresence {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UEPresence(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEPresenceInAreaOfInterestItem {
    pub location_reporting_reference_id: LocationReportingReferenceID,
    pub ue_presence: UEPresence,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEPresenceInAreaOfInterestItemIE_Extensions>,
}
impl entropic::Entropic for UEPresenceInAreaOfInterestItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let location_reporting_reference_id: LocationReportingReferenceID =
            source.get_entropic()?;
        let ue_presence: UEPresence = source.get_entropic()?;
        let ie_extensions: Option<UEPresenceInAreaOfInterestItemIE_Extensions> = None;
        Ok(Self {
            location_reporting_reference_id,
            ue_presence,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.location_reporting_reference_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ue_presence.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct UEPresenceInAreaOfInterestList(pub Vec<UEPresenceInAreaOfInterestItem>);
impl entropic::Entropic for UEPresenceInAreaOfInterestList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(64, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEPresenceInAreaOfInterestItem::from_entropy_source(source)?);
        }
        Ok(UEPresenceInAreaOfInterestList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum UERLFReportContainer {
    #[asn(key = 0, extended = false)]
    NR(NRUERLFReportContainer),
    #[asn(key = 1, extended = false)]
    LTE(LTEUERLFReportContainer),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(UERLFReportContainer_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UERLFReportContainer {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UERLFReportContainer::NR(_) => 0u128.try_into().unwrap(),
            UERLFReportContainer::LTE(_) => 1u128.try_into().unwrap(),
            UERLFReportContainer::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapability(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityCheckRequest {
    pub protocol_i_es: UERadioCapabilityCheckRequestProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityCheckRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UERadioCapabilityCheckRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityCheckResponse {
    pub protocol_i_es: UERadioCapabilityCheckResponseProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityCheckResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UERadioCapabilityCheckResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UERadioCapabilityForPaging {
    #[asn(optional_idx = 0)]
    pub ue_radio_capability_for_paging_of_nr: Option<UERadioCapabilityForPagingOfNR>,
    #[asn(optional_idx = 1)]
    pub ue_radio_capability_for_paging_of_eutra: Option<UERadioCapabilityForPagingOfEUTRA>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UERadioCapabilityForPagingIE_Extensions>,
}
impl entropic::Entropic for UERadioCapabilityForPaging {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ue_radio_capability_for_paging_of_nr: Option<UERadioCapabilityForPagingOfNR> =
            source.get_entropic()?;
        let ue_radio_capability_for_paging_of_eutra: Option<UERadioCapabilityForPagingOfEUTRA> =
            source.get_entropic()?;
        let ie_extensions: Option<UERadioCapabilityForPagingIE_Extensions> = None;
        Ok(Self {
            ue_radio_capability_for_paging_of_nr,
            ue_radio_capability_for_paging_of_eutra,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ue_radio_capability_for_paging_of_nr
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .ue_radio_capability_for_paging_of_eutra
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPagingOfEUTRA(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPagingOfNB_IoT(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPagingOfNR(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingRequest {
    pub protocol_i_es: UERadioCapabilityIDMappingRequestProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityIDMappingRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UERadioCapabilityIDMappingRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingResponse {
    pub protocol_i_es: UERadioCapabilityIDMappingResponseProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityIDMappingResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UERadioCapabilityIDMappingResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityInfoIndication {
    pub protocol_i_es: UERadioCapabilityInfoIndicationProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityInfoIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UERadioCapabilityInfoIndicationProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UERetentionInformation(pub u8);
impl UERetentionInformation {
    pub const UES_RETAINED: u8 = 0u8;
}
impl entropic::Entropic for UERetentionInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UERetentionInformation(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESecurityCapabilities {
    pub n_rencryption_algorithms: NRencryptionAlgorithms,
    pub n_rintegrity_protection_algorithms: NRintegrityProtectionAlgorithms,
    pub eutr_aencryption_algorithms: EUTRAencryptionAlgorithms,
    pub eutr_aintegrity_protection_algorithms: EUTRAintegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESecurityCapabilitiesIE_Extensions>,
}
impl entropic::Entropic for UESecurityCapabilities {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let n_rencryption_algorithms: NRencryptionAlgorithms = source.get_entropic()?;
        let n_rintegrity_protection_algorithms: NRintegrityProtectionAlgorithms =
            source.get_entropic()?;
        let eutr_aencryption_algorithms: EUTRAencryptionAlgorithms = source.get_entropic()?;
        let eutr_aintegrity_protection_algorithms: EUTRAintegrityProtectionAlgorithms =
            source.get_entropic()?;
        let ie_extensions: Option<UESecurityCapabilitiesIE_Extensions> = None;
        Ok(Self {
            n_rencryption_algorithms,
            n_rintegrity_protection_algorithms,
            eutr_aencryption_algorithms,
            eutr_aintegrity_protection_algorithms,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.n_rencryption_algorithms.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .n_rintegrity_protection_algorithms
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.eutr_aencryption_algorithms.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .eutr_aintegrity_protection_algorithms
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UETNLABindingReleaseRequest {
    pub protocol_i_es: UETNLABindingReleaseRequestProtocolIEs,
}
impl entropic::Entropic for UETNLABindingReleaseRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UETNLABindingReleaseRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UL_CP_SecurityInformation {
    pub ul_nas_mac: UL_NAS_MAC,
    pub ul_nas_count: UL_NAS_Count,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UL_CP_SecurityInformationIE_Extensions>,
}
impl entropic::Entropic for UL_CP_SecurityInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ul_nas_mac: UL_NAS_MAC = source.get_entropic()?;
        let ul_nas_count: UL_NAS_Count = source.get_entropic()?;
        let ie_extensions: Option<UL_CP_SecurityInformationIE_Extensions> = None;
        Ok(Self {
            ul_nas_mac,
            ul_nas_count,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ul_nas_mac.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ul_nas_count.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct UL_NAS_Count(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for UL_NAS_Count {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(5, 16383);
        let total_bitlen = source.get_bounded_len(5..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(UL_NAS_Count(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 5);
        let capped_max = std::cmp::min(5, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(5..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct UL_NAS_MAC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for UL_NAS_MAC {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(UL_NAS_MAC(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UL_NGU_UP_TNLModifyItem {
    pub ul_ngu_up_tnl_information: UPTransportLayerInformation,
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UL_NGU_UP_TNLModifyItemIE_Extensions>,
}
impl entropic::Entropic for UL_NGU_UP_TNLModifyItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ul_ngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let dl_ngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let ie_extensions: Option<UL_NGU_UP_TNLModifyItemIE_Extensions> = None;
        Ok(Self {
            ul_ngu_up_tnl_information,
            dl_ngu_up_tnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ul_ngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.dl_ngu_up_tnl_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct UL_NGU_UP_TNLModifyList(pub Vec<UL_NGU_UP_TNLModifyItem>);
impl entropic::Entropic for UL_NGU_UP_TNLModifyList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UL_NGU_UP_TNLModifyItem::from_entropy_source(source)?);
        }
        Ok(UL_NGU_UP_TNLModifyList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ULForwarding(pub u8);
impl ULForwarding {
    pub const UL_FORWARDING_PROPOSED: u8 = 0u8;
}
impl entropic::Entropic for ULForwarding {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ULForwarding(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UPTransportLayerInformation {
    #[asn(key = 0, extended = false)]
    GTPTunnel(GTPTunnel),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UPTransportLayerInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UPTransportLayerInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UPTransportLayerInformation::GTPTunnel(_) => 0u128.try_into().unwrap(),
            UPTransportLayerInformation::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UPTransportLayerInformationItem {
    pub ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UPTransportLayerInformationItemIE_Extensions>,
}
impl entropic::Entropic for UPTransportLayerInformationItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let ie_extensions: Option<UPTransportLayerInformationItemIE_Extensions> = None;
        Ok(Self {
            ngu_up_tnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ngu_up_tnl_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct UPTransportLayerInformationList(pub Vec<UPTransportLayerInformationItem>);
impl entropic::Entropic for UPTransportLayerInformationList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UPTransportLayerInformationItem::from_entropy_source(
                source,
            )?);
        }
        Ok(UPTransportLayerInformationList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(3, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UPTransportLayerInformationPairItem {
    pub ul_ngu_up_tnl_information: UPTransportLayerInformation,
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UPTransportLayerInformationPairItemIE_Extensions>,
}
impl entropic::Entropic for UPTransportLayerInformationPairItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ul_ngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let dl_ngu_up_tnl_information: UPTransportLayerInformation = source.get_entropic()?;
        let ie_extensions: Option<UPTransportLayerInformationPairItemIE_Extensions> = None;
        Ok(Self {
            ul_ngu_up_tnl_information,
            dl_ngu_up_tnl_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ul_ngu_up_tnl_information.to_entropy_sink(sink)?;
        __entropic_internal_length += self.dl_ngu_up_tnl_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct UPTransportLayerInformationPairList(pub Vec<UPTransportLayerInformationPairItem>);
impl entropic::Entropic for UPTransportLayerInformationPairList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(3, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UPTransportLayerInformationPairItem::from_entropy_source(
                source,
            )?);
        }
        Ok(UPTransportLayerInformationPairList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(3, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "VisibleString")]
pub struct URI_address(pub String);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UnavailableGUAMIItem {
    pub guami: GUAMI,
    #[asn(optional_idx = 0)]
    pub timer_approach_for_guami_removal: Option<TimerApproachForGUAMIRemoval>,
    #[asn(optional_idx = 1)]
    pub backup_amf_name: Option<AMFName>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UnavailableGUAMIItemIE_Extensions>,
}
impl entropic::Entropic for UnavailableGUAMIItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let guami: GUAMI = source.get_entropic()?;
        let timer_approach_for_guami_removal: Option<TimerApproachForGUAMIRemoval> =
            source.get_entropic()?;
        let backup_amf_name: Option<AMFName> = source.get_entropic()?;
        let ie_extensions: Option<UnavailableGUAMIItemIE_Extensions> = None;
        Ok(Self {
            guami,
            timer_approach_for_guami_removal,
            backup_amf_name,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.guami.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .timer_approach_for_guami_removal
            .to_entropy_sink(sink)?;
        __entropic_internal_length += self.backup_amf_name.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct UnavailableGUAMIList(pub Vec<UnavailableGUAMIItem>);
impl entropic::Entropic for UnavailableGUAMIList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(256, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UnavailableGUAMIItem::from_entropy_source(source)?);
        }
        Ok(UnavailableGUAMIList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UnsuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: UnsuccessfulOutcomeValue,
}
impl entropic::Entropic for UnsuccessfulOutcome {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UnsuccessfulOutcomeValue = source.get_entropic()?;
        let procedure_code: ProcedureCode = ProcedureCode(value.choice_key());
        Ok(Self {
            procedure_code,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct UpdateFeedback(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for UpdateFeedback {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(UpdateFeedback(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNASTransport {
    pub protocol_i_es: UplinkNASTransportProtocolIEs,
}
impl entropic::Entropic for UplinkNASTransport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UplinkNASTransportProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNonUEAssociatedNRPPaTransport {
    pub protocol_i_es: UplinkNonUEAssociatedNRPPaTransportProtocolIEs,
}
impl entropic::Entropic for UplinkNonUEAssociatedNRPPaTransport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UplinkNonUEAssociatedNRPPaTransportProtocolIEs =
            source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRANConfigurationTransfer {
    pub protocol_i_es: UplinkRANConfigurationTransferProtocolIEs,
}
impl entropic::Entropic for UplinkRANConfigurationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UplinkRANConfigurationTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRANEarlyStatusTransfer {
    pub protocol_i_es: UplinkRANEarlyStatusTransferProtocolIEs,
}
impl entropic::Entropic for UplinkRANEarlyStatusTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UplinkRANEarlyStatusTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRANStatusTransfer {
    pub protocol_i_es: UplinkRANStatusTransferProtocolIEs,
}
impl entropic::Entropic for UplinkRANStatusTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UplinkRANStatusTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRIMInformationTransfer {
    pub protocol_i_es: UplinkRIMInformationTransferProtocolIEs,
}
impl entropic::Entropic for UplinkRIMInformationTransfer {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UplinkRIMInformationTransferProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkUEAssociatedNRPPaTransport {
    pub protocol_i_es: UplinkUEAssociatedNRPPaTransportProtocolIEs,
}
impl entropic::Entropic for UplinkUEAssociatedNRPPaTransport {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: UplinkUEAssociatedNRPPaTransportProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum UserLocationInformation {
    #[asn(key = 0, extended = false)]
    UserLocationInformationEUTRA(UserLocationInformationEUTRA),
    #[asn(key = 1, extended = false)]
    UserLocationInformationNR(UserLocationInformationNR),
    #[asn(key = 2, extended = false)]
    UserLocationInformationN3IWF(UserLocationInformationN3IWF),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(UserLocationInformation_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UserLocationInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UserLocationInformation::UserLocationInformationEUTRA(_) => 0u128.try_into().unwrap(),
            UserLocationInformation::UserLocationInformationNR(_) => 1u128.try_into().unwrap(),
            UserLocationInformation::UserLocationInformationN3IWF(_) => 2u128.try_into().unwrap(),
            UserLocationInformation::Choice_Extensions(_) => 3u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationEUTRA {
    pub eutra_cgi: EUTRA_CGI,
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub time_stamp: Option<TimeStamp>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationEUTRAIE_Extensions>,
}
impl entropic::Entropic for UserLocationInformationEUTRA {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let eutra_cgi: EUTRA_CGI = source.get_entropic()?;
        let tai: TAI = source.get_entropic()?;
        let time_stamp: Option<TimeStamp> = source.get_entropic()?;
        let ie_extensions: Option<UserLocationInformationEUTRAIE_Extensions> = None;
        Ok(Self {
            eutra_cgi,
            tai,
            time_stamp,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.eutra_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.time_stamp.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UserLocationInformationN3IWF {
    pub ip_address: TransportLayerAddress,
    pub port_number: PortNumber,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UserLocationInformationN3IWFIE_Extensions>,
}
impl entropic::Entropic for UserLocationInformationN3IWF {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let ip_address: TransportLayerAddress = source.get_entropic()?;
        let port_number: PortNumber = source.get_entropic()?;
        let ie_extensions: Option<UserLocationInformationN3IWFIE_Extensions> = None;
        Ok(Self {
            ip_address,
            port_number,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ip_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.port_number.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationNR {
    pub nr_cgi: NR_CGI,
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub time_stamp: Option<TimeStamp>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationNRIE_Extensions>,
}
impl entropic::Entropic for UserLocationInformationNR {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let nr_cgi: NR_CGI = source.get_entropic()?;
        let tai: TAI = source.get_entropic()?;
        let time_stamp: Option<TimeStamp> = source.get_entropic()?;
        let ie_extensions: Option<UserLocationInformationNRIE_Extensions> = None;
        Ok(Self {
            nr_cgi,
            tai,
            time_stamp,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.nr_cgi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.tai.to_entropy_sink(sink)?;
        __entropic_internal_length += self.time_stamp.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationTNGF {
    pub tnap_id: TNAP_ID,
    pub ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub port_number: Option<PortNumber>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationTNGFIE_Extensions>,
}
impl entropic::Entropic for UserLocationInformationTNGF {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let tnap_id: TNAP_ID = source.get_entropic()?;
        let ip_address: TransportLayerAddress = source.get_entropic()?;
        let port_number: Option<PortNumber> = source.get_entropic()?;
        let ie_extensions: Option<UserLocationInformationTNGFIE_Extensions> = None;
        Ok(Self {
            tnap_id,
            ip_address,
            port_number,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tnap_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ip_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.port_number.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationTWIF {
    pub twap_id: TWAP_ID,
    pub ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub port_number: Option<PortNumber>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationTWIFIE_Extensions>,
}
impl entropic::Entropic for UserLocationInformationTWIF {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let twap_id: TWAP_ID = source.get_entropic()?;
        let ip_address: TransportLayerAddress = source.get_entropic()?;
        let port_number: Option<PortNumber> = source.get_entropic()?;
        let ie_extensions: Option<UserLocationInformationTWIFIE_Extensions> = None;
        Ok(Self {
            twap_id,
            ip_address,
            port_number,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.twap_id.to_entropy_sink(sink)?;
        __entropic_internal_length += self.ip_address.to_entropy_sink(sink)?;
        __entropic_internal_length += self.port_number.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum UserLocationInformationW_AGF {
    #[asn(key = 0, extended = false)]
    GlobalLine_ID(GlobalLine_ID),
    #[asn(key = 1, extended = false)]
    HFCNode_ID(HFCNode_ID),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(UserLocationInformationW_AGF_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for UserLocationInformationW_AGF {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UserLocationInformationW_AGF::GlobalLine_ID(_) => 0u128.try_into().unwrap(),
            UserLocationInformationW_AGF::HFCNode_ID(_) => 1u128.try_into().unwrap(),
            UserLocationInformationW_AGF::Choice_Extensions(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UserPlaneSecurityInformation {
    pub security_result: SecurityResult,
    pub security_indication: SecurityIndication,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UserPlaneSecurityInformationIE_Extensions>,
}
impl entropic::Entropic for UserPlaneSecurityInformation {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let security_result: SecurityResult = source.get_entropic()?;
        let security_indication: SecurityIndication = source.get_entropic()?;
        let ie_extensions: Option<UserPlaneSecurityInformationIE_Extensions> = None;
        Ok(Self {
            security_result,
            security_indication,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.security_result.to_entropy_sink(sink)?;
        __entropic_internal_length += self.security_indication.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct VehicleUE(pub u8);
impl VehicleUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for VehicleUE {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(VehicleUE(source.get_uniform_range(0..=1)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct VolumeTimedReport_Item {
    pub start_time_stamp: VolumeTimedReport_ItemStartTimeStamp,
    pub end_time_stamp: VolumeTimedReport_ItemEndTimeStamp,
    pub usage_count_ul: VolumeTimedReport_ItemUsageCountUL,
    pub usage_count_dl: VolumeTimedReport_ItemUsageCountDL,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<VolumeTimedReport_ItemIE_Extensions>,
}
impl entropic::Entropic for VolumeTimedReport_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let start_time_stamp: VolumeTimedReport_ItemStartTimeStamp = source.get_entropic()?;
        let end_time_stamp: VolumeTimedReport_ItemEndTimeStamp = source.get_entropic()?;
        let usage_count_ul: VolumeTimedReport_ItemUsageCountUL = source.get_entropic()?;
        let usage_count_dl: VolumeTimedReport_ItemUsageCountDL = source.get_entropic()?;
        let ie_extensions: Option<VolumeTimedReport_ItemIE_Extensions> = None;
        Ok(Self {
            start_time_stamp,
            end_time_stamp,
            usage_count_ul,
            usage_count_dl,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.start_time_stamp.to_entropy_sink(sink)?;
        __entropic_internal_length += self.end_time_stamp.to_entropy_sink(sink)?;
        __entropic_internal_length += self.usage_count_ul.to_entropy_sink(sink)?;
        __entropic_internal_length += self.usage_count_dl.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct VolumeTimedReportList(pub Vec<VolumeTimedReport_Item>);
impl entropic::Entropic for VolumeTimedReportList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(VolumeTimedReport_Item::from_entropy_source(source)?);
        }
        Ok(VolumeTimedReportList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum W_AGF_ID {
    #[asn(key = 0, extended = false)]
    W_AGF_ID(W_AGF_ID_w_AGF_ID),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(W_AGF_ID_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for W_AGF_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            W_AGF_ID::W_AGF_ID(_) => 0u128.try_into().unwrap(),
            W_AGF_ID::Choice_Extensions(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasConfig(pub u8);
impl WLANMeasConfig {
    pub const SETUP: u8 = 0u8;
}
impl entropic::Entropic for WLANMeasConfig {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(WLANMeasConfig(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct WLANMeasConfigNameItem {
    pub wlan_name: WLANName,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<WLANMeasConfigNameItemIE_Extensions>,
}
impl entropic::Entropic for WLANMeasConfigNameItem {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let wlan_name: WLANName = source.get_entropic()?;
        let ie_extensions: Option<WLANMeasConfigNameItemIE_Extensions> = None;
        Ok(Self {
            wlan_name,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.wlan_name.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct WLANMeasConfigNameList(pub Vec<WLANMeasConfigNameItem>);
impl entropic::Entropic for WLANMeasConfigNameList {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WLANMeasConfigNameItem::from_entropy_source(source)?);
        }
        Ok(WLANMeasConfigNameList(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct WLANMeasurementConfiguration {
    pub wlan_meas_config: WLANMeasConfig,
    #[asn(optional_idx = 0)]
    pub wlan_meas_config_name_list: Option<WLANMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub wlan_rssi: Option<WLANMeasurementConfigurationWlan_rssi>,
    #[asn(optional_idx = 2)]
    pub wlan_rtt: Option<WLANMeasurementConfigurationWlan_rtt>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<WLANMeasurementConfigurationIE_Extensions>,
}
impl entropic::Entropic for WLANMeasurementConfiguration {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let wlan_meas_config: WLANMeasConfig = source.get_entropic()?;
        let wlan_meas_config_name_list: Option<WLANMeasConfigNameList> = source.get_entropic()?;
        let wlan_rssi: Option<WLANMeasurementConfigurationWlan_rssi> = source.get_entropic()?;
        let wlan_rtt: Option<WLANMeasurementConfigurationWlan_rtt> = source.get_entropic()?;
        let ie_extensions: Option<WLANMeasurementConfigurationIE_Extensions> = None;
        Ok(Self {
            wlan_meas_config,
            wlan_meas_config_name_list,
            wlan_rssi,
            wlan_rtt,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.wlan_meas_config.to_entropy_sink(sink)?;
        __entropic_internal_length += self.wlan_meas_config_name_list.to_entropy_sink(sink)?;
        __entropic_internal_length += self.wlan_rssi.to_entropy_sink(sink)?;
        __entropic_internal_length += self.wlan_rtt.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "32"
)]
pub struct WLANName(pub Vec<u8>);
impl entropic::Entropic for WLANName {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(WLANName(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct WUS_Assistance_Information {
    pub paging_probability_information: PagingProbabilityInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<WUS_Assistance_InformationIE_Extensions>,
}
impl entropic::Entropic for WUS_Assistance_Information {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let paging_probability_information: PagingProbabilityInformation = source.get_entropic()?;
        let ie_extensions: Option<WUS_Assistance_InformationIE_Extensions> = None;
        Ok(Self {
            paging_probability_information,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.paging_probability_information.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct WarningAreaCoordinates(pub Vec<u8>);
impl entropic::Entropic for WarningAreaCoordinates {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(WarningAreaCoordinates(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum WarningAreaList {
    #[asn(key = 0, extended = false)]
    EUTRA_CGIListForWarning(EUTRA_CGIListForWarning),
    #[asn(key = 1, extended = false)]
    NR_CGIListForWarning(NR_CGIListForWarning),
    #[asn(key = 2, extended = false)]
    TAIListForWarning(TAIListForWarning),
    #[asn(key = 3, extended = false)]
    EmergencyAreaIDList(EmergencyAreaIDList),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(WarningAreaList_choice_Extensions),
}
impl asn1_codecs::Asn1Choice for WarningAreaList {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            WarningAreaList::EUTRA_CGIListForWarning(_) => 0u128.try_into().unwrap(),
            WarningAreaList::NR_CGIListForWarning(_) => 1u128.try_into().unwrap(),
            WarningAreaList::TAIListForWarning(_) => 2u128.try_into().unwrap(),
            WarningAreaList::EmergencyAreaIDList(_) => 3u128.try_into().unwrap(),
            WarningAreaList::Choice_Extensions(_) => 4u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "9600"
)]
pub struct WarningMessageContents(pub Vec<u8>);
impl entropic::Entropic for WarningMessageContents {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(WarningMessageContents(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "50",
    sz_ub = "50"
)]
pub struct WarningSecurityInfo(pub Vec<u8>);
impl entropic::Entropic for WarningSecurityInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(50, 16383);
        let vec_len = source.get_bounded_len(50..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(WarningSecurityInfo(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(50, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(50..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct WarningType(pub Vec<u8>);
impl entropic::Entropic for WarningType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(WarningType(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningRequest {
    pub protocol_i_es: WriteReplaceWarningRequestProtocolIEs,
}
impl entropic::Entropic for WriteReplaceWarningRequest {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: WriteReplaceWarningRequestProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningResponse {
    pub protocol_i_es: WriteReplaceWarningResponseProtocolIEs,
}
impl entropic::Entropic for WriteReplaceWarningResponse {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let protocol_i_es: WriteReplaceWarningResponseProtocolIEs = source.get_entropic()?;
        Ok(Self { protocol_i_es })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.protocol_i_es.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct XnExtTLA_Item {
    #[asn(optional_idx = 0)]
    pub i_psec_tla: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub gtp_tl_as: Option<XnGTP_TLAs>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<XnExtTLA_ItemIE_Extensions>,
}
impl entropic::Entropic for XnExtTLA_Item {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let i_psec_tla: Option<TransportLayerAddress> = source.get_entropic()?;
        let gtp_tl_as: Option<XnGTP_TLAs> = source.get_entropic()?;
        let ie_extensions: Option<XnExtTLA_ItemIE_Extensions> = None;
        Ok(Self {
            i_psec_tla,
            gtp_tl_as,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.i_psec_tla.to_entropy_sink(sink)?;
        __entropic_internal_length += self.gtp_tl_as.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct XnExtTLAs(pub Vec<XnExtTLA_Item>);
impl entropic::Entropic for XnExtTLAs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(XnExtTLA_Item::from_entropy_source(source)?);
        }
        Ok(XnExtTLAs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct XnGTP_TLAs(pub Vec<TransportLayerAddress>);
impl entropic::Entropic for XnGTP_TLAs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(16, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TransportLayerAddress::from_entropy_source(source)?);
        }
        Ok(XnGTP_TLAs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct XnTLAs(pub Vec<TransportLayerAddress>);
impl entropic::Entropic for XnTLAs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(2, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TransportLayerAddress::from_entropy_source(source)?);
        }
        Ok(XnTLAs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct XnTNLConfigurationInfo {
    pub xn_transport_layer_addresses: XnTLAs,
    #[asn(optional_idx = 0)]
    pub xn_extended_transport_layer_addresses: Option<XnExtTLAs>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<XnTNLConfigurationInfoIE_Extensions>,
}
impl entropic::Entropic for XnTNLConfigurationInfo {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let xn_transport_layer_addresses: XnTLAs = source.get_entropic()?;
        let xn_extended_transport_layer_addresses: Option<XnExtTLAs> = source.get_entropic()?;
        let ie_extensions: Option<XnTNLConfigurationInfoIE_Extensions> = None;
        Ok(Self {
            xn_transport_layer_addresses,
            xn_extended_transport_layer_addresses,
            ie_extensions,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.xn_transport_layer_addresses.to_entropy_sink(sink)?;
        __entropic_internal_length += self
            .xn_extended_transport_layer_addresses
            .to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationSetupItemIE_Extensions_Entry {}
impl entropic::Entropic for AMF_TNLAssociationSetupItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationSetupItemIE_Extensions(
    pub Vec<AMF_TNLAssociationSetupItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AMF_TNLAssociationSetupItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationSetupItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationSetupItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationToAddItemIE_Extensions_Entry {}
impl entropic::Entropic for AMF_TNLAssociationToAddItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationToAddItemIE_Extensions(
    pub Vec<AMF_TNLAssociationToAddItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AMF_TNLAssociationToAddItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationToAddItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationToAddItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AMF_TNLAssociationToRemoveItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 168)]
    Id_TNLAssociationTransportLayerAddressNGRAN(CPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice for AMF_TNLAssociationToRemoveItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_TNLAssociationTransportLayerAddressNGRAN(_) => 168u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationToRemoveItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AMF_TNLAssociationToRemoveItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for AMF_TNLAssociationToRemoveItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: AMF_TNLAssociationToRemoveItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationToRemoveItemIE_Extensions(
    pub Vec<AMF_TNLAssociationToRemoveItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AMF_TNLAssociationToRemoveItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationToRemoveItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationToRemoveItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationToUpdateItemIE_Extensions_Entry {}
impl entropic::Entropic for AMF_TNLAssociationToUpdateItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationToUpdateItemIE_Extensions(
    pub Vec<AMF_TNLAssociationToUpdateItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AMF_TNLAssociationToUpdateItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AMF_TNLAssociationToUpdateItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AMF_TNLAssociationToUpdateItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AMFCPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
}
impl asn1_codecs::Asn1Choice for AMFCPRelocationIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_S_NSSAI(_) => 148u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFCPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFCPRelocationIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for AMFCPRelocationIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: AMFCPRelocationIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFCPRelocationIndicationProtocolIEs(
    pub Vec<AMFCPRelocationIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AMFConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 6)]
    Id_AMF_TNLAssociationToAddList(AMF_TNLAssociationToAddList),
    #[asn(key = 7)]
    Id_AMF_TNLAssociationToRemoveList(AMF_TNLAssociationToRemoveList),
    #[asn(key = 8)]
    Id_AMF_TNLAssociationToUpdateList(AMF_TNLAssociationToUpdateList),
    #[asn(key = 1)]
    Id_AMFName(AMFName),
    #[asn(key = 274)]
    Id_Extended_AMFName(Extended_AMFName),
    #[asn(key = 80)]
    Id_PLMNSupportList(PLMNSupportList),
    #[asn(key = 86)]
    Id_RelativeAMFCapacity(RelativeAMFCapacity),
    #[asn(key = 96)]
    Id_ServedGUAMIList(ServedGUAMIList),
}
impl asn1_codecs::Asn1Choice for AMFConfigurationUpdateProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_TNLAssociationToAddList(_) => 6u128.try_into().unwrap(),
            Self::Id_AMF_TNLAssociationToRemoveList(_) => 7u128.try_into().unwrap(),
            Self::Id_AMF_TNLAssociationToUpdateList(_) => 8u128.try_into().unwrap(),
            Self::Id_AMFName(_) => 1u128.try_into().unwrap(),
            Self::Id_Extended_AMFName(_) => 274u128.try_into().unwrap(),
            Self::Id_PLMNSupportList(_) => 80u128.try_into().unwrap(),
            Self::Id_RelativeAMFCapacity(_) => 86u128.try_into().unwrap(),
            Self::Id_ServedGUAMIList(_) => 96u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFConfigurationUpdateProtocolIEs_EntryValue,
}
impl entropic::Entropic for AMFConfigurationUpdateProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: AMFConfigurationUpdateProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFConfigurationUpdateProtocolIEs(pub Vec<AMFConfigurationUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 4)]
    Id_AMF_TNLAssociationFailedToSetupList(TNLAssociationList),
    #[asn(key = 5)]
    Id_AMF_TNLAssociationSetupList(AMF_TNLAssociationSetupList),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}
impl asn1_codecs::Asn1Choice for AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_TNLAssociationFailedToSetupList(_) => 4u128.try_into().unwrap(),
            Self::Id_AMF_TNLAssociationSetupList(_) => 5u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AMFConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 107)]
    Id_TimeToWait(TimeToWait),
}
impl asn1_codecs::Asn1Choice for AMFConfigurationUpdateFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_TimeToWait(_) => 107u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFConfigurationUpdateFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for AMFConfigurationUpdateFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: AMFConfigurationUpdateFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFConfigurationUpdateFailureProtocolIEs(
    pub Vec<AMFConfigurationUpdateFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFPagingTarget_choice_Extensions {}
impl entropic::Entropic for AMFPagingTarget_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AMFStatusIndicationProtocolIEs_EntryValue {
    #[asn(key = 120)]
    Id_UnavailableGUAMIList(UnavailableGUAMIList),
}
impl asn1_codecs::Asn1Choice for AMFStatusIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_UnavailableGUAMIList(_) => 120u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFStatusIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFStatusIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for AMFStatusIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: AMFStatusIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFStatusIndicationProtocolIEs(pub Vec<AMFStatusIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AdditionalDLUPTNLInformationForHOItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 183)]
    Id_AdditionalRedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice
    for AdditionalDLUPTNLInformationForHOItemIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRedundantDL_NGU_UP_TNLInformation(_) => 183u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AdditionalDLUPTNLInformationForHOItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AdditionalDLUPTNLInformationForHOItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for AdditionalDLUPTNLInformationForHOItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : AdditionalDLUPTNLInformationForHOItemIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AdditionalDLUPTNLInformationForHOItemIE_Extensions(
    pub Vec<AdditionalDLUPTNLInformationForHOItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AdditionalDLUPTNLInformationForHOItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                AdditionalDLUPTNLInformationForHOItemIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(AdditionalDLUPTNLInformationForHOItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllocationAndRetentionPriorityIE_Extensions_Entry {}
impl entropic::Entropic for AllocationAndRetentionPriorityIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AllocationAndRetentionPriorityIE_Extensions(
    pub Vec<AllocationAndRetentionPriorityIE_Extensions_Entry>,
);
impl entropic::Entropic for AllocationAndRetentionPriorityIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AllocationAndRetentionPriorityIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AllocationAndRetentionPriorityIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Allowed_PNI_NPN_ItemPNI_NPN_restricted(pub u8);
impl Allowed_PNI_NPN_ItemPNI_NPN_restricted {
    pub const RESTRICTED: u8 = 0u8;
    pub const NOT_RESTRICTED: u8 = 1u8;
}
impl entropic::Entropic for Allowed_PNI_NPN_ItemPNI_NPN_restricted {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Allowed_PNI_NPN_ItemPNI_NPN_restricted(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Allowed_PNI_NPN_ItemIE_Extensions_Entry {}
impl entropic::Entropic for Allowed_PNI_NPN_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Allowed_PNI_NPN_ItemIE_Extensions(pub Vec<Allowed_PNI_NPN_ItemIE_Extensions_Entry>);
impl entropic::Entropic for Allowed_PNI_NPN_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Allowed_PNI_NPN_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(Allowed_PNI_NPN_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllowedNSSAI_ItemIE_Extensions_Entry {}
impl entropic::Entropic for AllowedNSSAI_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AllowedNSSAI_ItemIE_Extensions(pub Vec<AllowedNSSAI_ItemIE_Extensions_Entry>);
impl entropic::Entropic for AllowedNSSAI_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AllowedNSSAI_ItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(AllowedNSSAI_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AlternativeQoSParaSetItemIE_Extensions_Entry {}
impl entropic::Entropic for AlternativeQoSParaSetItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AlternativeQoSParaSetItemIE_Extensions(
    pub Vec<AlternativeQoSParaSetItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AlternativeQoSParaSetItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AlternativeQoSParaSetItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AlternativeQoSParaSetItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestIE_Extensions_Entry {}
impl entropic::Entropic for AreaOfInterestIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestIE_Extensions(pub Vec<AreaOfInterestIE_Extensions_Entry>);
impl entropic::Entropic for AreaOfInterestIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(AreaOfInterestIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestCellItemIE_Extensions_Entry {}
impl entropic::Entropic for AreaOfInterestCellItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestCellItemIE_Extensions(pub Vec<AreaOfInterestCellItemIE_Extensions_Entry>);
impl entropic::Entropic for AreaOfInterestCellItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestCellItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AreaOfInterestCellItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestItemIE_Extensions_Entry {}
impl entropic::Entropic for AreaOfInterestItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestItemIE_Extensions(pub Vec<AreaOfInterestItemIE_Extensions_Entry>);
impl entropic::Entropic for AreaOfInterestItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(AreaOfInterestItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestRANNodeItemIE_Extensions_Entry {}
impl entropic::Entropic for AreaOfInterestRANNodeItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestRANNodeItemIE_Extensions(
    pub Vec<AreaOfInterestRANNodeItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AreaOfInterestRANNodeItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestRANNodeItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AreaOfInterestRANNodeItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestTAIItemIE_Extensions_Entry {}
impl entropic::Entropic for AreaOfInterestTAIItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestTAIItemIE_Extensions(pub Vec<AreaOfInterestTAIItemIE_Extensions_Entry>);
impl entropic::Entropic for AreaOfInterestTAIItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaOfInterestTAIItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AreaOfInterestTAIItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct AreaScopeOfMDT_EUTRA_pLMNWide;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaScopeOfMDT_EUTRA_choice_Extensions {}
impl entropic::Entropic for AreaScopeOfMDT_EUTRA_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct AreaScopeOfMDT_NR_pLMNWide;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaScopeOfMDT_NR_choice_Extensions {}
impl entropic::Entropic for AreaScopeOfMDT_NR_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaScopeOfNeighCellsItemIE_Extensions_Entry {}
impl entropic::Entropic for AreaScopeOfNeighCellsItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaScopeOfNeighCellsItemIE_Extensions(
    pub Vec<AreaScopeOfNeighCellsItemIE_Extensions_Entry>,
);
impl entropic::Entropic for AreaScopeOfNeighCellsItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AreaScopeOfNeighCellsItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AreaScopeOfNeighCellsItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AssistanceDataForPagingIE_Extensions_EntryExtensionValue {
    #[asn(key = 260)]
    Id_NPN_PagingAssistanceInformation(NPN_PagingAssistanceInformation),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
}
impl asn1_codecs::Asn1Choice for AssistanceDataForPagingIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_NPN_PagingAssistanceInformation(_) => 260u128.try_into().unwrap(),
            Self::Id_PagingAssisDataforCEcapabUE(_) => 207u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForPagingIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AssistanceDataForPagingIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for AssistanceDataForPagingIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: AssistanceDataForPagingIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForPagingIE_Extensions(
    pub Vec<AssistanceDataForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for AssistanceDataForPagingIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AssistanceDataForPagingIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AssistanceDataForPagingIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions_Entry {}
impl entropic::Entropic for AssistanceDataForRecommendedCellsIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions(
    pub Vec<AssistanceDataForRecommendedCellsIE_Extensions_Entry>,
);
impl entropic::Entropic for AssistanceDataForRecommendedCellsIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                AssistanceDataForRecommendedCellsIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(AssistanceDataForRecommendedCellsIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct AssociatedQosFlowItemQosFlowMappingIndication(pub u8);
impl AssociatedQosFlowItemQosFlowMappingIndication {
    pub const UL: u8 = 0u8;
    pub const DL: u8 = 1u8;
}
impl entropic::Entropic for AssociatedQosFlowItemQosFlowMappingIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(AssociatedQosFlowItemQosFlowMappingIndication(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum AssociatedQosFlowItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}
impl asn1_codecs::Asn1Choice for AssociatedQosFlowItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CurrentQoSParaSetIndex(_) => 221u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssociatedQosFlowItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AssociatedQosFlowItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for AssociatedQosFlowItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: AssociatedQosFlowItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssociatedQosFlowItemIE_Extensions(pub Vec<AssociatedQosFlowItemIE_Extensions_Entry>);
impl entropic::Entropic for AssociatedQosFlowItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AssociatedQosFlowItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(AssociatedQosFlowItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BluetoothMeasConfigNameItemIE_Extensions_Entry {}
impl entropic::Entropic for BluetoothMeasConfigNameItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BluetoothMeasConfigNameItemIE_Extensions(
    pub Vec<BluetoothMeasConfigNameItemIE_Extensions_Entry>,
);
impl entropic::Entropic for BluetoothMeasConfigNameItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(BluetoothMeasConfigNameItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(BluetoothMeasConfigNameItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasurementConfigurationBt_rssi(pub u8);
impl BluetoothMeasurementConfigurationBt_rssi {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for BluetoothMeasurementConfigurationBt_rssi {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(BluetoothMeasurementConfigurationBt_rssi(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BluetoothMeasurementConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for BluetoothMeasurementConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BluetoothMeasurementConfigurationIE_Extensions(
    pub Vec<BluetoothMeasurementConfigurationIE_Extensions_Entry>,
);
impl entropic::Entropic for BluetoothMeasurementConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                BluetoothMeasurementConfigurationIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(BluetoothMeasurementConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BroadcastCancelledAreaList_choice_Extensions {}
impl entropic::Entropic for BroadcastCancelledAreaList_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BroadcastCompletedAreaList_choice_Extensions {}
impl entropic::Entropic for BroadcastCompletedAreaList_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum BroadcastPLMNItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 271)]
    Id_ExtendedTAISliceSupportList(ExtendedSliceSupportList),
    #[asn(key = 258)]
    Id_NPN_Support(NPN_Support),
}
impl asn1_codecs::Asn1Choice for BroadcastPLMNItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ExtendedTAISliceSupportList(_) => 271u128.try_into().unwrap(),
            Self::Id_NPN_Support(_) => 258u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BroadcastPLMNItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: BroadcastPLMNItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for BroadcastPLMNItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: BroadcastPLMNItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BroadcastPLMNItemIE_Extensions(pub Vec<BroadcastPLMNItemIE_Extensions_Entry>);
impl entropic::Entropic for BroadcastPLMNItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(BroadcastPLMNItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(BroadcastPLMNItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CNAssistedRANTuningIE_Extensions_Entry {}
impl entropic::Entropic for CNAssistedRANTuningIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CNAssistedRANTuningIE_Extensions(pub Vec<CNAssistedRANTuningIE_Extensions_Entry>);
impl entropic::Entropic for CNAssistedRANTuningIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CNAssistedRANTuningIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(CNAssistedRANTuningIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CNTypeRestrictionsForEquivalentItemCn_Type(pub u8);
impl CNTypeRestrictionsForEquivalentItemCn_Type {
    pub const EPC_FORBIDDEN: u8 = 0u8;
    pub const FIVE_GC_FORBIDDEN: u8 = 1u8;
}
impl entropic::Entropic for CNTypeRestrictionsForEquivalentItemCn_Type {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CNTypeRestrictionsForEquivalentItemCn_Type(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CNTypeRestrictionsForEquivalentItemIE_Extensions_Entry {}
impl entropic::Entropic for CNTypeRestrictionsForEquivalentItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CNTypeRestrictionsForEquivalentItemIE_Extensions(
    pub Vec<CNTypeRestrictionsForEquivalentItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CNTypeRestrictionsForEquivalentItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                CNTypeRestrictionsForEquivalentItemIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(CNTypeRestrictionsForEquivalentItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct COUNTValueForPDCP_SN12PDCP_SN12(pub u16);
impl entropic::Entropic for COUNTValueForPDCP_SN12PDCP_SN12 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(COUNTValueForPDCP_SN12PDCP_SN12(
            source.get_uniform_range(0..=4095)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct COUNTValueForPDCP_SN12HFN_PDCP_SN12(pub u32);
impl entropic::Entropic for COUNTValueForPDCP_SN12HFN_PDCP_SN12 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(COUNTValueForPDCP_SN12HFN_PDCP_SN12(
            source.get_uniform_range(0..=1048575)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1048575 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTValueForPDCP_SN12IE_Extensions_Entry {}
impl entropic::Entropic for COUNTValueForPDCP_SN12IE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTValueForPDCP_SN12IE_Extensions(pub Vec<COUNTValueForPDCP_SN12IE_Extensions_Entry>);
impl entropic::Entropic for COUNTValueForPDCP_SN12IE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(COUNTValueForPDCP_SN12IE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(COUNTValueForPDCP_SN12IE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "262143")]
pub struct COUNTValueForPDCP_SN18PDCP_SN18(pub u32);
impl entropic::Entropic for COUNTValueForPDCP_SN18PDCP_SN18 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(COUNTValueForPDCP_SN18PDCP_SN18(
            source.get_uniform_range(0..=262143)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=262143 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16383")]
pub struct COUNTValueForPDCP_SN18HFN_PDCP_SN18(pub u16);
impl entropic::Entropic for COUNTValueForPDCP_SN18HFN_PDCP_SN18 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(COUNTValueForPDCP_SN18HFN_PDCP_SN18(
            source.get_uniform_range(0..=16383)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=16383 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTValueForPDCP_SN18IE_Extensions_Entry {}
impl entropic::Entropic for COUNTValueForPDCP_SN18IE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTValueForPDCP_SN18IE_Extensions(pub Vec<COUNTValueForPDCP_SN18IE_Extensions_Entry>);
impl entropic::Entropic for COUNTValueForPDCP_SN18IE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(COUNTValueForPDCP_SN18IE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(COUNTValueForPDCP_SN18IE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum CPTransportLayerInformation_choice_ExtensionsValue {
    #[asn(key = 169)]
    Id_EndpointIPAddressAndPort(EndpointIPAddressAndPort),
}
impl asn1_codecs::Asn1Choice for CPTransportLayerInformation_choice_ExtensionsValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EndpointIPAddressAndPort(_) => 169u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPTransportLayerInformation_choice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CPTransportLayerInformation_choice_ExtensionsValue,
}
impl entropic::Entropic for CPTransportLayerInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: CPTransportLayerInformation_choice_ExtensionsValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInEAI_EUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CancelledCellsInEAI_EUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_EUTRA_ItemIE_Extensions(
    pub Vec<CancelledCellsInEAI_EUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CancelledCellsInEAI_EUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInEAI_EUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInEAI_EUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInEAI_NR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CancelledCellsInEAI_NR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_NR_ItemIE_Extensions(
    pub Vec<CancelledCellsInEAI_NR_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CancelledCellsInEAI_NR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInEAI_NR_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInEAI_NR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInTAI_EUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CancelledCellsInTAI_EUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_EUTRA_ItemIE_Extensions(
    pub Vec<CancelledCellsInTAI_EUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CancelledCellsInTAI_EUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInTAI_EUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInTAI_EUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInTAI_NR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CancelledCellsInTAI_NR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_NR_ItemIE_Extensions(
    pub Vec<CancelledCellsInTAI_NR_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CancelledCellsInTAI_NR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellsInTAI_NR_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CancelledCellsInTAI_NR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidateCell_choice_Extensions {}
impl entropic::Entropic for CandidateCell_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidateCellIDIE_Extensions_Entry {}
impl entropic::Entropic for CandidateCellIDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CandidateCellIDIE_Extensions(pub Vec<CandidateCellIDIE_Extensions_Entry>);
impl entropic::Entropic for CandidateCellIDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CandidateCellIDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(CandidateCellIDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidateCellItemIE_Extensions_Entry {}
impl entropic::Entropic for CandidateCellItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CandidateCellItemIE_Extensions(pub Vec<CandidateCellItemIE_Extensions_Entry>);
impl entropic::Entropic for CandidateCellItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CandidateCellItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(CandidateCellItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1007", extensible = true)]
pub struct CandidatePCICandidatePCI(pub u16);
impl entropic::Entropic for CandidatePCICandidatePCI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CandidatePCICandidatePCI(
            source.get_uniform_range(0..=1007)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1007 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3279165")]
pub struct CandidatePCICandidateNRARFCN(pub u32);
impl entropic::Entropic for CandidatePCICandidateNRARFCN {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(CandidatePCICandidateNRARFCN(
            source.get_uniform_range(0..=3279165)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3279165 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidatePCIIE_Extensions_Entry {}
impl entropic::Entropic for CandidatePCIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CandidatePCIIE_Extensions(pub Vec<CandidatePCIIE_Extensions_Entry>);
impl entropic::Entropic for CandidatePCIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CandidatePCIIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(CandidatePCIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Cause_choice_Extensions {}
impl entropic::Entropic for Cause_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Cell_CAGInformationIE_Extensions_Entry {}
impl entropic::Entropic for Cell_CAGInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Cell_CAGInformationIE_Extensions(pub Vec<Cell_CAGInformationIE_Extensions_Entry>);
impl entropic::Entropic for Cell_CAGInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Cell_CAGInformationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(Cell_CAGInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedMDT_EUTRAIE_Extensions_Entry {}
impl entropic::Entropic for CellBasedMDT_EUTRAIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedMDT_EUTRAIE_Extensions(pub Vec<CellBasedMDT_EUTRAIE_Extensions_Entry>);
impl entropic::Entropic for CellBasedMDT_EUTRAIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellBasedMDT_EUTRAIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(CellBasedMDT_EUTRAIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedMDT_NRIE_Extensions_Entry {}
impl entropic::Entropic for CellBasedMDT_NRIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedMDT_NRIE_Extensions(pub Vec<CellBasedMDT_NRIE_Extensions_Entry>);
impl entropic::Entropic for CellBasedMDT_NRIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellBasedMDT_NRIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(CellBasedMDT_NRIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDBroadcastEUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CellIDBroadcastEUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastEUTRA_ItemIE_Extensions(
    pub Vec<CellIDBroadcastEUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CellIDBroadcastEUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDBroadcastEUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CellIDBroadcastEUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDBroadcastNR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CellIDBroadcastNR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastNR_ItemIE_Extensions(pub Vec<CellIDBroadcastNR_ItemIE_Extensions_Entry>);
impl entropic::Entropic for CellIDBroadcastNR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDBroadcastNR_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CellIDBroadcastNR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDCancelledEUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CellIDCancelledEUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledEUTRA_ItemIE_Extensions(
    pub Vec<CellIDCancelledEUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CellIDCancelledEUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDCancelledEUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CellIDCancelledEUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDCancelledNR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CellIDCancelledNR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledNR_ItemIE_Extensions(pub Vec<CellIDCancelledNR_ItemIE_Extensions_Entry>);
impl entropic::Entropic for CellIDCancelledNR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellIDCancelledNR_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CellIDCancelledNR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDListForRestart_choice_Extensions {}
impl entropic::Entropic for CellIDListForRestart_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum CellTrafficTraceProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 43)]
    Id_NGRAN_CGI(NGRAN_CGI),
    #[asn(key = 44)]
    Id_NGRANTraceID(NGRANTraceID),
    #[asn(key = 256)]
    Id_PrivacyIndicator(PrivacyIndicator),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 109)]
    Id_TraceCollectionEntityIPAddress(TransportLayerAddress),
    #[asn(key = 257)]
    Id_TraceCollectionEntityURI(URI_address),
}
impl asn1_codecs::Asn1Choice for CellTrafficTraceProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NGRAN_CGI(_) => 43u128.try_into().unwrap(),
            Self::Id_NGRANTraceID(_) => 44u128.try_into().unwrap(),
            Self::Id_PrivacyIndicator(_) => 256u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_TraceCollectionEntityIPAddress(_) => 109u128.try_into().unwrap(),
            Self::Id_TraceCollectionEntityURI(_) => 257u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTrafficTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellTrafficTraceProtocolIEs_EntryValue,
}
impl entropic::Entropic for CellTrafficTraceProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: CellTrafficTraceProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellTrafficTraceProtocolIEs(pub Vec<CellTrafficTraceProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTypeIE_Extensions_Entry {}
impl entropic::Entropic for CellTypeIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellTypeIE_Extensions(pub Vec<CellTypeIE_Extensions_Entry>);
impl entropic::Entropic for CellTypeIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellTypeIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CellTypeIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInEAI_EUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CompletedCellsInEAI_EUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_EUTRA_ItemIE_Extensions(
    pub Vec<CompletedCellsInEAI_EUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CompletedCellsInEAI_EUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInEAI_EUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInEAI_EUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInEAI_NR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CompletedCellsInEAI_NR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_NR_ItemIE_Extensions(
    pub Vec<CompletedCellsInEAI_NR_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CompletedCellsInEAI_NR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInEAI_NR_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInEAI_NR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInTAI_EUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CompletedCellsInTAI_EUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_EUTRA_ItemIE_Extensions(
    pub Vec<CompletedCellsInTAI_EUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CompletedCellsInTAI_EUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInTAI_EUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInTAI_EUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInTAI_NR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CompletedCellsInTAI_NR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_NR_ItemIE_Extensions(
    pub Vec<CompletedCellsInTAI_NR_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CompletedCellsInTAI_NR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellsInTAI_NR_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CompletedCellsInTAI_NR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ConnectionEstablishmentIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 212)]
    Id_DL_CP_SecurityInformation(DL_CP_SecurityInformation),
    #[asn(key = 226)]
    Id_EndIndication(EndIndication),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 210)]
    Id_NB_IoT_UEPriority(NB_IoT_UEPriority),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}
impl asn1_codecs::Asn1Choice for ConnectionEstablishmentIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_CEmodeBrestricted(_) => 222u128.try_into().unwrap(),
            Self::Id_DL_CP_SecurityInformation(_) => 212u128.try_into().unwrap(),
            Self::Id_EndIndication(_) => 226u128.try_into().unwrap(),
            Self::Id_Enhanced_CoverageRestriction(_) => 205u128.try_into().unwrap(),
            Self::Id_NB_IoT_UEPriority(_) => 210u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_S_NSSAI(_) => 148u128.try_into().unwrap(),
            Self::Id_UE_DifferentiationInfo(_) => 209u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 117u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ConnectionEstablishmentIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ConnectionEstablishmentIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for ConnectionEstablishmentIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: ConnectionEstablishmentIndicationProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ConnectionEstablishmentIndicationProtocolIEs(
    pub Vec<ConnectionEstablishmentIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum CoreNetworkAssistanceInformationForInactiveIE_Extensions_EntryExtensionValue {
    #[asn(key = 280)]
    Id_ExtendedUEIdentityIndexValue(ExtendedUEIdentityIndexValue),
    #[asn(key = 223)]
    Id_PagingeDRXInformation(PagingeDRXInformation),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
}
impl asn1_codecs::Asn1Choice
    for CoreNetworkAssistanceInformationForInactiveIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ExtendedUEIdentityIndexValue(_) => 280u128.try_into().unwrap(),
            Self::Id_PagingeDRXInformation(_) => 223u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityForPaging(_) => 118u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CoreNetworkAssistanceInformationForInactiveIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        CoreNetworkAssistanceInformationForInactiveIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for CoreNetworkAssistanceInformationForInactiveIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : CoreNetworkAssistanceInformationForInactiveIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CoreNetworkAssistanceInformationForInactiveIE_Extensions(
    pub Vec<CoreNetworkAssistanceInformationForInactiveIE_Extensions_Entry>,
);
impl entropic::Entropic for CoreNetworkAssistanceInformationForInactiveIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (CoreNetworkAssistanceInformationForInactiveIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(CoreNetworkAssistanceInformationForInactiveIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnosticsIE_Extensions_Entry {}
impl entropic::Entropic for CriticalityDiagnosticsIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnosticsIE_Extensions(pub Vec<CriticalityDiagnosticsIE_Extensions_Entry>);
impl entropic::Entropic for CriticalityDiagnosticsIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CriticalityDiagnosticsIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CriticalityDiagnosticsIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CriticalityDiagnostics_IE_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions(
    pub Vec<CriticalityDiagnostics_IE_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CriticalityDiagnostics_IE_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CriticalityDiagnostics_IE_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(CriticalityDiagnostics_IE_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DAPSRequestInfoDAPSIndicator(pub u8);
impl DAPSRequestInfoDAPSIndicator {
    pub const DAPS_HO_REQUIRED: u8 = 0u8;
}
impl entropic::Entropic for DAPSRequestInfoDAPSIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DAPSRequestInfoDAPSIndicator(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSRequestInfoIE_Extensions_Entry {}
impl entropic::Entropic for DAPSRequestInfoIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSRequestInfoIE_Extensions(pub Vec<DAPSRequestInfoIE_Extensions_Entry>);
impl entropic::Entropic for DAPSRequestInfoIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSRequestInfoIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(DAPSRequestInfoIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct DAPSResponseInfoDapsresponseindicator(pub u8);
impl DAPSResponseInfoDapsresponseindicator {
    pub const DAPS_HO_ACCEPTED: u8 = 0u8;
    pub const DAPS_HO_NOT_ACCEPTED: u8 = 1u8;
}
impl entropic::Entropic for DAPSResponseInfoDapsresponseindicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(DAPSResponseInfoDapsresponseindicator(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoIE_Extensions_Entry {}
impl entropic::Entropic for DAPSResponseInfoIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoIE_Extensions(pub Vec<DAPSResponseInfoIE_Extensions_Entry>);
impl entropic::Entropic for DAPSResponseInfoIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSResponseInfoIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(DAPSResponseInfoIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoItemIE_Extension_Entry {}
impl entropic::Entropic for DAPSResponseInfoItemIE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoItemIE_Extension(pub Vec<DAPSResponseInfoItemIE_Extension_Entry>);
impl entropic::Entropic for DAPSResponseInfoItemIE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSResponseInfoItemIE_Extension_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(DAPSResponseInfoItemIE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_CP_SecurityInformationIE_Extensions_Entry {}
impl entropic::Entropic for DL_CP_SecurityInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DL_CP_SecurityInformationIE_Extensions(
    pub Vec<DL_CP_SecurityInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for DL_CP_SecurityInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DL_CP_SecurityInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(DL_CP_SecurityInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusDL_choice_Extensions {}
impl entropic::Entropic for DRBStatusDL_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusDL12IE_Extension_Entry {}
impl entropic::Entropic for DRBStatusDL12IE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusDL12IE_Extension(pub Vec<DRBStatusDL12IE_Extension_Entry>);
impl entropic::Entropic for DRBStatusDL12IE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBStatusDL12IE_Extension_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(DRBStatusDL12IE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusDL18IE_Extension_Entry {}
impl entropic::Entropic for DRBStatusDL18IE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusDL18IE_Extension(pub Vec<DRBStatusDL18IE_Extension_Entry>);
impl entropic::Entropic for DRBStatusDL18IE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBStatusDL18IE_Extension_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(DRBStatusDL18IE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusUL_choice_Extensions {}
impl entropic::Entropic for DRBStatusUL_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "2048")]
pub struct DRBStatusUL12ReceiveStatusOfUL_PDCP_SDUs(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl entropic::Entropic for DRBStatusUL12ReceiveStatusOfUL_PDCP_SDUs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(2048, 16383);
        let total_bitlen = source.get_bounded_len(1..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(DRBStatusUL12ReceiveStatusOfUL_PDCP_SDUs(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 1);
        let capped_max = std::cmp::min(2048, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusUL12IE_Extension_Entry {}
impl entropic::Entropic for DRBStatusUL12IE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusUL12IE_Extension(pub Vec<DRBStatusUL12IE_Extension_Entry>);
impl entropic::Entropic for DRBStatusUL12IE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBStatusUL12IE_Extension_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(DRBStatusUL12IE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "131072"
)]
pub struct DRBStatusUL18ReceiveStatusOfUL_PDCP_SDUs(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl entropic::Entropic for DRBStatusUL18ReceiveStatusOfUL_PDCP_SDUs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(131072, 16383);
        let total_bitlen = source.get_bounded_len(1..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(DRBStatusUL18ReceiveStatusOfUL_PDCP_SDUs(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 1);
        let capped_max = std::cmp::min(131072, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusUL18IE_Extension_Entry {}
impl entropic::Entropic for DRBStatusUL18IE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusUL18IE_Extension(pub Vec<DRBStatusUL18IE_Extension_Entry>);
impl entropic::Entropic for DRBStatusUL18IE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBStatusUL18IE_Extension_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(DRBStatusUL18IE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry {}
impl entropic::Entropic for DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension(
    pub Vec<DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry>,
);
impl entropic::Entropic for DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DRBsSubjectToStatusTransferItemIE_Extension_EntryExtensionValue {
    #[asn(key = 159)]
    Id_OldAssociatedQosFlowList_ULendmarkerexpected(AssociatedQosFlowList),
}
impl asn1_codecs::Asn1Choice for DRBsSubjectToStatusTransferItemIE_Extension_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_OldAssociatedQosFlowList_ULendmarkerexpected(_) => 159u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBsSubjectToStatusTransferItemIE_Extension_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: DRBsSubjectToStatusTransferItemIE_Extension_EntryExtensionValue,
}
impl entropic::Entropic for DRBsSubjectToStatusTransferItemIE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: DRBsSubjectToStatusTransferItemIE_Extension_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBsSubjectToStatusTransferItemIE_Extension(
    pub Vec<DRBsSubjectToStatusTransferItemIE_Extension_Entry>,
);
impl entropic::Entropic for DRBsSubjectToStatusTransferItemIE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBsSubjectToStatusTransferItemIE_Extension_Entry::from_entropy_source(source)?);
        }
        Ok(DRBsSubjectToStatusTransferItemIE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DRBsToQosFlowsMappingItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 266)]
    Id_DAPSRequestInfo(DAPSRequestInfo),
}
impl asn1_codecs::Asn1Choice for DRBsToQosFlowsMappingItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DAPSRequestInfo(_) => 266u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBsToQosFlowsMappingItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: DRBsToQosFlowsMappingItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for DRBsToQosFlowsMappingItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: DRBsToQosFlowsMappingItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBsToQosFlowsMappingItemIE_Extensions(
    pub Vec<DRBsToQosFlowsMappingItemIE_Extensions_Entry>,
);
impl entropic::Entropic for DRBsToQosFlowsMappingItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DRBsToQosFlowsMappingItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(DRBsToQosFlowsMappingItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DataForwardingResponseDRBItemIE_Extensions_Entry {}
impl entropic::Entropic for DataForwardingResponseDRBItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DataForwardingResponseDRBItemIE_Extensions(
    pub Vec<DataForwardingResponseDRBItemIE_Extensions_Entry>,
);
impl entropic::Entropic for DataForwardingResponseDRBItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DataForwardingResponseDRBItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(DataForwardingResponseDRBItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DataForwardingResponseERABListItemIE_Extensions_Entry {}
impl entropic::Entropic for DataForwardingResponseERABListItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DataForwardingResponseERABListItemIE_Extensions(
    pub Vec<DataForwardingResponseERABListItemIE_Extensions_Entry>,
);
impl entropic::Entropic for DataForwardingResponseERABListItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                DataForwardingResponseERABListItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(DataForwardingResponseERABListItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DeactivateTraceProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 44)]
    Id_NGRANTraceID(NGRANTraceID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for DeactivateTraceProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NGRANTraceID(_) => 44u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeactivateTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DeactivateTraceProtocolIEs_EntryValue,
}
impl entropic::Entropic for DeactivateTraceProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DeactivateTraceProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DeactivateTraceProtocolIEs(pub Vec<DeactivateTraceProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 226)]
    Id_EndIndication(EndIndication),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 31)]
    Id_IndexToRFSP(IndexToRFSP),
    #[asn(key = 36)]
    Id_MobilityRestrictionList(MobilityRestrictionList),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 48)]
    Id_OldAMF(AMFName),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 228)]
    Id_UECapabilityInfoRequest(UECapabilityInfoRequest),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}
impl asn1_codecs::Asn1Choice for DownlinkNASTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_CEmodeBrestricted(_) => 222u128.try_into().unwrap(),
            Self::Id_EndIndication(_) => 226u128.try_into().unwrap(),
            Self::Id_Enhanced_CoverageRestriction(_) => 205u128.try_into().unwrap(),
            Self::Id_Extended_ConnectedTime(_) => 206u128.try_into().unwrap(),
            Self::Id_IndexToRFSP(_) => 31u128.try_into().unwrap(),
            Self::Id_MobilityRestrictionList(_) => 36u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 38u128.try_into().unwrap(),
            Self::Id_OldAMF(_) => 48u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RANPagingPriority(_) => 83u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 177u128.try_into().unwrap(),
            Self::Id_UE_DifferentiationInfo(_) => 209u128.try_into().unwrap(),
            Self::Id_UEAggregateMaximumBitRate(_) => 110u128.try_into().unwrap(),
            Self::Id_UECapabilityInfoRequest(_) => 228u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 117u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNASTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkNASTransportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DownlinkNASTransportProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNASTransportProtocolIEs(pub Vec<DownlinkNASTransportProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}
impl asn1_codecs::Asn1Choice for DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_NRPPa_PDU(_) => 46u128.try_into().unwrap(),
            Self::Id_RoutingID(_) => 89u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNonUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRANConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 157)]
    Id_ENDC_SONConfigurationTransferDL(EN_DCSONConfigurationTransfer),
    #[asn(key = 250)]
    Id_IntersystemSONConfigurationTransferDL(IntersystemSONConfigurationTransfer),
    #[asn(key = 98)]
    Id_SONConfigurationTransferDL(SONConfigurationTransfer),
}
impl asn1_codecs::Asn1Choice for DownlinkRANConfigurationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ENDC_SONConfigurationTransferDL(_) => 157u128.try_into().unwrap(),
            Self::Id_IntersystemSONConfigurationTransferDL(_) => 250u128.try_into().unwrap(),
            Self::Id_SONConfigurationTransferDL(_) => 98u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRANConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRANConfigurationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkRANConfigurationTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DownlinkRANConfigurationTransferProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRANConfigurationTransferProtocolIEs(
    pub Vec<DownlinkRANConfigurationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 268)]
    Id_EarlyStatusTransfer_TransparentContainer(EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_EarlyStatusTransfer_TransparentContainer(_) => 268u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRANEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkRANEarlyStatusTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRANEarlyStatusTransferProtocolIEs(
    pub Vec<DownlinkRANEarlyStatusTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRANStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 84)]
    Id_RANStatusTransfer_TransparentContainer(RANStatusTransfer_TransparentContainer),
}
impl asn1_codecs::Asn1Choice for DownlinkRANStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RANStatusTransfer_TransparentContainer(_) => 84u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRANStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRANStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkRANStatusTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DownlinkRANStatusTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRANStatusTransferProtocolIEs(
    pub Vec<DownlinkRANStatusTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRIMInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 175)]
    Id_RIMInformationTransfer(RIMInformationTransfer),
}
impl asn1_codecs::Asn1Choice for DownlinkRIMInformationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RIMInformationTransfer(_) => 175u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRIMInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRIMInformationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkRIMInformationTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DownlinkRIMInformationTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRIMInformationTransferProtocolIEs(
    pub Vec<DownlinkRIMInformationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}
impl asn1_codecs::Asn1Choice for DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NRPPa_PDU(_) => 46u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RoutingID(_) => 89u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum Dynamic5QIDescriptorIE_Extensions_EntryExtensionValue {
    #[asn(key = 187)]
    Id_CNPacketDelayBudgetDL(ExtendedPacketDelayBudget),
    #[asn(key = 188)]
    Id_CNPacketDelayBudgetUL(ExtendedPacketDelayBudget),
    #[asn(key = 189)]
    Id_ExtendedPacketDelayBudget(ExtendedPacketDelayBudget),
}
impl asn1_codecs::Asn1Choice for Dynamic5QIDescriptorIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CNPacketDelayBudgetDL(_) => 187u128.try_into().unwrap(),
            Self::Id_CNPacketDelayBudgetUL(_) => 188u128.try_into().unwrap(),
            Self::Id_ExtendedPacketDelayBudget(_) => 189u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Dynamic5QIDescriptorIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: Dynamic5QIDescriptorIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for Dynamic5QIDescriptorIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: Dynamic5QIDescriptorIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Dynamic5QIDescriptorIE_Extensions(pub Vec<Dynamic5QIDescriptorIE_Extensions_Entry>);
impl entropic::Entropic for Dynamic5QIDescriptorIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Dynamic5QIDescriptorIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(Dynamic5QIDescriptorIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABInformationItemIE_Extensions_Entry {}
impl entropic::Entropic for E_RABInformationItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABInformationItemIE_Extensions(pub Vec<E_RABInformationItemIE_Extensions_Entry>);
impl entropic::Entropic for E_RABInformationItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABInformationItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(E_RABInformationItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct ENB_ID_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_macroENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(20, 16383);
        let total_bitlen = source.get_bounded_len(20..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ENB_ID_macroENB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 20);
        let capped_max = std::cmp::min(20, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(20..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct ENB_ID_homeENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_homeENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(28, 16383);
        let total_bitlen = source.get_bounded_len(28..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ENB_ID_homeENB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 28);
        let capped_max = std::cmp::min(28, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(28..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "18", sz_ub = "18")]
pub struct ENB_ID_short_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_short_macroENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(18, 16383);
        let total_bitlen = source.get_bounded_len(18..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ENB_ID_short_macroENB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 18);
        let capped_max = std::cmp::min(18, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(18..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "21", sz_ub = "21")]
pub struct ENB_ID_long_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_long_macroENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(21, 16383);
        let total_bitlen = source.get_bounded_len(21..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ENB_ID_long_macroENB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 21);
        let capped_max = std::cmp::min(21, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(21..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENB_ID_choice_Extensions {}
impl entropic::Entropic for ENB_ID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EPS_TAIIE_Extensions_Entry {}
impl entropic::Entropic for EPS_TAIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EPS_TAIIE_Extensions(pub Vec<EPS_TAIIE_Extensions_Entry>);
impl entropic::Entropic for EPS_TAIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EPS_TAIIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(EPS_TAIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EUTRA_CGIIE_Extensions_Entry {}
impl entropic::Entropic for EUTRA_CGIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EUTRA_CGIIE_Extensions(pub Vec<EUTRA_CGIIE_Extensions_Entry>);
impl entropic::Entropic for EUTRA_CGIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRA_CGIIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(EUTRA_CGIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry {}
impl entropic::Entropic for EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EarlyStatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for EarlyStatusTransfer_TransparentContainerIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(EarlyStatusTransfer_TransparentContainerIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDBroadcastNR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for EmergencyAreaIDBroadcastNR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastNR_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDBroadcastNR_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for EmergencyAreaIDBroadcastNR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                EmergencyAreaIDBroadcastNR_ItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(EmergencyAreaIDBroadcastNR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDCancelledNR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for EmergencyAreaIDCancelledNR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledNR_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDCancelledNR_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for EmergencyAreaIDCancelledNR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                EmergencyAreaIDCancelledNR_ItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(EmergencyAreaIDCancelledNR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyFallbackIndicatorIE_Extensions_Entry {}
impl entropic::Entropic for EmergencyFallbackIndicatorIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyFallbackIndicatorIE_Extensions(
    pub Vec<EmergencyFallbackIndicatorIE_Extensions_Entry>,
);
impl entropic::Entropic for EmergencyFallbackIndicatorIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyFallbackIndicatorIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(EmergencyFallbackIndicatorIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EndpointIPAddressAndPortIE_Extensions_Entry {}
impl entropic::Entropic for EndpointIPAddressAndPortIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EndpointIPAddressAndPortIE_Extensions(
    pub Vec<EndpointIPAddressAndPortIE_Extensions_Entry>,
);
impl entropic::Entropic for EndpointIPAddressAndPortIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EndpointIPAddressAndPortIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(EndpointIPAddressAndPortIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ErrorIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for ErrorIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_FiveG_S_TMSI(_) => 26u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ErrorIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ErrorIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for ErrorIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: ErrorIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ErrorIndicationProtocolIEs(pub Vec<ErrorIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EventL1LoggedMDTConfigIE_Extensions_Entry {}
impl entropic::Entropic for EventL1LoggedMDTConfigIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EventL1LoggedMDTConfigIE_Extensions(pub Vec<EventL1LoggedMDTConfigIE_Extensions_Entry>);
impl entropic::Entropic for EventL1LoggedMDTConfigIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EventL1LoggedMDTConfigIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(EventL1LoggedMDTConfigIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EventTrigger_outOfCoverage(pub u8);
impl EventTrigger_outOfCoverage {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for EventTrigger_outOfCoverage {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(EventTrigger_outOfCoverage(source.get_uniform_range(0..=0)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EventTrigger_choice_Extensions {}
impl entropic::Entropic for EventTrigger_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEActivityBehaviourIE_Extensions_Entry {}
impl entropic::Entropic for ExpectedUEActivityBehaviourIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEActivityBehaviourIE_Extensions(
    pub Vec<ExpectedUEActivityBehaviourIE_Extensions_Entry>,
);
impl entropic::Entropic for ExpectedUEActivityBehaviourIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ExpectedUEActivityBehaviourIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(ExpectedUEActivityBehaviourIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEBehaviourIE_Extensions_Entry {}
impl entropic::Entropic for ExpectedUEBehaviourIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEBehaviourIE_Extensions(pub Vec<ExpectedUEBehaviourIE_Extensions_Entry>);
impl entropic::Entropic for ExpectedUEBehaviourIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ExpectedUEBehaviourIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(ExpectedUEBehaviourIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct ExpectedUEMovingTrajectoryItemTimeStayedInCell(pub u16);
impl entropic::Entropic for ExpectedUEMovingTrajectoryItemTimeStayedInCell {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ExpectedUEMovingTrajectoryItemTimeStayedInCell(
            source.get_uniform_range(0..=4095)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEMovingTrajectoryItemIE_Extensions_Entry {}
impl entropic::Entropic for ExpectedUEMovingTrajectoryItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEMovingTrajectoryItemIE_Extensions(
    pub Vec<ExpectedUEMovingTrajectoryItemIE_Extensions_Entry>,
);
impl entropic::Entropic for ExpectedUEMovingTrajectoryItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ExpectedUEMovingTrajectoryItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(ExpectedUEMovingTrajectoryItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Extended_AMFNameIE_Extensions_Entry {}
impl entropic::Entropic for Extended_AMFNameIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Extended_AMFNameIE_Extensions(pub Vec<Extended_AMFNameIE_Extensions_Entry>);
impl entropic::Entropic for Extended_AMFNameIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Extended_AMFNameIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(Extended_AMFNameIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Extended_RANNodeNameIE_Extensions_Entry {}
impl entropic::Entropic for Extended_RANNodeNameIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Extended_RANNodeNameIE_Extensions(pub Vec<Extended_RANNodeNameIE_Extensions_Entry>);
impl entropic::Entropic for Extended_RANNodeNameIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Extended_RANNodeNameIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(Extended_RANNodeNameIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct ExtendedRATRestrictionInformationPrimaryRATRestriction(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl entropic::Entropic for ExtendedRATRestrictionInformationPrimaryRATRestriction {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ExtendedRATRestrictionInformationPrimaryRATRestriction(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct ExtendedRATRestrictionInformationSecondaryRATRestriction(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl entropic::Entropic for ExtendedRATRestrictionInformationSecondaryRATRestriction {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ExtendedRATRestrictionInformationSecondaryRATRestriction(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExtendedRATRestrictionInformationIE_Extensions_Entry {}
impl entropic::Entropic for ExtendedRATRestrictionInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExtendedRATRestrictionInformationIE_Extensions(
    pub Vec<ExtendedRATRestrictionInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for ExtendedRATRestrictionInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                ExtendedRATRestrictionInformationIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(ExtendedRATRestrictionInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FailureIndicationIE_Extensions_Entry {}
impl entropic::Entropic for FailureIndicationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FailureIndicationIE_Extensions(pub Vec<FailureIndicationIE_Extensions_Entry>);
impl entropic::Entropic for FailureIndicationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(FailureIndicationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(FailureIndicationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FirstDLCountIE_Extension_Entry {}
impl entropic::Entropic for FirstDLCountIE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FirstDLCountIE_Extension(pub Vec<FirstDLCountIE_Extension_Entry>);
impl entropic::Entropic for FirstDLCountIE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(FirstDLCountIE_Extension_Entry::from_entropy_source(source)?);
        }
        Ok(FirstDLCountIE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FiveG_S_TMSIIE_Extensions_Entry {}
impl entropic::Entropic for FiveG_S_TMSIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FiveG_S_TMSIIE_Extensions(pub Vec<FiveG_S_TMSIIE_Extensions_Entry>);
impl entropic::Entropic for FiveG_S_TMSIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(FiveG_S_TMSIIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(FiveG_S_TMSIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenAreaInformation_ItemIE_Extensions_Entry {}
impl entropic::Entropic for ForbiddenAreaInformation_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenAreaInformation_ItemIE_Extensions(
    pub Vec<ForbiddenAreaInformation_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for ForbiddenAreaInformation_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ForbiddenAreaInformation_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(ForbiddenAreaInformation_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FromEUTRANtoNGRANIE_Extensions_Entry {}
impl entropic::Entropic for FromEUTRANtoNGRANIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FromEUTRANtoNGRANIE_Extensions(pub Vec<FromEUTRANtoNGRANIE_Extensions_Entry>);
impl entropic::Entropic for FromEUTRANtoNGRANIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(FromEUTRANtoNGRANIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(FromEUTRANtoNGRANIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FromNGRANtoEUTRANIE_Extensions_Entry {}
impl entropic::Entropic for FromNGRANtoEUTRANIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FromNGRANtoEUTRANIE_Extensions(pub Vec<FromNGRANtoEUTRANIE_Extensions_Entry>);
impl entropic::Entropic for FromNGRANtoEUTRANIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(FromNGRANtoEUTRANIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(FromNGRANtoEUTRANIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum GBR_QosInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 220)]
    Id_AlternativeQoSParaSetList(AlternativeQoSParaSetList),
}
impl asn1_codecs::Asn1Choice for GBR_QosInformationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AlternativeQoSParaSetList(_) => 220u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GBR_QosInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for GBR_QosInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GBR_QosInformationIE_Extensions(pub Vec<GBR_QosInformationIE_Extensions_Entry>);
impl entropic::Entropic for GBR_QosInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GBR_QosInformationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GBR_QosInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "22", sz_ub = "32")]
pub struct GNB_ID_gNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for GNB_ID_gNB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(22..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(GNB_ID_gNB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 22);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(22..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GNB_ID_choice_Extensions {}
impl entropic::Entropic for GNB_ID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GTPTunnelIE_Extensions_Entry {}
impl entropic::Entropic for GTPTunnelIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GTPTunnelIE_Extensions(pub Vec<GTPTunnelIE_Extensions_Entry>);
impl entropic::Entropic for GTPTunnelIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GTPTunnelIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(GTPTunnelIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GUAMIIE_Extensions_Entry {}
impl entropic::Entropic for GUAMIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GUAMIIE_Extensions(pub Vec<GUAMIIE_Extensions_Entry>);
impl entropic::Entropic for GUAMIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GUAMIIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(GUAMIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalENB_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalENB_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalENB_IDIE_Extensions(pub Vec<GlobalENB_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalENB_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalENB_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalENB_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalGNB_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalGNB_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalGNB_IDIE_Extensions(pub Vec<GlobalGNB_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalGNB_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalGNB_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalGNB_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalLine_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalLine_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalLine_IDIE_Extensions(pub Vec<GlobalLine_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalLine_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalLine_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalLine_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalN3IWF_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalN3IWF_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalN3IWF_IDIE_Extensions(pub Vec<GlobalN3IWF_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalN3IWF_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalN3IWF_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalN3IWF_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalNgENB_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalNgENB_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalNgENB_IDIE_Extensions(pub Vec<GlobalNgENB_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalNgENB_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalNgENB_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalNgENB_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum GlobalRANNodeID_choice_ExtensionsValue {
    #[asn(key = 240)]
    Id_GlobalTNGF_ID(GlobalTNGF_ID),
    #[asn(key = 241)]
    Id_GlobalTWIF_ID(GlobalTWIF_ID),
    #[asn(key = 242)]
    Id_GlobalW_AGF_ID(GlobalW_AGF_ID),
}
impl asn1_codecs::Asn1Choice for GlobalRANNodeID_choice_ExtensionsValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_GlobalTNGF_ID(_) => 240u128.try_into().unwrap(),
            Self::Id_GlobalTWIF_ID(_) => 241u128.try_into().unwrap(),
            Self::Id_GlobalW_AGF_ID(_) => 242u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalRANNodeID_choice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: GlobalRANNodeID_choice_ExtensionsValue,
}
impl entropic::Entropic for GlobalRANNodeID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: GlobalRANNodeID_choice_ExtensionsValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalTNGF_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalTNGF_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalTNGF_IDIE_Extensions(pub Vec<GlobalTNGF_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalTNGF_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalTNGF_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalTNGF_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalTWIF_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalTWIF_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalTWIF_IDIE_Extensions(pub Vec<GlobalTWIF_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalTWIF_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalTWIF_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalTWIF_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalW_AGF_IDIE_Extensions_Entry {}
impl entropic::Entropic for GlobalW_AGF_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalW_AGF_IDIE_Extensions(pub Vec<GlobalW_AGF_IDIE_Extensions_Entry>);
impl entropic::Entropic for GlobalW_AGF_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GlobalW_AGF_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(GlobalW_AGF_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct HOReportHandoverReportType(pub u8);
impl HOReportHandoverReportType {
    pub const HO_TOO_EARLY: u8 = 0u8;
    pub const HO_TO_WRONG_CELL: u8 = 1u8;
    pub const INTERSYSTEM_PING_PONG: u8 = 2u8;
}
impl entropic::Entropic for HOReportHandoverReportType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(HOReportHandoverReportType(source.get_uniform_range(0..=2)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct HOReportSourcecellC_RNTI(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for HOReportSourcecellC_RNTI {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(HOReportSourcecellC_RNTI(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HOReportIE_Extensions_Entry {}
impl entropic::Entropic for HOReportIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HOReportIE_Extensions(pub Vec<HOReportIE_Extensions_Entry>);
impl entropic::Entropic for HOReportIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HOReportIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(HOReportIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCancelProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverCancelProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverCancelProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverCancelProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelProtocolIEs(pub Vec<HandoverCancelProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCancelAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverCancelAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverCancelAcknowledgeProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverCancelAcknowledgeProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelAcknowledgeProtocolIEs(
    pub Vec<HandoverCancelAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCommandProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 29)]
    Id_HandoverType(HandoverType),
    #[asn(key = 39)]
    Id_NASSecurityParametersFromNGRAN(NASSecurityParametersFromNGRAN),
    #[asn(key = 59)]
    Id_PDUSessionResourceHandoverList(PDUSessionResourceHandoverList),
    #[asn(key = 78)]
    Id_PDUSessionResourceToReleaseListHOCmd(PDUSessionResourceToReleaseListHOCmd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 106)]
    Id_TargetToSource_TransparentContainer(TargetToSource_TransparentContainer),
}
impl asn1_codecs::Asn1Choice for HandoverCommandProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_HandoverType(_) => 29u128.try_into().unwrap(),
            Self::Id_NASSecurityParametersFromNGRAN(_) => 39u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceHandoverList(_) => 59u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceToReleaseListHOCmd(_) => 78u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_TargetToSource_TransparentContainer(_) => 106u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCommandProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverCommandProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverCommandProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCommandProtocolIEs(pub Vec<HandoverCommandProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCommandTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 152)]
    Id_AdditionalDLForwardingUPTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 172)]
    Id_AdditionalULForwardingUPTNLInformation(UPTransportLayerInformationList),
    #[asn(key = 249)]
    Id_DataForwardingResponseERABList(DataForwardingResponseERABList),
    #[asn(key = 164)]
    Id_ULForwardingUP_TNLInformation(UPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice for HandoverCommandTransferIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalDLForwardingUPTNLInformation(_) => 152u128.try_into().unwrap(),
            Self::Id_AdditionalULForwardingUPTNLInformation(_) => 172u128.try_into().unwrap(),
            Self::Id_DataForwardingResponseERABList(_) => 249u128.try_into().unwrap(),
            Self::Id_ULForwardingUP_TNLInformation(_) => 164u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommandTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: HandoverCommandTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for HandoverCommandTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: HandoverCommandTransferIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverCommandTransferIE_Extensions(
    pub Vec<HandoverCommandTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for HandoverCommandTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverCommandTransferIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(HandoverCommandTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 262)]
    Id_TargettoSource_Failure_TransparentContainer(TargettoSource_Failure_TransparentContainer),
}
impl asn1_codecs::Asn1Choice for HandoverFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_TargettoSource_Failure_TransparentContainer(_) => 262u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverFailureProtocolIEs(pub Vec<HandoverFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverNotifyProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 269)]
    Id_NotifySourceNGRANNode(NotifySourceNGRANNode),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for HandoverNotifyProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NotifySourceNGRANNode(_) => 269u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverNotifyProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverNotifyProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverNotifyProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverNotifyProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverNotifyProtocolIEs(pub Vec<HandoverNotifyProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverPreparationFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 262)]
    Id_TargettoSource_Failure_TransparentContainer(TargettoSource_Failure_TransparentContainer),
}
impl asn1_codecs::Asn1Choice for HandoverPreparationFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_TargettoSource_Failure_TransparentContainer(_) => 262u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverPreparationFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverPreparationFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverPreparationFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverPreparationFailureProtocolIEs(
    pub Vec<HandoverPreparationFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationUnsuccessfulTransferIE_Extensions_Entry {}
impl entropic::Entropic for HandoverPreparationUnsuccessfulTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverPreparationUnsuccessfulTransferIE_Extensions(
    pub Vec<HandoverPreparationUnsuccessfulTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for HandoverPreparationUnsuccessfulTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                HandoverPreparationUnsuccessfulTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(HandoverPreparationUnsuccessfulTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 28)]
    Id_GUAMI(GUAMI),
    #[asn(key = 29)]
    Id_HandoverType(HandoverType),
    #[asn(key = 199)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 254)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 34)]
    Id_MaskedIMEISV(MaskedIMEISV),
    #[asn(key = 36)]
    Id_MobilityRestrictionList(MobilityRestrictionList),
    #[asn(key = 37)]
    Id_NASC(NAS_PDU),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 41)]
    Id_NewSecurityContextInd(NewSecurityContextInd),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 73)]
    Id_PDUSessionResourceSetupListHOReq(PDUSessionResourceSetupListHOReq),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 146)]
    Id_RedirectionVoiceFallback(RedirectionVoiceFallback),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 101)]
    Id_SourceToTarget_TransparentContainer(SourceToTarget_TransparentContainer),
    #[asn(key = 108)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 234)]
    Id_UE_UP_CIoT_Support(UE_UP_CIoT_Support),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}
impl asn1_codecs::Asn1Choice for HandoverRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_CEmodeBrestricted(_) => 222u128.try_into().unwrap(),
            Self::Id_CNAssistedRANTuning(_) => 165u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CoreNetworkAssistanceInformationForInactive(_) => 18u128.try_into().unwrap(),
            Self::Id_Enhanced_CoverageRestriction(_) => 205u128.try_into().unwrap(),
            Self::Id_Extended_ConnectedTime(_) => 206u128.try_into().unwrap(),
            Self::Id_GUAMI(_) => 28u128.try_into().unwrap(),
            Self::Id_HandoverType(_) => 29u128.try_into().unwrap(),
            Self::Id_IAB_Authorized(_) => 199u128.try_into().unwrap(),
            Self::Id_LTEUESidelinkAggregateMaximumBitrate(_) => 217u128.try_into().unwrap(),
            Self::Id_LTEV2XServicesAuthorized(_) => 215u128.try_into().unwrap(),
            Self::Id_LocationReportingRequestType(_) => 33u128.try_into().unwrap(),
            Self::Id_ManagementBasedMDTPLMNList(_) => 254u128.try_into().unwrap(),
            Self::Id_MaskedIMEISV(_) => 34u128.try_into().unwrap(),
            Self::Id_MobilityRestrictionList(_) => 36u128.try_into().unwrap(),
            Self::Id_NASC(_) => 37u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 218u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 216u128.try_into().unwrap(),
            Self::Id_NewSecurityContextInd(_) => 41u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 219u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSetupListHOReq(_) => 73u128.try_into().unwrap(),
            Self::Id_RRCInactiveTransitionReportRequest(_) => 91u128.try_into().unwrap(),
            Self::Id_RedirectionVoiceFallback(_) => 146u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 177u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 93u128.try_into().unwrap(),
            Self::Id_SourceToTarget_TransparentContainer(_) => 101u128.try_into().unwrap(),
            Self::Id_TraceActivation(_) => 108u128.try_into().unwrap(),
            Self::Id_UE_DifferentiationInfo(_) => 209u128.try_into().unwrap(),
            Self::Id_UE_UP_CIoT_Support(_) => 234u128.try_into().unwrap(),
            Self::Id_UEAggregateMaximumBitRate(_) => 110u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 119u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestProtocolIEs(pub Vec<HandoverRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 53)]
    Id_PDUSessionResourceAdmittedList(PDUSessionResourceAdmittedList),
    #[asn(key = 56)]
    Id_PDUSessionResourceFailedToSetupListHOAck(PDUSessionResourceFailedToSetupListHOAck),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 106)]
    Id_TargetToSource_TransparentContainer(TargetToSource_TransparentContainer),
}
impl asn1_codecs::Asn1Choice for HandoverRequestAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceAdmittedList(_) => 53u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToSetupListHOAck(_) => 56u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_TargetToSource_TransparentContainer(_) => 106u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverRequestAcknowledgeProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverRequestAcknowledgeProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestAcknowledgeProtocolIEs(
    pub Vec<HandoverRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 153)]
    Id_AdditionalDLUPTNLInformationForHOList(AdditionalDLUPTNLInformationForHOList),
    #[asn(key = 172)]
    Id_AdditionalULForwardingUPTNLInformation(UPTransportLayerInformationList),
    #[asn(key = 249)]
    Id_DataForwardingResponseERABList(DataForwardingResponseERABList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 164)]
    Id_ULForwardingUP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 198)]
    Id_UsedRSNInformation(RedundantPDUSessionInformation),
}
impl asn1_codecs::Asn1Choice
    for HandoverRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalDLUPTNLInformationForHOList(_) => 153u128.try_into().unwrap(),
            Self::Id_AdditionalULForwardingUPTNLInformation(_) => 172u128.try_into().unwrap(),
            Self::Id_DataForwardingResponseERABList(_) => 249u128.try_into().unwrap(),
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_RedundantDL_NGU_UP_TNLInformation(_) => 192u128.try_into().unwrap(),
            Self::Id_ULForwardingUP_TNLInformation(_) => 164u128.try_into().unwrap(),
            Self::Id_UsedRSNInformation(_) => 198u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestAcknowledgeTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: HandoverRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for HandoverRequestAcknowledgeTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: HandoverRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverRequestAcknowledgeTransferIE_Extensions(
    pub Vec<HandoverRequestAcknowledgeTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for HandoverRequestAcknowledgeTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                HandoverRequestAcknowledgeTransferIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(HandoverRequestAcknowledgeTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequiredProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 22)]
    Id_DirectForwardingPathAvailability(DirectForwardingPathAvailability),
    #[asn(key = 29)]
    Id_HandoverType(HandoverType),
    #[asn(key = 61)]
    Id_PDUSessionResourceListHORqd(PDUSessionResourceListHORqd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 101)]
    Id_SourceToTarget_TransparentContainer(SourceToTarget_TransparentContainer),
    #[asn(key = 105)]
    Id_TargetID(TargetID),
}
impl asn1_codecs::Asn1Choice for HandoverRequiredProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_DirectForwardingPathAvailability(_) => 22u128.try_into().unwrap(),
            Self::Id_HandoverType(_) => 29u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceListHORqd(_) => 61u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_SourceToTarget_TransparentContainer(_) => 101u128.try_into().unwrap(),
            Self::Id_TargetID(_) => 105u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequiredProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverRequiredProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverRequiredProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequiredProtocolIEs(pub Vec<HandoverRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequiredTransferIE_Extensions_Entry {}
impl entropic::Entropic for HandoverRequiredTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverRequiredTransferIE_Extensions(
    pub Vec<HandoverRequiredTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for HandoverRequiredTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverRequiredTransferIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(HandoverRequiredTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverResourceAllocationUnsuccessfulTransferIE_Extensions_Entry {}
impl entropic::Entropic for HandoverResourceAllocationUnsuccessfulTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverResourceAllocationUnsuccessfulTransferIE_Extensions(
    pub Vec<HandoverResourceAllocationUnsuccessfulTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for HandoverResourceAllocationUnsuccessfulTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (HandoverResourceAllocationUnsuccessfulTransferIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(HandoverResourceAllocationUnsuccessfulTransferIE_Extensions(
            v,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverSuccessProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverSuccessProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverSuccessProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverSuccessProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverSuccessProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: HandoverSuccessProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverSuccessProtocolIEs(pub Vec<HandoverSuccessProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ImmediateMDTNrIE_Extensions_Entry {}
impl entropic::Entropic for ImmediateMDTNrIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ImmediateMDTNrIE_Extensions(pub Vec<ImmediateMDTNrIE_Extensions_Entry>);
impl entropic::Entropic for ImmediateMDTNrIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ImmediateMDTNrIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(ImmediateMDTNrIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions_Entry {}
impl entropic::Entropic for InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions(
    pub Vec<InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 132)]
    Id_PDUSessionResourceFailedToSetupListCxtFail(PDUSessionResourceFailedToSetupListCxtFail),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for InitialContextSetupFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToSetupListCxtFail(_) => 132u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialContextSetupFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: InitialContextSetupFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupFailureProtocolIEs(
    pub Vec<InitialContextSetupFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 24)]
    Id_EmergencyFallbackIndicator(EmergencyFallbackIndicator),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 28)]
    Id_GUAMI(GUAMI),
    #[asn(key = 199)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 31)]
    Id_IndexToRFSP(IndexToRFSP),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 254)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 34)]
    Id_MaskedIMEISV(MaskedIMEISV),
    #[asn(key = 36)]
    Id_MobilityRestrictionList(MobilityRestrictionList),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 48)]
    Id_OldAMF(AMFName),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 71)]
    Id_PDUSessionResourceSetupListCxtReq(PDUSessionResourceSetupListCxtReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 238)]
    Id_RGLevelWirelineAccessCharacteristics(RGLevelWirelineAccessCharacteristics),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 146)]
    Id_RedirectionVoiceFallback(RedirectionVoiceFallback),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 94)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 108)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 234)]
    Id_UE_UP_CIoT_Support(UE_UP_CIoT_Support),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}
impl asn1_codecs::Asn1Choice for InitialContextSetupRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_CEmodeBrestricted(_) => 222u128.try_into().unwrap(),
            Self::Id_CNAssistedRANTuning(_) => 165u128.try_into().unwrap(),
            Self::Id_CoreNetworkAssistanceInformationForInactive(_) => 18u128.try_into().unwrap(),
            Self::Id_EmergencyFallbackIndicator(_) => 24u128.try_into().unwrap(),
            Self::Id_Enhanced_CoverageRestriction(_) => 205u128.try_into().unwrap(),
            Self::Id_Extended_ConnectedTime(_) => 206u128.try_into().unwrap(),
            Self::Id_GUAMI(_) => 28u128.try_into().unwrap(),
            Self::Id_IAB_Authorized(_) => 199u128.try_into().unwrap(),
            Self::Id_IndexToRFSP(_) => 31u128.try_into().unwrap(),
            Self::Id_LTEUESidelinkAggregateMaximumBitrate(_) => 217u128.try_into().unwrap(),
            Self::Id_LTEV2XServicesAuthorized(_) => 215u128.try_into().unwrap(),
            Self::Id_LocationReportingRequestType(_) => 33u128.try_into().unwrap(),
            Self::Id_ManagementBasedMDTPLMNList(_) => 254u128.try_into().unwrap(),
            Self::Id_MaskedIMEISV(_) => 34u128.try_into().unwrap(),
            Self::Id_MobilityRestrictionList(_) => 36u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 38u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 218u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 216u128.try_into().unwrap(),
            Self::Id_OldAMF(_) => 48u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 219u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSetupListCxtReq(_) => 71u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RGLevelWirelineAccessCharacteristics(_) => 238u128.try_into().unwrap(),
            Self::Id_RRCInactiveTransitionReportRequest(_) => 91u128.try_into().unwrap(),
            Self::Id_RedirectionVoiceFallback(_) => 146u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 177u128.try_into().unwrap(),
            Self::Id_SecurityKey(_) => 94u128.try_into().unwrap(),
            Self::Id_TraceActivation(_) => 108u128.try_into().unwrap(),
            Self::Id_UE_DifferentiationInfo(_) => 209u128.try_into().unwrap(),
            Self::Id_UE_UP_CIoT_Support(_) => 234u128.try_into().unwrap(),
            Self::Id_UEAggregateMaximumBitRate(_) => 110u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 117u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityForPaging(_) => 118u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 119u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialContextSetupRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: InitialContextSetupRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupRequestProtocolIEs(
    pub Vec<InitialContextSetupRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 55)]
    Id_PDUSessionResourceFailedToSetupListCxtRes(PDUSessionResourceFailedToSetupListCxtRes),
    #[asn(key = 72)]
    Id_PDUSessionResourceSetupListCxtRes(PDUSessionResourceSetupListCxtRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for InitialContextSetupResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToSetupListCxtRes(_) => 55u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSetupListCxtRes(_) => 72u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialContextSetupResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: InitialContextSetupResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupResponseProtocolIEs(
    pub Vec<InitialContextSetupResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialUEMessageProtocolIEs_EntryValue {
    #[asn(key = 3)]
    Id_AMFSetID(AMFSetID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 245)]
    Id_AuthenticatedIndication(AuthenticatedIndication),
    #[asn(key = 224)]
    Id_CEmodeBSupport_Indicator(CEmodeBSupport_Indicator),
    #[asn(key = 227)]
    Id_EDT_Session(EDT_Session),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 201)]
    Id_IABNodeIndication(IABNodeIndication),
    #[asn(key = 225)]
    Id_LTEM_Indication(LTEM_Indication),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 259)]
    Id_NPN_AccessInformation(NPN_AccessInformation),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 90)]
    Id_RRCEstablishmentCause(RRCEstablishmentCause),
    #[asn(key = 174)]
    Id_SelectedPLMNIdentity(PLMNIdentity),
    #[asn(key = 171)]
    Id_SourceToTarget_AMFInformationReroute(SourceToTarget_AMFInformationReroute),
    #[asn(key = 112)]
    Id_UEContextRequest(UEContextRequest),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for InitialUEMessageProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMFSetID(_) => 3u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_AuthenticatedIndication(_) => 245u128.try_into().unwrap(),
            Self::Id_CEmodeBSupport_Indicator(_) => 224u128.try_into().unwrap(),
            Self::Id_EDT_Session(_) => 227u128.try_into().unwrap(),
            Self::Id_FiveG_S_TMSI(_) => 26u128.try_into().unwrap(),
            Self::Id_IABNodeIndication(_) => 201u128.try_into().unwrap(),
            Self::Id_LTEM_Indication(_) => 225u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 38u128.try_into().unwrap(),
            Self::Id_NPN_AccessInformation(_) => 259u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RRCEstablishmentCause(_) => 90u128.try_into().unwrap(),
            Self::Id_SelectedPLMNIdentity(_) => 174u128.try_into().unwrap(),
            Self::Id_SourceToTarget_AMFInformationReroute(_) => 171u128.try_into().unwrap(),
            Self::Id_UEContextRequest(_) => 112u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialUEMessageProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialUEMessageProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialUEMessageProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: InitialUEMessageProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialUEMessageProtocolIEs(pub Vec<InitialUEMessageProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingMessageValue {
    #[asn(key = 64)]
    Id_AMFCPRelocationIndication(AMFCPRelocationIndication),
    #[asn(key = 0)]
    Id_AMFConfigurationUpdate(AMFConfigurationUpdate),
    #[asn(key = 1)]
    Id_AMFStatusIndication(AMFStatusIndication),
    #[asn(key = 2)]
    Id_CellTrafficTrace(CellTrafficTrace),
    #[asn(key = 65)]
    Id_ConnectionEstablishmentIndication(ConnectionEstablishmentIndication),
    #[asn(key = 3)]
    Id_DeactivateTrace(DeactivateTrace),
    #[asn(key = 4)]
    Id_DownlinkNASTransport(DownlinkNASTransport),
    #[asn(key = 5)]
    Id_DownlinkNonUEAssociatedNRPPaTransport(DownlinkNonUEAssociatedNRPPaTransport),
    #[asn(key = 6)]
    Id_DownlinkRANConfigurationTransfer(DownlinkRANConfigurationTransfer),
    #[asn(key = 63)]
    Id_DownlinkRANEarlyStatusTransfer(DownlinkRANEarlyStatusTransfer),
    #[asn(key = 7)]
    Id_DownlinkRANStatusTransfer(DownlinkRANStatusTransfer),
    #[asn(key = 54)]
    Id_DownlinkRIMInformationTransfer(DownlinkRIMInformationTransfer),
    #[asn(key = 8)]
    Id_DownlinkUEAssociatedNRPPaTransport(DownlinkUEAssociatedNRPPaTransport),
    #[asn(key = 9)]
    Id_ErrorIndication(ErrorIndication),
    #[asn(key = 10)]
    Id_HandoverCancel(HandoverCancel),
    #[asn(key = 11)]
    Id_HandoverNotification(HandoverNotify),
    #[asn(key = 12)]
    Id_HandoverPreparation(HandoverRequired),
    #[asn(key = 13)]
    Id_HandoverResourceAllocation(HandoverRequest),
    #[asn(key = 61)]
    Id_HandoverSuccess(HandoverSuccess),
    #[asn(key = 14)]
    Id_InitialContextSetup(InitialContextSetupRequest),
    #[asn(key = 15)]
    Id_InitialUEMessage(InitialUEMessage),
    #[asn(key = 18)]
    Id_LocationReport(LocationReport),
    #[asn(key = 16)]
    Id_LocationReportingControl(LocationReportingControl),
    #[asn(key = 17)]
    Id_LocationReportingFailureIndication(LocationReportingFailureIndication),
    #[asn(key = 19)]
    Id_NASNonDeliveryIndication(NASNonDeliveryIndication),
    #[asn(key = 20)]
    Id_NGReset(NGReset),
    #[asn(key = 21)]
    Id_NGSetup(NGSetupRequest),
    #[asn(key = 22)]
    Id_OverloadStart(OverloadStart),
    #[asn(key = 23)]
    Id_OverloadStop(OverloadStop),
    #[asn(key = 26)]
    Id_PDUSessionResourceModify(PDUSessionResourceModifyRequest),
    #[asn(key = 27)]
    Id_PDUSessionResourceModifyIndication(PDUSessionResourceModifyIndication),
    #[asn(key = 30)]
    Id_PDUSessionResourceNotify(PDUSessionResourceNotify),
    #[asn(key = 28)]
    Id_PDUSessionResourceRelease(PDUSessionResourceReleaseCommand),
    #[asn(key = 29)]
    Id_PDUSessionResourceSetup(PDUSessionResourceSetupRequest),
    #[asn(key = 32)]
    Id_PWSCancel(PWSCancelRequest),
    #[asn(key = 33)]
    Id_PWSFailureIndication(PWSFailureIndication),
    #[asn(key = 34)]
    Id_PWSRestartIndication(PWSRestartIndication),
    #[asn(key = 24)]
    Id_Paging(Paging),
    #[asn(key = 25)]
    Id_PathSwitchRequest(PathSwitchRequest),
    #[asn(key = 31)]
    Id_PrivateMessage(PrivateMessage),
    #[asn(key = 57)]
    Id_RANCPRelocationIndication(RANCPRelocationIndication),
    #[asn(key = 35)]
    Id_RANConfigurationUpdate(RANConfigurationUpdate),
    #[asn(key = 37)]
    Id_RRCInactiveTransitionReport(RRCInactiveTransitionReport),
    #[asn(key = 36)]
    Id_RerouteNASRequest(RerouteNASRequest),
    #[asn(key = 55)]
    Id_RetrieveUEInformation(RetrieveUEInformation),
    #[asn(key = 52)]
    Id_SecondaryRATDataUsageReport(SecondaryRATDataUsageReport),
    #[asn(key = 38)]
    Id_TraceFailureIndication(TraceFailureIndication),
    #[asn(key = 39)]
    Id_TraceStart(TraceStart),
    #[asn(key = 40)]
    Id_UEContextModification(UEContextModificationRequest),
    #[asn(key = 41)]
    Id_UEContextRelease(UEContextReleaseCommand),
    #[asn(key = 42)]
    Id_UEContextReleaseRequest(UEContextReleaseRequest),
    #[asn(key = 58)]
    Id_UEContextResume(UEContextResumeRequest),
    #[asn(key = 59)]
    Id_UEContextSuspend(UEContextSuspendRequest),
    #[asn(key = 56)]
    Id_UEInformationTransfer(UEInformationTransfer),
    #[asn(key = 43)]
    Id_UERadioCapabilityCheck(UERadioCapabilityCheckRequest),
    #[asn(key = 60)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingRequest),
    #[asn(key = 44)]
    Id_UERadioCapabilityInfoIndication(UERadioCapabilityInfoIndication),
    #[asn(key = 45)]
    Id_UETNLABindingRelease(UETNLABindingReleaseRequest),
    #[asn(key = 46)]
    Id_UplinkNASTransport(UplinkNASTransport),
    #[asn(key = 47)]
    Id_UplinkNonUEAssociatedNRPPaTransport(UplinkNonUEAssociatedNRPPaTransport),
    #[asn(key = 48)]
    Id_UplinkRANConfigurationTransfer(UplinkRANConfigurationTransfer),
    #[asn(key = 62)]
    Id_UplinkRANEarlyStatusTransfer(UplinkRANEarlyStatusTransfer),
    #[asn(key = 49)]
    Id_UplinkRANStatusTransfer(UplinkRANStatusTransfer),
    #[asn(key = 53)]
    Id_UplinkRIMInformationTransfer(UplinkRIMInformationTransfer),
    #[asn(key = 50)]
    Id_UplinkUEAssociatedNRPPaTransport(UplinkUEAssociatedNRPPaTransport),
    #[asn(key = 51)]
    Id_WriteReplaceWarning(WriteReplaceWarningRequest),
}
impl asn1_codecs::Asn1Choice for InitiatingMessageValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMFCPRelocationIndication(_) => 64u128.try_into().unwrap(),
            Self::Id_AMFConfigurationUpdate(_) => 0u128.try_into().unwrap(),
            Self::Id_AMFStatusIndication(_) => 1u128.try_into().unwrap(),
            Self::Id_CellTrafficTrace(_) => 2u128.try_into().unwrap(),
            Self::Id_ConnectionEstablishmentIndication(_) => 65u128.try_into().unwrap(),
            Self::Id_DeactivateTrace(_) => 3u128.try_into().unwrap(),
            Self::Id_DownlinkNASTransport(_) => 4u128.try_into().unwrap(),
            Self::Id_DownlinkNonUEAssociatedNRPPaTransport(_) => 5u128.try_into().unwrap(),
            Self::Id_DownlinkRANConfigurationTransfer(_) => 6u128.try_into().unwrap(),
            Self::Id_DownlinkRANEarlyStatusTransfer(_) => 63u128.try_into().unwrap(),
            Self::Id_DownlinkRANStatusTransfer(_) => 7u128.try_into().unwrap(),
            Self::Id_DownlinkRIMInformationTransfer(_) => 54u128.try_into().unwrap(),
            Self::Id_DownlinkUEAssociatedNRPPaTransport(_) => 8u128.try_into().unwrap(),
            Self::Id_ErrorIndication(_) => 9u128.try_into().unwrap(),
            Self::Id_HandoverCancel(_) => 10u128.try_into().unwrap(),
            Self::Id_HandoverNotification(_) => 11u128.try_into().unwrap(),
            Self::Id_HandoverPreparation(_) => 12u128.try_into().unwrap(),
            Self::Id_HandoverResourceAllocation(_) => 13u128.try_into().unwrap(),
            Self::Id_HandoverSuccess(_) => 61u128.try_into().unwrap(),
            Self::Id_InitialContextSetup(_) => 14u128.try_into().unwrap(),
            Self::Id_InitialUEMessage(_) => 15u128.try_into().unwrap(),
            Self::Id_LocationReport(_) => 18u128.try_into().unwrap(),
            Self::Id_LocationReportingControl(_) => 16u128.try_into().unwrap(),
            Self::Id_LocationReportingFailureIndication(_) => 17u128.try_into().unwrap(),
            Self::Id_NASNonDeliveryIndication(_) => 19u128.try_into().unwrap(),
            Self::Id_NGReset(_) => 20u128.try_into().unwrap(),
            Self::Id_NGSetup(_) => 21u128.try_into().unwrap(),
            Self::Id_OverloadStart(_) => 22u128.try_into().unwrap(),
            Self::Id_OverloadStop(_) => 23u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModify(_) => 26u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModifyIndication(_) => 27u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceNotify(_) => 30u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceRelease(_) => 28u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSetup(_) => 29u128.try_into().unwrap(),
            Self::Id_PWSCancel(_) => 32u128.try_into().unwrap(),
            Self::Id_PWSFailureIndication(_) => 33u128.try_into().unwrap(),
            Self::Id_PWSRestartIndication(_) => 34u128.try_into().unwrap(),
            Self::Id_Paging(_) => 24u128.try_into().unwrap(),
            Self::Id_PathSwitchRequest(_) => 25u128.try_into().unwrap(),
            Self::Id_PrivateMessage(_) => 31u128.try_into().unwrap(),
            Self::Id_RANCPRelocationIndication(_) => 57u128.try_into().unwrap(),
            Self::Id_RANConfigurationUpdate(_) => 35u128.try_into().unwrap(),
            Self::Id_RRCInactiveTransitionReport(_) => 37u128.try_into().unwrap(),
            Self::Id_RerouteNASRequest(_) => 36u128.try_into().unwrap(),
            Self::Id_RetrieveUEInformation(_) => 55u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReport(_) => 52u128.try_into().unwrap(),
            Self::Id_TraceFailureIndication(_) => 38u128.try_into().unwrap(),
            Self::Id_TraceStart(_) => 39u128.try_into().unwrap(),
            Self::Id_UEContextModification(_) => 40u128.try_into().unwrap(),
            Self::Id_UEContextRelease(_) => 41u128.try_into().unwrap(),
            Self::Id_UEContextReleaseRequest(_) => 42u128.try_into().unwrap(),
            Self::Id_UEContextResume(_) => 58u128.try_into().unwrap(),
            Self::Id_UEContextSuspend(_) => 59u128.try_into().unwrap(),
            Self::Id_UEInformationTransfer(_) => 56u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityCheck(_) => 43u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityIDMapping(_) => 60u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityInfoIndication(_) => 44u128.try_into().unwrap(),
            Self::Id_UETNLABindingRelease(_) => 45u128.try_into().unwrap(),
            Self::Id_UplinkNASTransport(_) => 46u128.try_into().unwrap(),
            Self::Id_UplinkNonUEAssociatedNRPPaTransport(_) => 47u128.try_into().unwrap(),
            Self::Id_UplinkRANConfigurationTransfer(_) => 48u128.try_into().unwrap(),
            Self::Id_UplinkRANEarlyStatusTransfer(_) => 62u128.try_into().unwrap(),
            Self::Id_UplinkRANStatusTransfer(_) => 49u128.try_into().unwrap(),
            Self::Id_UplinkRIMInformationTransfer(_) => 53u128.try_into().unwrap(),
            Self::Id_UplinkUEAssociatedNRPPaTransport(_) => 50u128.try_into().unwrap(),
            Self::Id_WriteReplaceWarning(_) => 51u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemFailureIndicationIE_Extensions_Entry {}
impl entropic::Entropic for InterSystemFailureIndicationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemFailureIndicationIE_Extensions(
    pub Vec<InterSystemFailureIndicationIE_Extensions_Entry>,
);
impl entropic::Entropic for InterSystemFailureIndicationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InterSystemFailureIndicationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(InterSystemFailureIndicationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemHOReportIE_Extensions_Entry {}
impl entropic::Entropic for InterSystemHOReportIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemHOReportIE_Extensions(pub Vec<InterSystemHOReportIE_Extensions_Entry>);
impl entropic::Entropic for InterSystemHOReportIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InterSystemHOReportIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(InterSystemHOReportIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemHandoverReportType_choice_Extensions {}
impl entropic::Entropic for InterSystemHandoverReportType_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONConfigurationTransferIE_Extensions_Entry {}
impl entropic::Entropic for IntersystemSONConfigurationTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemSONConfigurationTransferIE_Extensions(
    pub Vec<IntersystemSONConfigurationTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for IntersystemSONConfigurationTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                IntersystemSONConfigurationTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(IntersystemSONConfigurationTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONInformation_choice_Extensions {}
impl entropic::Entropic for IntersystemSONInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONInformationReport_choice_Extensions {}
impl entropic::Entropic for IntersystemSONInformationReport_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONNGRANnodeIDIE_Extensions_Entry {}
impl entropic::Entropic for IntersystemSONNGRANnodeIDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemSONNGRANnodeIDIE_Extensions(
    pub Vec<IntersystemSONNGRANnodeIDIE_Extensions_Entry>,
);
impl entropic::Entropic for IntersystemSONNGRANnodeIDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(IntersystemSONNGRANnodeIDIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(IntersystemSONNGRANnodeIDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONTransferType_choice_Extensions {}
impl entropic::Entropic for IntersystemSONTransferType_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONeNBIDIE_Extensions_Entry {}
impl entropic::Entropic for IntersystemSONeNBIDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemSONeNBIDIE_Extensions(pub Vec<IntersystemSONeNBIDIE_Extensions_Entry>);
impl entropic::Entropic for IntersystemSONeNBIDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(IntersystemSONeNBIDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(IntersystemSONeNBIDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IntersystemUnnecessaryHOEarlyIRATHO(pub u8);
impl IntersystemUnnecessaryHOEarlyIRATHO {
    pub const TRUE: u8 = 0u8;
    pub const FALSE: u8 = 1u8;
}
impl entropic::Entropic for IntersystemUnnecessaryHOEarlyIRATHO {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(IntersystemUnnecessaryHOEarlyIRATHO(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemUnnecessaryHOIE_Extensions_Entry {}
impl entropic::Entropic for IntersystemUnnecessaryHOIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemUnnecessaryHOIE_Extensions(
    pub Vec<IntersystemUnnecessaryHOIE_Extensions_Entry>,
);
impl entropic::Entropic for IntersystemUnnecessaryHOIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(IntersystemUnnecessaryHOIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(IntersystemUnnecessaryHOIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LAIIE_Extensions_Entry {}
impl entropic::Entropic for LAIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LAIIE_Extensions(pub Vec<LAIIE_Extensions_Entry>);
impl entropic::Entropic for LAIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LAIIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(LAIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LTEUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}
impl entropic::Entropic for LTEUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LTEUESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<LTEUESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl entropic::Entropic for LTEUESidelinkAggregateMaximumBitrateIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                LTEUESidelinkAggregateMaximumBitrateIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(LTEUESidelinkAggregateMaximumBitrateIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LTEV2XServicesAuthorizedIE_Extensions_Entry {}
impl entropic::Entropic for LTEV2XServicesAuthorizedIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LTEV2XServicesAuthorizedIE_Extensions(
    pub Vec<LTEV2XServicesAuthorizedIE_Extensions_Entry>,
);
impl entropic::Entropic for LTEV2XServicesAuthorizedIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LTEV2XServicesAuthorizedIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(LTEV2XServicesAuthorizedIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedCellInformation_choice_Extensions {}
impl entropic::Entropic for LastVisitedCellInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedCellItemIE_Extensions_Entry {}
impl entropic::Entropic for LastVisitedCellItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LastVisitedCellItemIE_Extensions(pub Vec<LastVisitedCellItemIE_Extensions_Entry>);
impl entropic::Entropic for LastVisitedCellItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LastVisitedCellItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(LastVisitedCellItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedNGRANCellInformationIE_Extensions_Entry {}
impl entropic::Entropic for LastVisitedNGRANCellInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LastVisitedNGRANCellInformationIE_Extensions(
    pub Vec<LastVisitedNGRANCellInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for LastVisitedNGRANCellInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                LastVisitedNGRANCellInformationIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(LastVisitedNGRANCellInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 116)]
    Id_UEPresenceInAreaOfInterestList(UEPresenceInAreaOfInterestList),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for LocationReportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_LocationReportingRequestType(_) => 33u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UEPresenceInAreaOfInterestList(_) => 116u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportProtocolIEs_EntryValue,
}
impl entropic::Entropic for LocationReportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: LocationReportProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportProtocolIEs(pub Vec<LocationReportProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingControlProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for LocationReportingControlProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_LocationReportingRequestType(_) => 33u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingControlProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingControlProtocolIEs_EntryValue,
}
impl entropic::Entropic for LocationReportingControlProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: LocationReportingControlProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingControlProtocolIEs(pub Vec<LocationReportingControlProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for LocationReportingFailureIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingFailureIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for LocationReportingFailureIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: LocationReportingFailureIndicationProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingFailureIndicationProtocolIEs(
    pub Vec<LocationReportingFailureIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingRequestTypeIE_Extensions_EntryExtensionValue {
    #[asn(key = 170)]
    Id_LocationReportingAdditionalInfo(LocationReportingAdditionalInfo),
}
impl asn1_codecs::Asn1Choice for LocationReportingRequestTypeIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_LocationReportingAdditionalInfo(_) => 170u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingRequestTypeIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: LocationReportingRequestTypeIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for LocationReportingRequestTypeIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: LocationReportingRequestTypeIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LocationReportingRequestTypeIE_Extensions(
    pub Vec<LocationReportingRequestTypeIE_Extensions_Entry>,
);
impl entropic::Entropic for LocationReportingRequestTypeIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LocationReportingRequestTypeIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(LocationReportingRequestTypeIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMDTNrIE_Extensions_Entry {}
impl entropic::Entropic for LoggedMDTNrIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LoggedMDTNrIE_Extensions(pub Vec<LoggedMDTNrIE_Extensions_Entry>);
impl entropic::Entropic for LoggedMDTNrIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LoggedMDTNrIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(LoggedMDTNrIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct LoggedMDTTrigger_periodical;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMDTTrigger_choice_Extensions {}
impl entropic::Entropic for LoggedMDTTrigger_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M1ConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1ConfigurationIE_Extensions(pub Vec<M1ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M1ConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M1ConfigurationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(M1ConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1PeriodicReportingIE_Extensions_Entry {}
impl entropic::Entropic for M1PeriodicReportingIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1PeriodicReportingIE_Extensions(pub Vec<M1PeriodicReportingIE_Extensions_Entry>);
impl entropic::Entropic for M1PeriodicReportingIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M1PeriodicReportingIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(M1PeriodicReportingIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ThresholdEventA2IE_Extensions_Entry {}
impl entropic::Entropic for M1ThresholdEventA2IE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1ThresholdEventA2IE_Extensions(pub Vec<M1ThresholdEventA2IE_Extensions_Entry>);
impl entropic::Entropic for M1ThresholdEventA2IE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M1ThresholdEventA2IE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(M1ThresholdEventA2IE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ThresholdType_choice_Extensions {}
impl entropic::Entropic for M1ThresholdType_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M4ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M4ConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M4ConfigurationIE_Extensions(pub Vec<M4ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M4ConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M4ConfigurationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(M4ConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M5ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M5ConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M5ConfigurationIE_Extensions(pub Vec<M5ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M5ConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M5ConfigurationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(M5ConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M6ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M6ConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M6ConfigurationIE_Extensions(pub Vec<M6ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M6ConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M6ConfigurationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(M6ConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M7ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M7ConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M7ConfigurationIE_Extensions(pub Vec<M7ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M7ConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M7ConfigurationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(M7ConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for MDT_ConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_ConfigurationIE_Extensions(pub Vec<MDT_ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for MDT_ConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MDT_ConfigurationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(MDT_ConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_Configuration_EUTRAIE_Extensions_Entry {}
impl entropic::Entropic for MDT_Configuration_EUTRAIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_Configuration_EUTRAIE_Extensions(
    pub Vec<MDT_Configuration_EUTRAIE_Extensions_Entry>,
);
impl entropic::Entropic for MDT_Configuration_EUTRAIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MDT_Configuration_EUTRAIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(MDT_Configuration_EUTRAIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_Configuration_NRIE_Extensions_Entry {}
impl entropic::Entropic for MDT_Configuration_NRIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_Configuration_NRIE_Extensions(pub Vec<MDT_Configuration_NRIE_Extensions_Entry>);
impl entropic::Entropic for MDT_Configuration_NRIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MDT_Configuration_NRIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(MDT_Configuration_NRIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_Location_InfoIE_Extensions_Entry {}
impl entropic::Entropic for MDT_Location_InfoIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_Location_InfoIE_Extensions(pub Vec<MDT_Location_InfoIE_Extensions_Entry>);
impl entropic::Entropic for MDT_Location_InfoIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MDT_Location_InfoIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(MDT_Location_InfoIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDTModeNr_choice_Extensions {}
impl entropic::Entropic for MDTModeNr_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementThresholdL1LoggedMDT_choice_Extensions {}
impl entropic::Entropic for MeasurementThresholdL1LoggedMDT_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MobilityRestrictionListIE_Extensions_EntryExtensionValue {
    #[asn(key = 160)]
    Id_CNTypeRestrictionsForEquivalent(CNTypeRestrictionsForEquivalent),
    #[asn(key = 161)]
    Id_CNTypeRestrictionsForServing(CNTypeRestrictionsForServing),
    #[asn(key = 150)]
    Id_LastEUTRAN_PLMNIdentity(PLMNIdentity),
    #[asn(key = 261)]
    Id_NPN_MobilityInformation(NPN_MobilityInformation),
}
impl asn1_codecs::Asn1Choice for MobilityRestrictionListIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CNTypeRestrictionsForEquivalent(_) => 160u128.try_into().unwrap(),
            Self::Id_CNTypeRestrictionsForServing(_) => 161u128.try_into().unwrap(),
            Self::Id_LastEUTRAN_PLMNIdentity(_) => 150u128.try_into().unwrap(),
            Self::Id_NPN_MobilityInformation(_) => 261u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityRestrictionListIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: MobilityRestrictionListIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for MobilityRestrictionListIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: MobilityRestrictionListIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MobilityRestrictionListIE_Extensions(
    pub Vec<MobilityRestrictionListIE_Extensions_Entry>,
);
impl entropic::Entropic for MobilityRestrictionListIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MobilityRestrictionListIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(MobilityRestrictionListIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct N3IWF_ID_n3IWF_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for N3IWF_ID_n3IWF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(N3IWF_ID_n3IWF_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct N3IWF_ID_choice_Extensions {}
impl entropic::Entropic for N3IWF_ID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NASNonDeliveryIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for NASNonDeliveryIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 38u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NASNonDeliveryIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NASNonDeliveryIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for NASNonDeliveryIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: NASNonDeliveryIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NASNonDeliveryIndicationProtocolIEs(pub Vec<NASNonDeliveryIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NB_IoT_Paging_eDRXInfoIE_Extensions_Entry {}
impl entropic::Entropic for NB_IoT_Paging_eDRXInfoIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NB_IoT_Paging_eDRXInfoIE_Extensions(pub Vec<NB_IoT_Paging_eDRXInfoIE_Extensions_Entry>);
impl entropic::Entropic for NB_IoT_Paging_eDRXInfoIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NB_IoT_Paging_eDRXInfoIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(NB_IoT_Paging_eDRXInfoIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGRAN_CGI_choice_Extensions {}
impl entropic::Entropic for NGRAN_CGI_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGRAN_TNLAssociationToRemoveItemIE_Extensions_Entry {}
impl entropic::Entropic for NGRAN_TNLAssociationToRemoveItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NGRAN_TNLAssociationToRemoveItemIE_Extensions(
    pub Vec<NGRAN_TNLAssociationToRemoveItemIE_Extensions_Entry>,
);
impl entropic::Entropic for NGRAN_TNLAssociationToRemoveItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                NGRAN_TNLAssociationToRemoveItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(NGRAN_TNLAssociationToRemoveItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NGResetProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 88)]
    Id_ResetType(ResetType),
}
impl asn1_codecs::Asn1Choice for NGResetProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_ResetType(_) => 88u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGResetProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGResetProtocolIEs_EntryValue,
}
impl entropic::Entropic for NGResetProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: NGResetProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGResetProtocolIEs(pub Vec<NGResetProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NGResetAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_UE_associatedLogicalNG_connectionList(UE_associatedLogicalNG_connectionList),
}
impl asn1_codecs::Asn1Choice for NGResetAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_UE_associatedLogicalNG_connectionList(_) => 111u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGResetAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGResetAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for NGResetAcknowledgeProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: NGResetAcknowledgeProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGResetAcknowledgeProtocolIEs(pub Vec<NGResetAcknowledgeProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NGSetupFailureProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 107)]
    Id_TimeToWait(TimeToWait),
}
impl asn1_codecs::Asn1Choice for NGSetupFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_TimeToWait(_) => 107u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGSetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGSetupFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for NGSetupFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: NGSetupFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGSetupFailureProtocolIEs(pub Vec<NGSetupFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NGSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 21)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 273)]
    Id_Extended_RANNodeName(Extended_RANNodeName),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 204)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 82)]
    Id_RANNodeName(RANNodeName),
    #[asn(key = 102)]
    Id_SupportedTAList(SupportedTAList),
    #[asn(key = 147)]
    Id_UERetentionInformation(UERetentionInformation),
}
impl asn1_codecs::Asn1Choice for NGSetupRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DefaultPagingDRX(_) => 21u128.try_into().unwrap(),
            Self::Id_Extended_RANNodeName(_) => 273u128.try_into().unwrap(),
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_NB_IoT_DefaultPagingDRX(_) => 204u128.try_into().unwrap(),
            Self::Id_RANNodeName(_) => 82u128.try_into().unwrap(),
            Self::Id_SupportedTAList(_) => 102u128.try_into().unwrap(),
            Self::Id_UERetentionInformation(_) => 147u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGSetupRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for NGSetupRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: NGSetupRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGSetupRequestProtocolIEs(pub Vec<NGSetupRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NGSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 1)]
    Id_AMFName(AMFName),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 274)]
    Id_Extended_AMFName(Extended_AMFName),
    #[asn(key = 200)]
    Id_IAB_Supported(IAB_Supported),
    #[asn(key = 80)]
    Id_PLMNSupportList(PLMNSupportList),
    #[asn(key = 86)]
    Id_RelativeAMFCapacity(RelativeAMFCapacity),
    #[asn(key = 96)]
    Id_ServedGUAMIList(ServedGUAMIList),
    #[asn(key = 147)]
    Id_UERetentionInformation(UERetentionInformation),
}
impl asn1_codecs::Asn1Choice for NGSetupResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMFName(_) => 1u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_Extended_AMFName(_) => 274u128.try_into().unwrap(),
            Self::Id_IAB_Supported(_) => 200u128.try_into().unwrap(),
            Self::Id_PLMNSupportList(_) => 80u128.try_into().unwrap(),
            Self::Id_RelativeAMFCapacity(_) => 86u128.try_into().unwrap(),
            Self::Id_ServedGUAMIList(_) => 96u128.try_into().unwrap(),
            Self::Id_UERetentionInformation(_) => 147u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGSetupResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for NGSetupResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: NGSetupResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGSetupResponseProtocolIEs(pub Vec<NGSetupResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_AccessInformation_choice_Extensions {}
impl entropic::Entropic for NPN_AccessInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_MobilityInformation_choice_Extensions {}
impl entropic::Entropic for NPN_MobilityInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_PagingAssistanceInformation_choice_Extensions {}
impl entropic::Entropic for NPN_PagingAssistanceInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_Support_choice_Extensions {}
impl entropic::Entropic for NPN_Support_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NR_CGIIE_Extensions_Entry {}
impl entropic::Entropic for NR_CGIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NR_CGIIE_Extensions(pub Vec<NR_CGIIE_Extensions_Entry>);
impl entropic::Entropic for NR_CGIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NR_CGIIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(NR_CGIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRFrequencyBandItemIE_Extension_Entry {}
impl entropic::Entropic for NRFrequencyBandItemIE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRFrequencyBandItemIE_Extension(pub Vec<NRFrequencyBandItemIE_Extension_Entry>);
impl entropic::Entropic for NRFrequencyBandItemIE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NRFrequencyBandItemIE_Extension_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(NRFrequencyBandItemIE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRFrequencyInfoIE_Extension_Entry {}
impl entropic::Entropic for NRFrequencyInfoIE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRFrequencyInfoIE_Extension(pub Vec<NRFrequencyInfoIE_Extension_Entry>);
impl entropic::Entropic for NRFrequencyInfoIE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NRFrequencyInfoIE_Extension_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(NRFrequencyInfoIE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}
impl entropic::Entropic for NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl entropic::Entropic for NRUESidelinkAggregateMaximumBitrateIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(NRUESidelinkAggregateMaximumBitrateIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRV2XServicesAuthorizedIE_Extensions_Entry {}
impl entropic::Entropic for NRV2XServicesAuthorizedIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRV2XServicesAuthorizedIE_Extensions(
    pub Vec<NRV2XServicesAuthorizedIE_Extensions_Entry>,
);
impl entropic::Entropic for NRV2XServicesAuthorizedIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NRV2XServicesAuthorizedIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(NRV2XServicesAuthorizedIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct NgENB_ID_macroNgENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NgENB_ID_macroNgENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(20, 16383);
        let total_bitlen = source.get_bounded_len(20..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(NgENB_ID_macroNgENB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 20);
        let capped_max = std::cmp::min(20, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(20..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "18", sz_ub = "18")]
pub struct NgENB_ID_shortMacroNgENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NgENB_ID_shortMacroNgENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(18, 16383);
        let total_bitlen = source.get_bounded_len(18..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(NgENB_ID_shortMacroNgENB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 18);
        let capped_max = std::cmp::min(18, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(18..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "21", sz_ub = "21")]
pub struct NgENB_ID_longMacroNgENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NgENB_ID_longMacroNgENB_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(21, 16383);
        let total_bitlen = source.get_bounded_len(21..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(NgENB_ID_longMacroNgENB_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 21);
        let capped_max = std::cmp::min(21, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(21..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NgENB_ID_choice_Extensions {}
impl entropic::Entropic for NgENB_ID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NonDynamic5QIDescriptorIE_Extensions_EntryExtensionValue {
    #[asn(key = 187)]
    Id_CNPacketDelayBudgetDL(ExtendedPacketDelayBudget),
    #[asn(key = 188)]
    Id_CNPacketDelayBudgetUL(ExtendedPacketDelayBudget),
}
impl asn1_codecs::Asn1Choice for NonDynamic5QIDescriptorIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CNPacketDelayBudgetDL(_) => 187u128.try_into().unwrap(),
            Self::Id_CNPacketDelayBudgetUL(_) => 188u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NonDynamic5QIDescriptorIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: NonDynamic5QIDescriptorIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for NonDynamic5QIDescriptorIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: NonDynamic5QIDescriptorIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NonDynamic5QIDescriptorIE_Extensions(
    pub Vec<NonDynamic5QIDescriptorIE_Extensions_Entry>,
);
impl entropic::Entropic for NonDynamic5QIDescriptorIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NonDynamic5QIDescriptorIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(NonDynamic5QIDescriptorIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadResponse_choice_Extensions {}
impl entropic::Entropic for OverloadResponse_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum OverloadStartProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_AMFOverloadResponse(OverloadResponse),
    #[asn(key = 9)]
    Id_AMFTrafficLoadReductionIndication(TrafficLoadReductionIndication),
    #[asn(key = 49)]
    Id_OverloadStartNSSAIList(OverloadStartNSSAIList),
}
impl asn1_codecs::Asn1Choice for OverloadStartProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMFOverloadResponse(_) => 2u128.try_into().unwrap(),
            Self::Id_AMFTrafficLoadReductionIndication(_) => 9u128.try_into().unwrap(),
            Self::Id_OverloadStartNSSAIList(_) => 49u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: OverloadStartProtocolIEs_EntryValue,
}
impl entropic::Entropic for OverloadStartProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: OverloadStartProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStartProtocolIEs(pub Vec<OverloadStartProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStartNSSAIItemIE_Extensions_Entry {}
impl entropic::Entropic for OverloadStartNSSAIItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct OverloadStartNSSAIItemIE_Extensions(pub Vec<OverloadStartNSSAIItemIE_Extensions_Entry>);
impl entropic::Entropic for OverloadStartNSSAIItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(OverloadStartNSSAIItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(OverloadStartNSSAIItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStopProtocolIEs_Entry {}
impl entropic::Entropic for OverloadStopProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStopProtocolIEs(pub Vec<OverloadStopProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5FlowBitRatesIE_Extensions_Entry {}
impl entropic::Entropic for PC5FlowBitRatesIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5FlowBitRatesIE_Extensions(pub Vec<PC5FlowBitRatesIE_Extensions_Entry>);
impl entropic::Entropic for PC5FlowBitRatesIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5FlowBitRatesIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(PC5FlowBitRatesIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSFlowItemIE_Extensions_Entry {}
impl entropic::Entropic for PC5QoSFlowItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSFlowItemIE_Extensions(pub Vec<PC5QoSFlowItemIE_Extensions_Entry>);
impl entropic::Entropic for PC5QoSFlowItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5QoSFlowItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(PC5QoSFlowItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSParametersIE_Extensions_Entry {}
impl entropic::Entropic for PC5QoSParametersIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSParametersIE_Extensions(pub Vec<PC5QoSParametersIE_Extensions_Entry>);
impl entropic::Entropic for PC5QoSParametersIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5QoSParametersIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(PC5QoSParametersIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionAggregateMaximumBitRateIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionAggregateMaximumBitRateIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionAggregateMaximumBitRateIE_Extensions(
    pub Vec<PDUSessionAggregateMaximumBitRateIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionAggregateMaximumBitRateIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionAggregateMaximumBitRateIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionAggregateMaximumBitRateIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceAdmittedItemHandoverRequestAcknowledgeTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceAdmittedItemIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceAdmittedItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceAdmittedItemIE_Extensions(
    pub Vec<PDUSessionResourceAdmittedItemIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceAdmittedItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceAdmittedItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceAdmittedItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceFailedToModifyItemModCfmPDUSessionResourceModifyIndicationUnsuccessfulTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToModifyItemModCfmIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToModifyItemModCfmIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToModifyItemModCfmIE_Extensions(
    pub Vec<PDUSessionResourceFailedToModifyItemModCfmIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToModifyItemModCfmIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToModifyItemModCfmIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToModifyItemModCfmIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceFailedToModifyItemModResPDUSessionResourceModifyUnsuccessfulTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToModifyItemModResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToModifyItemModResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToModifyItemModResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToModifyItemModResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToModifyItemModResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToModifyItemModResIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToModifyItemModResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToResumeItemRESReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToResumeItemRESReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToResumeItemRESReqIE_Extensions(
    pub Vec<PDUSessionResourceFailedToResumeItemRESReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToResumeItemRESReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToResumeItemRESReqIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToResumeItemRESReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToResumeItemRESResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToResumeItemRESResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToResumeItemRESResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToResumeItemRESResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToResumeItemRESResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToResumeItemRESResIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToResumeItemRESResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceFailedToSetupItemCxtFailPDUSessionResourceSetupUnsuccessfulTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceFailedToSetupItemCxtResPDUSessionResourceSetupUnsuccessfulTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemCxtResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemCxtResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemCxtResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemCxtResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToSetupItemCxtResIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToSetupItemCxtResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceFailedToSetupItemHOAckHandoverResourceAllocationUnsuccessfulTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemHOAckIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemHOAckIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemHOAckIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemHOAckIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemHOAckIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToSetupItemHOAckIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToSetupItemHOAckIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceFailedToSetupItemPSReqPathSwitchRequestSetupFailedTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemPSReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemPSReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemPSReqIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemPSReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemPSReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToSetupItemPSReqIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToSetupItemPSReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceFailedToSetupItemSUResPDUSessionResourceSetupUnsuccessfulTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemSUResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemSUResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemSUResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemSUResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceFailedToSetupItemSUResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceFailedToSetupItemSUResIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceFailedToSetupItemSUResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceHandoverItemHandoverCommandTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceHandoverItemIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceHandoverItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceHandoverItemIE_Extensions(
    pub Vec<PDUSessionResourceHandoverItemIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceHandoverItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceHandoverItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceHandoverItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceInformationItemIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceInformationItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceInformationItemIE_Extensions(
    pub Vec<PDUSessionResourceInformationItemIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceInformationItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceInformationItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceInformationItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub struct PDUSessionResourceItemCxtRelCplIE_Extensions_EntryExtensionValue;
impl asn1_codecs::Asn1Choice for PDUSessionResourceItemCxtRelCplIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        0u128.try_into().unwrap()
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceItemCxtRelCplIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceItemCxtRelCplIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceItemCxtRelCplIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: PDUSessionResourceItemCxtRelCplIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceItemCxtRelCplIE_Extensions(
    pub Vec<PDUSessionResourceItemCxtRelCplIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceItemCxtRelCplIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceItemCxtRelCplIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceItemCxtRelCplIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceItemCxtRelReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceItemCxtRelReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceItemCxtRelReqIE_Extensions(
    pub Vec<PDUSessionResourceItemCxtRelReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceItemCxtRelReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceItemCxtRelReqIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceItemCxtRelReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceItemHORqdHandoverRequiredTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceItemHORqdIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceItemHORqdIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceItemHORqdIE_Extensions(
    pub Vec<PDUSessionResourceItemHORqdIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceItemHORqdIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceItemHORqdIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceItemHORqdIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyConfirmProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 131)]
    Id_PDUSessionResourceFailedToModifyListModCfm(PDUSessionResourceFailedToModifyListModCfm),
    #[asn(key = 62)]
    Id_PDUSessionResourceModifyListModCfm(PDUSessionResourceModifyListModCfm),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceModifyConfirmProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToModifyListModCfm(_) => 131u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModifyListModCfm(_) => 62u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyConfirmProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceModifyConfirmProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceModifyConfirmProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyConfirmProtocolIEs(
    pub Vec<PDUSessionResourceModifyConfirmProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyConfirmTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 185)]
    Id_AdditionalRedundantNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice
    for PDUSessionResourceModifyConfirmTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRedundantNGU_UP_TNLInformation(_) => 185u128.try_into().unwrap(),
            Self::Id_RedundantUL_NGU_UP_TNLInformation(_) => 195u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyConfirmTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceModifyConfirmTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceModifyConfirmTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : PDUSessionResourceModifyConfirmTransferIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyConfirmTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyConfirmTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyConfirmTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyConfirmTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceModifyConfirmTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 63)]
    Id_PDUSessionResourceModifyListModInd(PDUSessionResourceModifyListModInd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceModifyIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModifyListModInd(_) => 63u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceModifyIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceModifyIndicationProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyIndicationProtocolIEs(
    pub Vec<PDUSessionResourceModifyIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyIndicationTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 193)]
    Id_RedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformation),
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
    #[asn(key = 156)]
    Id_SecurityResult(SecurityResult),
}
impl asn1_codecs::Asn1Choice
    for PDUSessionResourceModifyIndicationTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRedundantDLQosFlowPerTNLInformation(_) => {
                184u128.try_into().unwrap()
            }
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_RedundantDLQosFlowPerTNLInformation(_) => 193u128.try_into().unwrap(),
            Self::Id_SecondaryRATUsageInformation(_) => 144u128.try_into().unwrap(),
            Self::Id_SecurityResult(_) => 156u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyIndicationTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        PDUSessionResourceModifyIndicationTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceModifyIndicationTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : PDUSessionResourceModifyIndicationTransferIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyIndicationTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyIndicationTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyIndicationTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyIndicationTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceModifyIndicationTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions_Entry {}
impl entropic::Entropic
    for PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions_Entry
{
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceModifyItemModCfmPDUSessionResourceModifyConfirmTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModCfmIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceModifyItemModCfmIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModCfmIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModCfmIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyItemModCfmIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyItemModCfmIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceModifyItemModCfmIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceModifyItemModIndPDUSessionResourceModifyIndicationTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModIndIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceModifyItemModIndIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModIndIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModIndIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyItemModIndIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyItemModIndIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceModifyItemModIndIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceModifyItemModReqPDUSessionResourceModifyRequestTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyItemModReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
}
impl asn1_codecs::Asn1Choice
    for PDUSessionResourceModifyItemModReqIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_S_NSSAI(_) => 148u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceModifyItemModReqIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceModifyItemModReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: PDUSessionResourceModifyItemModReqIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModReqIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyItemModReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyItemModReqIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceModifyItemModReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceModifyItemModResPDUSessionResourceModifyResponseTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceModifyItemModResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModResIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyItemModResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyItemModResIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceModifyItemModResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 64)]
    Id_PDUSessionResourceModifyListModReq(PDUSessionResourceModifyListModReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceModifyRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModifyListModReq(_) => 64u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RANPagingPriority(_) => 83u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceModifyRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceModifyRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyRequestProtocolIEs(
    pub Vec<PDUSessionResourceModifyRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyRequestTransferProtocolIEs_EntryValue {
    #[asn(key = 186)]
    Id_AdditionalRedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 126)]
    Id_AdditionalUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 166)]
    Id_CommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 129)]
    Id_NetworkInstance(NetworkInstance),
    #[asn(key = 130)]
    Id_PDUSessionAggregateMaximumBitRate(PDUSessionAggregateMaximumBitRate),
    #[asn(key = 135)]
    Id_QosFlowAddOrModifyRequestList(QosFlowAddOrModifyRequestList),
    #[asn(key = 137)]
    Id_QosFlowToReleaseList(QosFlowListWithCause),
    #[asn(key = 190)]
    Id_RedundantCommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 138)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 140)]
    Id_UL_NGU_UP_TNLModifyList(UL_NGU_UP_TNLModifyList),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceModifyRequestTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRedundantUL_NGU_UP_TNLInformation(_) => 186u128.try_into().unwrap(),
            Self::Id_AdditionalUL_NGU_UP_TNLInformation(_) => 126u128.try_into().unwrap(),
            Self::Id_CommonNetworkInstance(_) => 166u128.try_into().unwrap(),
            Self::Id_NetworkInstance(_) => 129u128.try_into().unwrap(),
            Self::Id_PDUSessionAggregateMaximumBitRate(_) => 130u128.try_into().unwrap(),
            Self::Id_QosFlowAddOrModifyRequestList(_) => 135u128.try_into().unwrap(),
            Self::Id_QosFlowToReleaseList(_) => 137u128.try_into().unwrap(),
            Self::Id_RedundantCommonNetworkInstance(_) => 190u128.try_into().unwrap(),
            Self::Id_RedundantUL_NGU_UP_TNLInformation(_) => 195u128.try_into().unwrap(),
            Self::Id_SecurityIndication(_) => 138u128.try_into().unwrap(),
            Self::Id_UL_NGU_UP_TNLModifyList(_) => 140u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyRequestTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyRequestTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceModifyRequestTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceModifyRequestTransferProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyRequestTransferProtocolIEs(
    pub Vec<PDUSessionResourceModifyRequestTransferProtocolIEs_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyRequestTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyRequestTransferProtocolIEs_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceModifyRequestTransferProtocolIEs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 54)]
    Id_PDUSessionResourceFailedToModifyListModRes(PDUSessionResourceFailedToModifyListModRes),
    #[asn(key = 65)]
    Id_PDUSessionResourceModifyListModRes(PDUSessionResourceModifyListModRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceModifyResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToModifyListModRes(_) => 54u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModifyListModRes(_) => 65u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceModifyResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceModifyResponseProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyResponseProtocolIEs(
    pub Vec<PDUSessionResourceModifyResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyResponseTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 154)]
    Id_AdditionalNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 185)]
    Id_AdditionalRedundantNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice
    for PDUSessionResourceModifyResponseTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalNGU_UP_TNLInformation(_) => 154u128.try_into().unwrap(),
            Self::Id_AdditionalRedundantDLQosFlowPerTNLInformation(_) => {
                184u128.try_into().unwrap()
            }
            Self::Id_AdditionalRedundantNGU_UP_TNLInformation(_) => 185u128.try_into().unwrap(),
            Self::Id_RedundantDL_NGU_UP_TNLInformation(_) => 192u128.try_into().unwrap(),
            Self::Id_RedundantUL_NGU_UP_TNLInformation(_) => 195u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyResponseTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceModifyResponseTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceModifyResponseTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : PDUSessionResourceModifyResponseTransferIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyResponseTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyResponseTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyResponseTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceModifyResponseTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceModifyResponseTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceNotifyProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 66)]
    Id_PDUSessionResourceNotifyList(PDUSessionResourceNotifyList),
    #[asn(key = 67)]
    Id_PDUSessionResourceReleasedListNot(PDUSessionResourceReleasedListNot),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceNotifyProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceNotifyList(_) => 66u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceReleasedListNot(_) => 67u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceNotifyProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceNotifyProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceNotifyProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyProtocolIEs(pub Vec<PDUSessionResourceNotifyProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceNotifyItemPDUSessionResourceNotifyTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyItemIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceNotifyItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyItemIE_Extensions(
    pub Vec<PDUSessionResourceNotifyItemIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceNotifyItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceNotifyItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceNotifyItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceNotifyReleasedTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
}
impl asn1_codecs::Asn1Choice
    for PDUSessionResourceNotifyReleasedTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SecondaryRATUsageInformation(_) => 144u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyReleasedTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceNotifyReleasedTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceNotifyReleasedTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : PDUSessionResourceNotifyReleasedTransferIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyReleasedTransferIE_Extensions(
    pub Vec<PDUSessionResourceNotifyReleasedTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceNotifyReleasedTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceNotifyReleasedTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceNotifyReleasedTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceNotifyTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 278)]
    Id_QosFlowFeedbackList(QosFlowFeedbackList),
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceNotifyTransferIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_QosFlowFeedbackList(_) => 278u128.try_into().unwrap(),
            Self::Id_SecondaryRATUsageInformation(_) => 144u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceNotifyTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceNotifyTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: PDUSessionResourceNotifyTransferIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyTransferIE_Extensions(
    pub Vec<PDUSessionResourceNotifyTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceNotifyTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceNotifyTransferIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceNotifyTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 79)]
    Id_PDUSessionResourceToReleaseListRelCmd(PDUSessionResourceToReleaseListRelCmd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceReleaseCommandProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 38u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceToReleaseListRelCmd(_) => 79u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RANPagingPriority(_) => 83u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceReleaseCommandProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceReleaseCommandProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceReleaseCommandProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseCommandProtocolIEs(
    pub Vec<PDUSessionResourceReleaseCommandProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseCommandTransferIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceReleaseCommandTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseCommandTransferIE_Extensions(
    pub Vec<PDUSessionResourceReleaseCommandTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceReleaseCommandTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceReleaseCommandTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceReleaseCommandTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceReleaseResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 70)]
    Id_PDUSessionResourceReleasedListRelRes(PDUSessionResourceReleasedListRelRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceReleaseResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceReleasedListRelRes(_) => 70u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceReleaseResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceReleaseResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceReleaseResponseProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseResponseProtocolIEs(
    pub Vec<PDUSessionResourceReleaseResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceReleaseResponseTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
}
impl asn1_codecs::Asn1Choice
    for PDUSessionResourceReleaseResponseTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SecondaryRATUsageInformation(_) => 144u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseResponseTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceReleaseResponseTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceReleaseResponseTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : PDUSessionResourceReleaseResponseTransferIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseResponseTransferIE_Extensions(
    pub Vec<PDUSessionResourceReleaseResponseTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceReleaseResponseTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceReleaseResponseTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceReleaseResponseTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceReleasedItemNotPDUSessionResourceNotifyReleasedTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemNotIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceReleasedItemNotIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemNotIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemNotIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceReleasedItemNotIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceReleasedItemNotIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceReleasedItemNotIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceReleasedItemPSAckPathSwitchRequestUnsuccessfulTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemPSAckIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceReleasedItemPSAckIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemPSAckIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemPSAckIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceReleasedItemPSAckIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceReleasedItemPSAckIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceReleasedItemPSAckIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceReleasedItemPSFailPathSwitchRequestUnsuccessfulTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemPSFailIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceReleasedItemPSFailIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemPSFailIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemPSFailIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceReleasedItemPSFailIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceReleasedItemPSFailIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceReleasedItemPSFailIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceReleasedItemRelResPDUSessionResourceReleaseResponseTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemRelResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceReleasedItemRelResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemRelResIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemRelResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceReleasedItemRelResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceReleasedItemRelResIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceReleasedItemRelResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceResumeItemRESReqUEContextResumeRequestTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceResumeItemRESReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceResumeItemRESReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceResumeItemRESReqIE_Extensions(
    pub Vec<PDUSessionResourceResumeItemRESReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceResumeItemRESReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceResumeItemRESReqIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceResumeItemRESReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceResumeItemRESResUEContextResumeResponseTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceResumeItemRESResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceResumeItemRESResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceResumeItemRESResIE_Extensions(
    pub Vec<PDUSessionResourceResumeItemRESResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceResumeItemRESResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceResumeItemRESResIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceResumeItemRESResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSecondaryRATUsageItemSecondaryRATDataUsageReportTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSecondaryRATUsageItemIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSecondaryRATUsageItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSecondaryRATUsageItemIE_Extensions(
    pub Vec<PDUSessionResourceSecondaryRATUsageItemIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSecondaryRATUsageItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSecondaryRATUsageItemIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceSecondaryRATUsageItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSetupItemCxtReqPDUSessionResourceSetupRequestTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemCxtReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSetupItemCxtReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemCxtReqIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemCxtReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupItemCxtReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSetupItemCxtReqIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceSetupItemCxtReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSetupItemCxtResPDUSessionResourceSetupResponseTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemCxtResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSetupItemCxtResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemCxtResIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemCxtResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupItemCxtResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSetupItemCxtResIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceSetupItemCxtResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSetupItemHOReqHandoverRequestTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemHOReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSetupItemHOReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemHOReqIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemHOReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupItemHOReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSetupItemHOReqIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceSetupItemHOReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSetupItemSUReqPDUSessionResourceSetupRequestTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemSUReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSetupItemSUReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemSUReqIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemSUReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupItemSUReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSetupItemSUReqIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceSetupItemSUReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSetupItemSUResPDUSessionResourceSetupResponseTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemSUResIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSetupItemSUResIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemSUResIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemSUResIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupItemSUResIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSetupItemSUResIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(PDUSessionResourceSetupItemSUResIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 74)]
    Id_PDUSessionResourceSetupListSUReq(PDUSessionResourceSetupListSUReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceSetupRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 38u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSetupListSUReq(_) => 74u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RANPagingPriority(_) => 83u128.try_into().unwrap(),
            Self::Id_UEAggregateMaximumBitRate(_) => 110u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceSetupRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceSetupRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceSetupRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupRequestProtocolIEs(
    pub Vec<PDUSessionResourceSetupRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupRequestTransferProtocolIEs_EntryValue {
    #[asn(key = 186)]
    Id_AdditionalRedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 126)]
    Id_AdditionalUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 166)]
    Id_CommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 127)]
    Id_DataForwardingNotPossible(DataForwardingNotPossible),
    #[asn(key = 22)]
    Id_DirectForwardingPathAvailability(DirectForwardingPathAvailability),
    #[asn(key = 129)]
    Id_NetworkInstance(NetworkInstance),
    #[asn(key = 130)]
    Id_PDUSessionAggregateMaximumBitRate(PDUSessionAggregateMaximumBitRate),
    #[asn(key = 134)]
    Id_PDUSessionType(PDUSessionType),
    #[asn(key = 136)]
    Id_QosFlowSetupRequestList(QosFlowSetupRequestList),
    #[asn(key = 190)]
    Id_RedundantCommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 197)]
    Id_RedundantPDUSessionInformation(RedundantPDUSessionInformation),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 138)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 139)]
    Id_UL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceSetupRequestTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRedundantUL_NGU_UP_TNLInformation(_) => 186u128.try_into().unwrap(),
            Self::Id_AdditionalUL_NGU_UP_TNLInformation(_) => 126u128.try_into().unwrap(),
            Self::Id_CommonNetworkInstance(_) => 166u128.try_into().unwrap(),
            Self::Id_DataForwardingNotPossible(_) => 127u128.try_into().unwrap(),
            Self::Id_DirectForwardingPathAvailability(_) => 22u128.try_into().unwrap(),
            Self::Id_NetworkInstance(_) => 129u128.try_into().unwrap(),
            Self::Id_PDUSessionAggregateMaximumBitRate(_) => 130u128.try_into().unwrap(),
            Self::Id_PDUSessionType(_) => 134u128.try_into().unwrap(),
            Self::Id_QosFlowSetupRequestList(_) => 136u128.try_into().unwrap(),
            Self::Id_RedundantCommonNetworkInstance(_) => 190u128.try_into().unwrap(),
            Self::Id_RedundantPDUSessionInformation(_) => 197u128.try_into().unwrap(),
            Self::Id_RedundantUL_NGU_UP_TNLInformation(_) => 195u128.try_into().unwrap(),
            Self::Id_SecurityIndication(_) => 138u128.try_into().unwrap(),
            Self::Id_UL_NGU_UP_TNLInformation(_) => 139u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupRequestTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceSetupRequestTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceSetupRequestTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceSetupRequestTransferProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupRequestTransferProtocolIEs(
    pub Vec<PDUSessionResourceSetupRequestTransferProtocolIEs_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupRequestTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSetupRequestTransferProtocolIEs_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceSetupRequestTransferProtocolIEs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 58)]
    Id_PDUSessionResourceFailedToSetupListSURes(PDUSessionResourceFailedToSetupListSURes),
    #[asn(key = 75)]
    Id_PDUSessionResourceSetupListSURes(PDUSessionResourceSetupListSURes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for PDUSessionResourceSetupResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToSetupListSURes(_) => 58u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSetupListSURes(_) => 75u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceSetupResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for PDUSessionResourceSetupResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PDUSessionResourceSetupResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupResponseProtocolIEs(
    pub Vec<PDUSessionResourceSetupResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupResponseTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 193)]
    Id_RedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformation),
    #[asn(key = 198)]
    Id_UsedRSNInformation(RedundantPDUSessionInformation),
}
impl asn1_codecs::Asn1Choice
    for PDUSessionResourceSetupResponseTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRedundantDLQosFlowPerTNLInformation(_) => {
                184u128.try_into().unwrap()
            }
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_RedundantDLQosFlowPerTNLInformation(_) => 193u128.try_into().unwrap(),
            Self::Id_UsedRSNInformation(_) => 198u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupResponseTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceSetupResponseTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PDUSessionResourceSetupResponseTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : PDUSessionResourceSetupResponseTransferIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupResponseTransferIE_Extensions(
    pub Vec<PDUSessionResourceSetupResponseTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupResponseTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSetupResponseTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceSetupResponseTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions(
    pub Vec<PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSuspendItemSUSReqUEContextSuspendRequestTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSuspendItemSUSReqIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSuspendItemSUSReqIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSuspendItemSUSReqIE_Extensions(
    pub Vec<PDUSessionResourceSuspendItemSUSReqIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSuspendItemSUSReqIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceSuspendItemSUSReqIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceSuspendItemSUSReqIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceSwitchedItemPathSwitchRequestAcknowledgeTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSwitchedItemIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceSwitchedItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSwitchedItemIE_Extensions(
    pub Vec<PDUSessionResourceSwitchedItemIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceSwitchedItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionResourceSwitchedItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PDUSessionResourceSwitchedItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceToBeSwitchedDLItemPathSwitchRequestTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceToBeSwitchedDLItemIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceToBeSwitchedDLItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceToBeSwitchedDLItemIE_Extensions(
    pub Vec<PDUSessionResourceToBeSwitchedDLItemIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceToBeSwitchedDLItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceToBeSwitchedDLItemIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceToBeSwitchedDLItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceToReleaseItemHOCmdHandoverPreparationUnsuccessfulTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceToReleaseItemHOCmdIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceToReleaseItemHOCmdIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceToReleaseItemHOCmdIE_Extensions(
    pub Vec<PDUSessionResourceToReleaseItemHOCmdIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceToReleaseItemHOCmdIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceToReleaseItemHOCmdIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceToReleaseItemHOCmdIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct PDUSessionResourceToReleaseItemRelCmdPDUSessionResourceReleaseCommandTransfer(
    pub Vec<u8>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceToReleaseItemRelCmdIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionResourceToReleaseItemRelCmdIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceToReleaseItemRelCmdIE_Extensions(
    pub Vec<PDUSessionResourceToReleaseItemRelCmdIE_Extensions_Entry>,
);
impl entropic::Entropic for PDUSessionResourceToReleaseItemRelCmdIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PDUSessionResourceToReleaseItemRelCmdIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PDUSessionResourceToReleaseItemRelCmdIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PDUSessionUsageReportRATType(pub u8);
impl PDUSessionUsageReportRATType {
    pub const NR: u8 = 0u8;
    pub const EUTRA: u8 = 1u8;
}
impl entropic::Entropic for PDUSessionUsageReportRATType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PDUSessionUsageReportRATType(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionUsageReportIE_Extensions_Entry {}
impl entropic::Entropic for PDUSessionUsageReportIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionUsageReportIE_Extensions(pub Vec<PDUSessionUsageReportIE_Extensions_Entry>);
impl entropic::Entropic for PDUSessionUsageReportIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PDUSessionUsageReportIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PDUSessionUsageReportIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PLMNSupportItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 270)]
    Id_ExtendedSliceSupportList(ExtendedSliceSupportList),
    #[asn(key = 258)]
    Id_NPN_Support(NPN_Support),
}
impl asn1_codecs::Asn1Choice for PLMNSupportItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ExtendedSliceSupportList(_) => 270u128.try_into().unwrap(),
            Self::Id_NPN_Support(_) => 258u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMNSupportItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PLMNSupportItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PLMNSupportItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: PLMNSupportItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PLMNSupportItemIE_Extensions(pub Vec<PLMNSupportItemIE_Extensions_Entry>);
impl entropic::Entropic for PLMNSupportItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNSupportItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(PLMNSupportItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PNI_NPN_MobilityInformationIE_Extensions_Entry {}
impl entropic::Entropic for PNI_NPN_MobilityInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PNI_NPN_MobilityInformationIE_Extensions(
    pub Vec<PNI_NPN_MobilityInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for PNI_NPN_MobilityInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PNI_NPN_MobilityInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PNI_NPN_MobilityInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PWSCancelRequestProtocolIEs_EntryValue {
    #[asn(key = 14)]
    Id_CancelAllWarningMessages(CancelAllWarningMessages),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 122)]
    Id_WarningAreaList(WarningAreaList),
}
impl asn1_codecs::Asn1Choice for PWSCancelRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CancelAllWarningMessages(_) => 14u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 35u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 95u128.try_into().unwrap(),
            Self::Id_WarningAreaList(_) => 122u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSCancelRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSCancelRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for PWSCancelRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PWSCancelRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSCancelRequestProtocolIEs(pub Vec<PWSCancelRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PWSCancelResponseProtocolIEs_EntryValue {
    #[asn(key = 12)]
    Id_BroadcastCancelledAreaList(BroadcastCancelledAreaList),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
}
impl asn1_codecs::Asn1Choice for PWSCancelResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BroadcastCancelledAreaList(_) => 12u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 35u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 95u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSCancelResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSCancelResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for PWSCancelResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PWSCancelResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSCancelResponseProtocolIEs(pub Vec<PWSCancelResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSFailedCellIDList_choice_Extensions {}
impl entropic::Entropic for PWSFailedCellIDList_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PWSFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 81)]
    Id_PWSFailedCellIDList(PWSFailedCellIDList),
}
impl asn1_codecs::Asn1Choice for PWSFailureIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_PWSFailedCellIDList(_) => 81u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSFailureIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for PWSFailureIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PWSFailureIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSFailureIndicationProtocolIEs(pub Vec<PWSFailureIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PWSRestartIndicationProtocolIEs_EntryValue {
    #[asn(key = 16)]
    Id_CellIDListForRestart(CellIDListForRestart),
    #[asn(key = 23)]
    Id_EmergencyAreaIDListForRestart(EmergencyAreaIDListForRestart),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 104)]
    Id_TAIListForRestart(TAIListForRestart),
}
impl asn1_codecs::Asn1Choice for PWSRestartIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CellIDListForRestart(_) => 16u128.try_into().unwrap(),
            Self::Id_EmergencyAreaIDListForRestart(_) => 23u128.try_into().unwrap(),
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_TAIListForRestart(_) => 104u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSRestartIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSRestartIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for PWSRestartIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PWSRestartIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSRestartIndicationProtocolIEs(pub Vec<PWSRestartIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9", extensible = true)]
pub struct PacketErrorRatePERScalar(pub u8);
impl entropic::Entropic for PacketErrorRatePERScalar {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PacketErrorRatePERScalar(source.get_uniform_range(0..=9)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=9 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9", extensible = true)]
pub struct PacketErrorRatePERExponent(pub u8);
impl entropic::Entropic for PacketErrorRatePERExponent {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PacketErrorRatePERExponent(source.get_uniform_range(0..=9)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=9 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PacketErrorRateIE_Extensions_Entry {}
impl entropic::Entropic for PacketErrorRateIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PacketErrorRateIE_Extensions(pub Vec<PacketErrorRateIE_Extensions_Entry>);
impl entropic::Entropic for PacketErrorRateIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PacketErrorRateIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(PacketErrorRateIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PagingProtocolIEs_EntryValue {
    #[asn(key = 11)]
    Id_AssistanceDataForPaging(AssistanceDataForPaging),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 203)]
    Id_NB_IoT_Paging_eDRXInfo(NB_IoT_Paging_eDRXInfo),
    #[asn(key = 202)]
    Id_NB_IoT_PagingDRX(NB_IoT_PagingDRX),
    #[asn(key = 50)]
    Id_PagingDRX(PagingDRX),
    #[asn(key = 51)]
    Id_PagingOrigin(PagingOrigin),
    #[asn(key = 52)]
    Id_PagingPriority(PagingPriority),
    #[asn(key = 223)]
    Id_PagingeDRXInformation(PagingeDRXInformation),
    #[asn(key = 103)]
    Id_TAIListForPaging(TAIListForPaging),
    #[asn(key = 115)]
    Id_UEPagingIdentity(UEPagingIdentity),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 208)]
    Id_WUS_Assistance_Information(WUS_Assistance_Information),
}
impl asn1_codecs::Asn1Choice for PagingProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AssistanceDataForPaging(_) => 11u128.try_into().unwrap(),
            Self::Id_CEmodeBrestricted(_) => 222u128.try_into().unwrap(),
            Self::Id_Enhanced_CoverageRestriction(_) => 205u128.try_into().unwrap(),
            Self::Id_NB_IoT_Paging_eDRXInfo(_) => 203u128.try_into().unwrap(),
            Self::Id_NB_IoT_PagingDRX(_) => 202u128.try_into().unwrap(),
            Self::Id_PagingDRX(_) => 50u128.try_into().unwrap(),
            Self::Id_PagingOrigin(_) => 51u128.try_into().unwrap(),
            Self::Id_PagingPriority(_) => 52u128.try_into().unwrap(),
            Self::Id_PagingeDRXInformation(_) => 223u128.try_into().unwrap(),
            Self::Id_TAIListForPaging(_) => 103u128.try_into().unwrap(),
            Self::Id_UEPagingIdentity(_) => 115u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityForPaging(_) => 118u128.try_into().unwrap(),
            Self::Id_WUS_Assistance_Information(_) => 208u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PagingProtocolIEs_EntryValue,
}
impl entropic::Entropic for PagingProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PagingProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PagingProtocolIEs(pub Vec<PagingProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingAssisDataforCEcapabUEIE_Extensions_Entry {}
impl entropic::Entropic for PagingAssisDataforCEcapabUEIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingAssisDataforCEcapabUEIE_Extensions(
    pub Vec<PagingAssisDataforCEcapabUEIE_Extensions_Entry>,
);
impl entropic::Entropic for PagingAssisDataforCEcapabUEIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PagingAssisDataforCEcapabUEIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PagingAssisDataforCEcapabUEIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingAttemptInformationIE_Extensions_Entry {}
impl entropic::Entropic for PagingAttemptInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingAttemptInformationIE_Extensions(
    pub Vec<PagingAttemptInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for PagingAttemptInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PagingAttemptInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PagingAttemptInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingeDRXInformationIE_Extensions_Entry {}
impl entropic::Entropic for PagingeDRXInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingeDRXInformationIE_Extensions(pub Vec<PagingeDRXInformationIE_Extensions_Entry>);
impl entropic::Entropic for PagingeDRXInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PagingeDRXInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PagingeDRXInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestProtocolIEs_EntryValue {
    #[asn(key = 57)]
    Id_PDUSessionResourceFailedToSetupListPSReq(PDUSessionResourceFailedToSetupListPSReq),
    #[asn(key = 76)]
    Id_PDUSessionResourceToBeSwitchedDLList(PDUSessionResourceToBeSwitchedDLList),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 237)]
    Id_RRC_Resume_Cause(RRCEstablishmentCause),
    #[asn(key = 100)]
    Id_SourceAMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for PathSwitchRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_PDUSessionResourceFailedToSetupListPSReq(_) => 57u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceToBeSwitchedDLList(_) => 76u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RRC_Resume_Cause(_) => 237u128.try_into().unwrap(),
            Self::Id_SourceAMF_UE_NGAP_ID(_) => 100u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 119u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for PathSwitchRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PathSwitchRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestProtocolIEs(pub Vec<PathSwitchRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 41)]
    Id_NewSecurityContextInd(NewSecurityContextInd),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 68)]
    Id_PDUSessionResourceReleasedListPSAck(PDUSessionResourceReleasedListPSAck),
    #[asn(key = 77)]
    Id_PDUSessionResourceSwitchedList(PDUSessionResourceSwitchedList),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 146)]
    Id_RedirectionVoiceFallback(RedirectionVoiceFallback),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 234)]
    Id_UE_UP_CIoT_Support(UE_UP_CIoT_Support),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}
impl asn1_codecs::Asn1Choice for PathSwitchRequestAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_CEmodeBrestricted(_) => 222u128.try_into().unwrap(),
            Self::Id_CNAssistedRANTuning(_) => 165u128.try_into().unwrap(),
            Self::Id_CoreNetworkAssistanceInformationForInactive(_) => 18u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_Enhanced_CoverageRestriction(_) => 205u128.try_into().unwrap(),
            Self::Id_Extended_ConnectedTime(_) => 206u128.try_into().unwrap(),
            Self::Id_LTEUESidelinkAggregateMaximumBitrate(_) => 217u128.try_into().unwrap(),
            Self::Id_LTEV2XServicesAuthorized(_) => 215u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 218u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 216u128.try_into().unwrap(),
            Self::Id_NewSecurityContextInd(_) => 41u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 219u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceReleasedListPSAck(_) => 68u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSwitchedList(_) => 77u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RRCInactiveTransitionReportRequest(_) => 91u128.try_into().unwrap(),
            Self::Id_RedirectionVoiceFallback(_) => 146u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 177u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 93u128.try_into().unwrap(),
            Self::Id_UE_DifferentiationInfo(_) => 209u128.try_into().unwrap(),
            Self::Id_UE_UP_CIoT_Support(_) => 234u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 119u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for PathSwitchRequestAcknowledgeProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PathSwitchRequestAcknowledgeProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs(
    pub Vec<PathSwitchRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 154)]
    Id_AdditionalNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 185)]
    Id_AdditionalRedundantNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 277)]
    Id_QosFlowParametersList(QosFlowParametersList),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice
    for PathSwitchRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalNGU_UP_TNLInformation(_) => 154u128.try_into().unwrap(),
            Self::Id_AdditionalRedundantNGU_UP_TNLInformation(_) => 185u128.try_into().unwrap(),
            Self::Id_QosFlowParametersList(_) => 277u128.try_into().unwrap(),
            Self::Id_RedundantUL_NGU_UP_TNLInformation(_) => 195u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestAcknowledgeTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PathSwitchRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PathSwitchRequestAcknowledgeTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: PathSwitchRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestAcknowledgeTransferIE_Extensions(
    pub Vec<PathSwitchRequestAcknowledgeTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PathSwitchRequestAcknowledgeTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PathSwitchRequestAcknowledgeTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PathSwitchRequestAcknowledgeTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 69)]
    Id_PDUSessionResourceReleasedListPSFail(PDUSessionResourceReleasedListPSFail),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for PathSwitchRequestFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceReleasedListPSFail(_) => 69u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for PathSwitchRequestFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: PathSwitchRequestFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestFailureProtocolIEs(pub Vec<PathSwitchRequestFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestSetupFailedTransferIE_Extensions_Entry {}
impl entropic::Entropic for PathSwitchRequestSetupFailedTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestSetupFailedTransferIE_Extensions(
    pub Vec<PathSwitchRequestSetupFailedTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PathSwitchRequestSetupFailedTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PathSwitchRequestSetupFailedTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PathSwitchRequestSetupFailedTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 155)]
    Id_AdditionalDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 191)]
    Id_RedundantDL_NGU_TNLInformationReused(DL_NGU_TNLInformationReused),
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 198)]
    Id_UsedRSNInformation(RedundantPDUSessionInformation),
}
impl asn1_codecs::Asn1Choice for PathSwitchRequestTransferIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalDLQosFlowPerTNLInformation(_) => 155u128.try_into().unwrap(),
            Self::Id_AdditionalRedundantDLQosFlowPerTNLInformation(_) => {
                184u128.try_into().unwrap()
            }
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_RedundantDL_NGU_TNLInformationReused(_) => 191u128.try_into().unwrap(),
            Self::Id_RedundantDL_NGU_UP_TNLInformation(_) => 192u128.try_into().unwrap(),
            Self::Id_UsedRSNInformation(_) => 198u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PathSwitchRequestTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for PathSwitchRequestTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: PathSwitchRequestTransferIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestTransferIE_Extensions(
    pub Vec<PathSwitchRequestTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PathSwitchRequestTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PathSwitchRequestTransferIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(PathSwitchRequestTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestUnsuccessfulTransferIE_Extensions_Entry {}
impl entropic::Entropic for PathSwitchRequestUnsuccessfulTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestUnsuccessfulTransferIE_Extensions(
    pub Vec<PathSwitchRequestUnsuccessfulTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for PathSwitchRequestUnsuccessfulTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                PathSwitchRequestUnsuccessfulTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(PathSwitchRequestUnsuccessfulTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct PrivateIE_ID_local(pub u16);
impl entropic::Entropic for PrivateIE_ID_local {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(PrivateIE_ID_local(source.get_uniform_range(0..=65535)?))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OBJECT-IDENTIFIER")]
pub struct PrivateIE_ID_global(Vec<u32>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PrivateMessagePrivateIEs_Entry {}
impl entropic::Entropic for PrivateMessagePrivateIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PrivateMessagePrivateIEs(pub Vec<PrivateMessagePrivateIEs_Entry>);
impl entropic::Entropic for PrivateMessagePrivateIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PrivateMessagePrivateIEs_Entry::from_entropy_source(source)?);
        }
        Ok(PrivateMessagePrivateIEs(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProcedureStageChoice_choice_Extensions {}
impl entropic::Entropic for ProcedureStageChoice_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct QoSFlowsUsageReport_ItemRATType(pub u8);
impl QoSFlowsUsageReport_ItemRATType {
    pub const NR: u8 = 0u8;
    pub const EUTRA: u8 = 1u8;
}
impl entropic::Entropic for QoSFlowsUsageReport_ItemRATType {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(QoSFlowsUsageReport_ItemRATType(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QoSFlowsUsageReport_ItemIE_Extensions_Entry {}
impl entropic::Entropic for QoSFlowsUsageReport_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QoSFlowsUsageReport_ItemIE_Extensions(
    pub Vec<QoSFlowsUsageReport_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for QoSFlowsUsageReport_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QoSFlowsUsageReport_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QoSFlowsUsageReport_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosCharacteristics_choice_Extensions {}
impl entropic::Entropic for QosCharacteristics_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowAcceptedItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}
impl asn1_codecs::Asn1Choice for QosFlowAcceptedItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CurrentQoSParaSetIndex(_) => 221u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowAcceptedItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowAcceptedItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowAcceptedItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowAcceptedItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowAcceptedItemIE_Extensions(pub Vec<QosFlowAcceptedItemIE_Extensions_Entry>);
impl entropic::Entropic for QosFlowAcceptedItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowAcceptedItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(QosFlowAcceptedItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowAddOrModifyRequestItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 194)]
    Id_RedundantQosFlowIndicator(RedundantQosFlowIndicator),
    #[asn(key = 196)]
    Id_TSCTrafficCharacteristics(TSCTrafficCharacteristics),
}
impl asn1_codecs::Asn1Choice for QosFlowAddOrModifyRequestItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RedundantQosFlowIndicator(_) => 194u128.try_into().unwrap(),
            Self::Id_TSCTrafficCharacteristics(_) => 196u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowAddOrModifyRequestItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowAddOrModifyRequestItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowAddOrModifyRequestItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowAddOrModifyRequestItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowAddOrModifyRequestItemIE_Extensions(
    pub Vec<QosFlowAddOrModifyRequestItemIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowAddOrModifyRequestItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowAddOrModifyRequestItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowAddOrModifyRequestItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowAddOrModifyResponseItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}
impl asn1_codecs::Asn1Choice for QosFlowAddOrModifyResponseItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CurrentQoSParaSetIndex(_) => 221u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowAddOrModifyResponseItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowAddOrModifyResponseItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowAddOrModifyResponseItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowAddOrModifyResponseItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowAddOrModifyResponseItemIE_Extensions(
    pub Vec<QosFlowAddOrModifyResponseItemIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowAddOrModifyResponseItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowAddOrModifyResponseItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowAddOrModifyResponseItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowFeedbackItemIE_Extensions_Entry {}
impl entropic::Entropic for QosFlowFeedbackItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowFeedbackItemIE_Extensions(pub Vec<QosFlowFeedbackItemIE_Extensions_Entry>);
impl entropic::Entropic for QosFlowFeedbackItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowFeedbackItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(QosFlowFeedbackItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowInformationItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 163)]
    Id_ULForwarding(ULForwarding),
}
impl asn1_codecs::Asn1Choice for QosFlowInformationItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ULForwarding(_) => 163u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowInformationItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowInformationItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowInformationItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowInformationItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowInformationItemIE_Extensions(pub Vec<QosFlowInformationItemIE_Extensions_Entry>);
impl entropic::Entropic for QosFlowInformationItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowInformationItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowInformationItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowItemWithDataForwardingIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}
impl asn1_codecs::Asn1Choice for QosFlowItemWithDataForwardingIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CurrentQoSParaSetIndex(_) => 221u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowItemWithDataForwardingIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowItemWithDataForwardingIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowItemWithDataForwardingIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowItemWithDataForwardingIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowItemWithDataForwardingIE_Extensions(
    pub Vec<QosFlowItemWithDataForwardingIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowItemWithDataForwardingIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowItemWithDataForwardingIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowItemWithDataForwardingIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowLevelQosParametersIE_Extensions_EntryExtensionValue {
    #[asn(key = 276)]
    Id_QosMonitoringReportingFrequency(QosMonitoringReportingFrequency),
    #[asn(key = 181)]
    Id_QosMonitoringRequest(QosMonitoringRequest),
}
impl asn1_codecs::Asn1Choice for QosFlowLevelQosParametersIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_QosMonitoringReportingFrequency(_) => 276u128.try_into().unwrap(),
            Self::Id_QosMonitoringRequest(_) => 181u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowLevelQosParametersIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowLevelQosParametersIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowLevelQosParametersIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowLevelQosParametersIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowLevelQosParametersIE_Extensions(
    pub Vec<QosFlowLevelQosParametersIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowLevelQosParametersIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowLevelQosParametersIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowLevelQosParametersIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowModifyConfirmItemIE_Extensions_Entry {}
impl entropic::Entropic for QosFlowModifyConfirmItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowModifyConfirmItemIE_Extensions(
    pub Vec<QosFlowModifyConfirmItemIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowModifyConfirmItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowModifyConfirmItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowModifyConfirmItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowNotifyItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetNotifyIndex),
}
impl asn1_codecs::Asn1Choice for QosFlowNotifyItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CurrentQoSParaSetIndex(_) => 221u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowNotifyItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowNotifyItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowNotifyItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowNotifyItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowNotifyItemIE_Extensions(pub Vec<QosFlowNotifyItemIE_Extensions_Entry>);
impl entropic::Entropic for QosFlowNotifyItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowNotifyItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(QosFlowNotifyItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowParametersItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 279)]
    Id_BurstArrivalTimeDownlink(BurstArrivalTime),
    #[asn(key = 187)]
    Id_CNPacketDelayBudgetDL(ExtendedPacketDelayBudget),
    #[asn(key = 188)]
    Id_CNPacketDelayBudgetUL(ExtendedPacketDelayBudget),
}
impl asn1_codecs::Asn1Choice for QosFlowParametersItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BurstArrivalTimeDownlink(_) => 279u128.try_into().unwrap(),
            Self::Id_CNPacketDelayBudgetDL(_) => 187u128.try_into().unwrap(),
            Self::Id_CNPacketDelayBudgetUL(_) => 188u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowParametersItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowParametersItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowParametersItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowParametersItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowParametersItemIE_Extensions(pub Vec<QosFlowParametersItemIE_Extensions_Entry>);
impl entropic::Entropic for QosFlowParametersItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowParametersItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowParametersItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowPerTNLInformationIE_Extensions_Entry {}
impl entropic::Entropic for QosFlowPerTNLInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowPerTNLInformationIE_Extensions(
    pub Vec<QosFlowPerTNLInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowPerTNLInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowPerTNLInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowPerTNLInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowPerTNLInformationItemIE_Extensions_Entry {}
impl entropic::Entropic for QosFlowPerTNLInformationItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowPerTNLInformationItemIE_Extensions(
    pub Vec<QosFlowPerTNLInformationItemIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowPerTNLInformationItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowPerTNLInformationItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowPerTNLInformationItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowSetupRequestItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 194)]
    Id_RedundantQosFlowIndicator(RedundantQosFlowIndicator),
    #[asn(key = 196)]
    Id_TSCTrafficCharacteristics(TSCTrafficCharacteristics),
}
impl asn1_codecs::Asn1Choice for QosFlowSetupRequestItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RedundantQosFlowIndicator(_) => 194u128.try_into().unwrap(),
            Self::Id_TSCTrafficCharacteristics(_) => 196u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowSetupRequestItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowSetupRequestItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for QosFlowSetupRequestItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: QosFlowSetupRequestItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowSetupRequestItemIE_Extensions(
    pub Vec<QosFlowSetupRequestItemIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowSetupRequestItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowSetupRequestItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowSetupRequestItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowToBeForwardedItemIE_Extensions_Entry {}
impl entropic::Entropic for QosFlowToBeForwardedItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowToBeForwardedItemIE_Extensions(
    pub Vec<QosFlowToBeForwardedItemIE_Extensions_Entry>,
);
impl entropic::Entropic for QosFlowToBeForwardedItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowToBeForwardedItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowToBeForwardedItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowWithCauseItemIE_Extensions_Entry {}
impl entropic::Entropic for QosFlowWithCauseItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowWithCauseItemIE_Extensions(pub Vec<QosFlowWithCauseItemIE_Extensions_Entry>);
impl entropic::Entropic for QosFlowWithCauseItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(QosFlowWithCauseItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(QosFlowWithCauseItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RANCPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 25)]
    Id_EUTRA_CGI(EUTRA_CGI),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 213)]
    Id_TAI(TAI),
    #[asn(key = 211)]
    Id_UL_CP_SecurityInformation(UL_CP_SecurityInformation),
}
impl asn1_codecs::Asn1Choice for RANCPRelocationIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EUTRA_CGI(_) => 25u128.try_into().unwrap(),
            Self::Id_FiveG_S_TMSI(_) => 26u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_TAI(_) => 213u128.try_into().unwrap(),
            Self::Id_UL_CP_SecurityInformation(_) => 211u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANCPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANCPRelocationIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for RANCPRelocationIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: RANCPRelocationIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANCPRelocationIndicationProtocolIEs(
    pub Vec<RANCPRelocationIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RANConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 21)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 273)]
    Id_Extended_RANNodeName(Extended_RANNodeName),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 204)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 167)]
    Id_NGRAN_TNLAssociationToRemoveList(NGRAN_TNLAssociationToRemoveList),
    #[asn(key = 82)]
    Id_RANNodeName(RANNodeName),
    #[asn(key = 102)]
    Id_SupportedTAList(SupportedTAList),
}
impl asn1_codecs::Asn1Choice for RANConfigurationUpdateProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DefaultPagingDRX(_) => 21u128.try_into().unwrap(),
            Self::Id_Extended_RANNodeName(_) => 273u128.try_into().unwrap(),
            Self::Id_GlobalRANNodeID(_) => 27u128.try_into().unwrap(),
            Self::Id_NB_IoT_DefaultPagingDRX(_) => 204u128.try_into().unwrap(),
            Self::Id_NGRAN_TNLAssociationToRemoveList(_) => 167u128.try_into().unwrap(),
            Self::Id_RANNodeName(_) => 82u128.try_into().unwrap(),
            Self::Id_SupportedTAList(_) => 102u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANConfigurationUpdateProtocolIEs_EntryValue,
}
impl entropic::Entropic for RANConfigurationUpdateProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: RANConfigurationUpdateProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANConfigurationUpdateProtocolIEs(pub Vec<RANConfigurationUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}
impl asn1_codecs::Asn1Choice for RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for RANConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<RANConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RANConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 107)]
    Id_TimeToWait(TimeToWait),
}
impl asn1_codecs::Asn1Choice for RANConfigurationUpdateFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_TimeToWait(_) => 107u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANConfigurationUpdateFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for RANConfigurationUpdateFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: RANConfigurationUpdateFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANConfigurationUpdateFailureProtocolIEs(
    pub Vec<RANConfigurationUpdateFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANStatusTransfer_TransparentContainerIE_Extensions_Entry {}
impl entropic::Entropic for RANStatusTransfer_TransparentContainerIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RANStatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<RANStatusTransfer_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for RANStatusTransfer_TransparentContainerIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                RANStatusTransfer_TransparentContainerIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(RANStatusTransfer_TransparentContainerIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RATRestrictions_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 180)]
    Id_ExtendedRATRestrictionInformation(ExtendedRATRestrictionInformation),
}
impl asn1_codecs::Asn1Choice for RATRestrictions_ItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ExtendedRATRestrictionInformation(_) => 180u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RATRestrictions_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: RATRestrictions_ItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for RATRestrictions_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: RATRestrictions_ItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RATRestrictions_ItemIE_Extensions(pub Vec<RATRestrictions_ItemIE_Extensions_Entry>);
impl entropic::Entropic for RATRestrictions_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RATRestrictions_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(RATRestrictions_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RIMInformationRIM_RSDetection(pub u8);
impl RIMInformationRIM_RSDetection {
    pub const RS_DETECTED: u8 = 0u8;
    pub const RS_DISAPPEARED: u8 = 1u8;
}
impl entropic::Entropic for RIMInformationRIM_RSDetection {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RIMInformationRIM_RSDetection(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RIMInformationIE_Extensions_Entry {}
impl entropic::Entropic for RIMInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RIMInformationIE_Extensions(pub Vec<RIMInformationIE_Extensions_Entry>);
impl entropic::Entropic for RIMInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RIMInformationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(RIMInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RIMInformationTransferIE_Extensions_Entry {}
impl entropic::Entropic for RIMInformationTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RIMInformationTransferIE_Extensions(pub Vec<RIMInformationTransferIE_Extensions_Entry>);
impl entropic::Entropic for RIMInformationTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RIMInformationTransferIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(RIMInformationTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RRCInactiveTransitionReportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 92)]
    Id_RRCState(RRCState),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for RRCInactiveTransitionReportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RRCState(_) => 92u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCInactiveTransitionReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RRCInactiveTransitionReportProtocolIEs_EntryValue,
}
impl entropic::Entropic for RRCInactiveTransitionReportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: RRCInactiveTransitionReportProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RRCInactiveTransitionReportProtocolIEs(
    pub Vec<RRCInactiveTransitionReportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RecommendedCellItemTimeStayedInCell(pub u16);
impl entropic::Entropic for RecommendedCellItemTimeStayedInCell {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(RecommendedCellItemTimeStayedInCell(
            source.get_uniform_range(0..=4095)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellItemIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedCellItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellItemIE_Extensions(pub Vec<RecommendedCellItemIE_Extensions_Entry>);
impl entropic::Entropic for RecommendedCellItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedCellItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(RecommendedCellItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellsForPagingIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedCellsForPagingIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellsForPagingIE_Extensions(
    pub Vec<RecommendedCellsForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for RecommendedCellsForPagingIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedCellsForPagingIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(RecommendedCellsForPagingIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedRANNodeItemIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedRANNodeItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedRANNodeItemIE_Extensions(pub Vec<RecommendedRANNodeItemIE_Extensions_Entry>);
impl entropic::Entropic for RecommendedRANNodeItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedRANNodeItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(RecommendedRANNodeItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedRANNodesForPagingIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedRANNodesForPagingIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedRANNodesForPagingIE_Extensions(
    pub Vec<RecommendedRANNodesForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for RecommendedRANNodesForPagingIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedRANNodesForPagingIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(RecommendedRANNodesForPagingIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RedundantPDUSessionInformationIE_Extensions_Entry {}
impl entropic::Entropic for RedundantPDUSessionInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RedundantPDUSessionInformationIE_Extensions(
    pub Vec<RedundantPDUSessionInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for RedundantPDUSessionInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RedundantPDUSessionInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(RedundantPDUSessionInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RerouteNASRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 3)]
    Id_AMFSetID(AMFSetID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 171)]
    Id_SourceToTarget_AMFInformationReroute(SourceToTarget_AMFInformationReroute),
}
impl asn1_codecs::Asn1Choice for RerouteNASRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_AMFSetID(_) => 3u128.try_into().unwrap(),
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_SourceToTarget_AMFInformationReroute(_) => 171u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RerouteNASRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RerouteNASRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for RerouteNASRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: RerouteNASRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RerouteNASRequestProtocolIEs(pub Vec<RerouteNASRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetType_choice_Extensions {}
impl entropic::Entropic for ResetType_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RetrieveUEInformationProtocolIEs_EntryValue {
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
}
impl asn1_codecs::Asn1Choice for RetrieveUEInformationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_FiveG_S_TMSI(_) => 26u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RetrieveUEInformationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RetrieveUEInformationProtocolIEs_EntryValue,
}
impl entropic::Entropic for RetrieveUEInformationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: RetrieveUEInformationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RetrieveUEInformationProtocolIEs(pub Vec<RetrieveUEInformationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S_NSSAIIE_Extensions_Entry {}
impl entropic::Entropic for S_NSSAIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct S_NSSAIIE_Extensions(pub Vec<S_NSSAIIE_Extensions_Entry>);
impl entropic::Entropic for S_NSSAIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(S_NSSAIIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(S_NSSAIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SNPN_MobilityInformationIE_Extensions_Entry {}
impl entropic::Entropic for SNPN_MobilityInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SNPN_MobilityInformationIE_Extensions(
    pub Vec<SNPN_MobilityInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for SNPN_MobilityInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SNPN_MobilityInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(SNPN_MobilityInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONConfigurationTransferIE_Extensions_Entry {}
impl entropic::Entropic for SONConfigurationTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONConfigurationTransferIE_Extensions(
    pub Vec<SONConfigurationTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for SONConfigurationTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SONConfigurationTransferIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(SONConfigurationTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SONInformation_choice_ExtensionsValue {
    #[asn(key = 252)]
    Id_SONInformationReport(SONInformationReport),
}
impl asn1_codecs::Asn1Choice for SONInformation_choice_ExtensionsValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SONInformationReport(_) => 252u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformation_choice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SONInformation_choice_ExtensionsValue,
}
impl entropic::Entropic for SONInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: SONInformation_choice_ExtensionsValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformationReplyIE_Extensions_Entry {}
impl entropic::Entropic for SONInformationReplyIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONInformationReplyIE_Extensions(pub Vec<SONInformationReplyIE_Extensions_Entry>);
impl entropic::Entropic for SONInformationReplyIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SONInformationReplyIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SONInformationReplyIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformationReport_choice_Extensions {}
impl entropic::Entropic for SONInformationReport_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ScheduledCommunicationTimeDayofWeek(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ScheduledCommunicationTimeDayofWeek {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(7, 16383);
        let total_bitlen = source.get_bounded_len(7..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(ScheduledCommunicationTimeDayofWeek(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 7);
        let capped_max = std::cmp::min(7, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(7..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayStart(pub u32);
impl entropic::Entropic for ScheduledCommunicationTimeTimeofDayStart {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ScheduledCommunicationTimeTimeofDayStart(
            source.get_uniform_range(0..=86399)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=86399 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayEnd(pub u32);
impl entropic::Entropic for ScheduledCommunicationTimeTimeofDayEnd {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(ScheduledCommunicationTimeTimeofDayEnd(
            source.get_uniform_range(0..=86399)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=86399 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ScheduledCommunicationTimeIE_Extensions_Entry {}
impl entropic::Entropic for ScheduledCommunicationTimeIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ScheduledCommunicationTimeIE_Extensions(
    pub Vec<ScheduledCommunicationTimeIE_Extensions_Entry>,
);
impl entropic::Entropic for ScheduledCommunicationTimeIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ScheduledCommunicationTimeIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(ScheduledCommunicationTimeIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SecondaryRATDataUsageReportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 143)]
    Id_HandoverFlag(HandoverFlag),
    #[asn(key = 142)]
    Id_PDUSessionResourceSecondaryRATUsageList(PDUSessionResourceSecondaryRATUsageList),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for SecondaryRATDataUsageReportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_HandoverFlag(_) => 143u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSecondaryRATUsageList(_) => 142u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATDataUsageReportProtocolIEs_EntryValue,
}
impl entropic::Entropic for SecondaryRATDataUsageReportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: SecondaryRATDataUsageReportProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportProtocolIEs(
    pub Vec<SecondaryRATDataUsageReportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportTransferIE_Extensions_Entry {}
impl entropic::Entropic for SecondaryRATDataUsageReportTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportTransferIE_Extensions(
    pub Vec<SecondaryRATDataUsageReportTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for SecondaryRATDataUsageReportTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                SecondaryRATDataUsageReportTransferIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(SecondaryRATDataUsageReportTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATUsageInformationIE_Extension_Entry {}
impl entropic::Entropic for SecondaryRATUsageInformationIE_Extension_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecondaryRATUsageInformationIE_Extension(
    pub Vec<SecondaryRATUsageInformationIE_Extension_Entry>,
);
impl entropic::Entropic for SecondaryRATUsageInformationIE_Extension {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SecondaryRATUsageInformationIE_Extension_Entry::from_entropy_source(source)?);
        }
        Ok(SecondaryRATUsageInformationIE_Extension(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityContextIE_Extensions_Entry {}
impl entropic::Entropic for SecurityContextIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityContextIE_Extensions(pub Vec<SecurityContextIE_Extensions_Entry>);
impl entropic::Entropic for SecurityContextIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SecurityContextIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SecurityContextIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SecurityIndicationIE_Extensions_EntryExtensionValue {
    #[asn(key = 151)]
    Id_MaximumIntegrityProtectedDataRate_DL(MaximumIntegrityProtectedDataRate),
}
impl asn1_codecs::Asn1Choice for SecurityIndicationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MaximumIntegrityProtectedDataRate_DL(_) => 151u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityIndicationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SecurityIndicationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for SecurityIndicationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: SecurityIndicationIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityIndicationIE_Extensions(pub Vec<SecurityIndicationIE_Extensions_Entry>);
impl entropic::Entropic for SecurityIndicationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SecurityIndicationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SecurityIndicationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityResultIE_Extensions_Entry {}
impl entropic::Entropic for SecurityResultIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityResultIE_Extensions(pub Vec<SecurityResultIE_Extensions_Entry>);
impl entropic::Entropic for SecurityResultIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SecurityResultIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SecurityResultIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorMeasConfigNameItemIE_Extensions_Entry {}
impl entropic::Entropic for SensorMeasConfigNameItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SensorMeasConfigNameItemIE_Extensions(
    pub Vec<SensorMeasConfigNameItemIE_Extensions_Entry>,
);
impl entropic::Entropic for SensorMeasConfigNameItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SensorMeasConfigNameItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(SensorMeasConfigNameItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorMeasurementConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for SensorMeasurementConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SensorMeasurementConfigurationIE_Extensions(
    pub Vec<SensorMeasurementConfigurationIE_Extensions_Entry>,
);
impl entropic::Entropic for SensorMeasurementConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SensorMeasurementConfigurationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(SensorMeasurementConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SensorNameConfig_uncompensatedBarometricConfig(pub u8);
impl SensorNameConfig_uncompensatedBarometricConfig {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for SensorNameConfig_uncompensatedBarometricConfig {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SensorNameConfig_uncompensatedBarometricConfig(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SensorNameConfig_ueSpeedConfig(pub u8);
impl SensorNameConfig_ueSpeedConfig {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for SensorNameConfig_ueSpeedConfig {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SensorNameConfig_ueSpeedConfig(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SensorNameConfig_ueOrientationConfig(pub u8);
impl SensorNameConfig_ueOrientationConfig {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for SensorNameConfig_ueOrientationConfig {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(SensorNameConfig_ueOrientationConfig(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorNameConfig_choice_Extensions {}
impl entropic::Entropic for SensorNameConfig_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ServedGUAMIItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 176)]
    Id_GUAMIType(GUAMIType),
}
impl asn1_codecs::Asn1Choice for ServedGUAMIItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_GUAMIType(_) => 176u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedGUAMIItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ServedGUAMIItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for ServedGUAMIItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: ServedGUAMIItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedGUAMIItemIE_Extensions(pub Vec<ServedGUAMIItemIE_Extensions_Entry>);
impl entropic::Entropic for ServedGUAMIItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServedGUAMIItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(ServedGUAMIItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServiceAreaInformation_ItemIE_Extensions_Entry {}
impl entropic::Entropic for ServiceAreaInformation_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServiceAreaInformation_ItemIE_Extensions(
    pub Vec<ServiceAreaInformation_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for ServiceAreaInformation_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServiceAreaInformation_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(ServiceAreaInformation_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SliceOverloadItemIE_Extensions_Entry {}
impl entropic::Entropic for SliceOverloadItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SliceOverloadItemIE_Extensions(pub Vec<SliceOverloadItemIE_Extensions_Entry>);
impl entropic::Entropic for SliceOverloadItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SliceOverloadItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SliceOverloadItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SliceSupportItemIE_Extensions_Entry {}
impl entropic::Entropic for SliceSupportItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SliceSupportItemIE_Extensions(pub Vec<SliceSupportItemIE_Extensions_Entry>);
impl entropic::Entropic for SliceSupportItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SliceSupportItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SliceSupportItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 182)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 253)]
    Id_UEHistoryInformationFromTheUE(UEHistoryInformationFromTheUE),
}
impl asn1_codecs::Asn1Choice
    for SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SgNB_UE_X2AP_ID(_) => 182u128.try_into().unwrap(),
            Self::Id_UEHistoryInformationFromTheUE(_) => 253u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic
    for SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_Entry
{
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions(
    pub Vec<SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceRANNodeIDIE_Extensions_Entry {}
impl entropic::Entropic for SourceRANNodeIDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceRANNodeIDIE_Extensions(pub Vec<SourceRANNodeIDIE_Extensions_Entry>);
impl entropic::Entropic for SourceRANNodeIDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SourceRANNodeIDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SourceRANNodeIDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceToTarget_AMFInformationRerouteIE_Extensions_Entry {}
impl entropic::Entropic for SourceToTarget_AMFInformationRerouteIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceToTarget_AMFInformationRerouteIE_Extensions(
    pub Vec<SourceToTarget_AMFInformationRerouteIE_Extensions_Entry>,
);
impl entropic::Entropic for SourceToTarget_AMFInformationRerouteIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                SourceToTarget_AMFInformationRerouteIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(SourceToTarget_AMFInformationRerouteIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SuccessfulOutcomeValue {
    #[asn(key = 0)]
    Id_AMFConfigurationUpdate(AMFConfigurationUpdateAcknowledge),
    #[asn(key = 10)]
    Id_HandoverCancel(HandoverCancelAcknowledge),
    #[asn(key = 12)]
    Id_HandoverPreparation(HandoverCommand),
    #[asn(key = 13)]
    Id_HandoverResourceAllocation(HandoverRequestAcknowledge),
    #[asn(key = 14)]
    Id_InitialContextSetup(InitialContextSetupResponse),
    #[asn(key = 20)]
    Id_NGReset(NGResetAcknowledge),
    #[asn(key = 21)]
    Id_NGSetup(NGSetupResponse),
    #[asn(key = 26)]
    Id_PDUSessionResourceModify(PDUSessionResourceModifyResponse),
    #[asn(key = 27)]
    Id_PDUSessionResourceModifyIndication(PDUSessionResourceModifyConfirm),
    #[asn(key = 28)]
    Id_PDUSessionResourceRelease(PDUSessionResourceReleaseResponse),
    #[asn(key = 29)]
    Id_PDUSessionResourceSetup(PDUSessionResourceSetupResponse),
    #[asn(key = 32)]
    Id_PWSCancel(PWSCancelResponse),
    #[asn(key = 25)]
    Id_PathSwitchRequest(PathSwitchRequestAcknowledge),
    #[asn(key = 35)]
    Id_RANConfigurationUpdate(RANConfigurationUpdateAcknowledge),
    #[asn(key = 40)]
    Id_UEContextModification(UEContextModificationResponse),
    #[asn(key = 41)]
    Id_UEContextRelease(UEContextReleaseComplete),
    #[asn(key = 58)]
    Id_UEContextResume(UEContextResumeResponse),
    #[asn(key = 59)]
    Id_UEContextSuspend(UEContextSuspendResponse),
    #[asn(key = 43)]
    Id_UERadioCapabilityCheck(UERadioCapabilityCheckResponse),
    #[asn(key = 60)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingResponse),
    #[asn(key = 51)]
    Id_WriteReplaceWarning(WriteReplaceWarningResponse),
}
impl asn1_codecs::Asn1Choice for SuccessfulOutcomeValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMFConfigurationUpdate(_) => 0u128.try_into().unwrap(),
            Self::Id_HandoverCancel(_) => 10u128.try_into().unwrap(),
            Self::Id_HandoverPreparation(_) => 12u128.try_into().unwrap(),
            Self::Id_HandoverResourceAllocation(_) => 13u128.try_into().unwrap(),
            Self::Id_InitialContextSetup(_) => 14u128.try_into().unwrap(),
            Self::Id_NGReset(_) => 20u128.try_into().unwrap(),
            Self::Id_NGSetup(_) => 21u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModify(_) => 26u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceModifyIndication(_) => 27u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceRelease(_) => 28u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSetup(_) => 29u128.try_into().unwrap(),
            Self::Id_PWSCancel(_) => 32u128.try_into().unwrap(),
            Self::Id_PathSwitchRequest(_) => 25u128.try_into().unwrap(),
            Self::Id_RANConfigurationUpdate(_) => 35u128.try_into().unwrap(),
            Self::Id_UEContextModification(_) => 40u128.try_into().unwrap(),
            Self::Id_UEContextRelease(_) => 41u128.try_into().unwrap(),
            Self::Id_UEContextResume(_) => 58u128.try_into().unwrap(),
            Self::Id_UEContextSuspend(_) => 59u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityCheck(_) => 43u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityIDMapping(_) => 60u128.try_into().unwrap(),
            Self::Id_WriteReplaceWarning(_) => 51u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SupportedTAItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 272)]
    Id_ConfiguredTACIndication(ConfiguredTACIndication),
    #[asn(key = 179)]
    Id_RAT_Information(RAT_Information),
}
impl asn1_codecs::Asn1Choice for SupportedTAItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ConfiguredTACIndication(_) => 272u128.try_into().unwrap(),
            Self::Id_RAT_Information(_) => 179u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedTAItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SupportedTAItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for SupportedTAItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: SupportedTAItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SupportedTAItemIE_Extensions(pub Vec<SupportedTAItemIE_Extensions_Entry>);
impl entropic::Entropic for SupportedTAItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SupportedTAItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(SupportedTAItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedMDTIE_Extensions_Entry {}
impl entropic::Entropic for TABasedMDTIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedMDTIE_Extensions(pub Vec<TABasedMDTIE_Extensions_Entry>);
impl entropic::Entropic for TABasedMDTIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TABasedMDTIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TABasedMDTIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIIE_Extensions_Entry {}
impl entropic::Entropic for TAIIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIIE_Extensions(pub Vec<TAIIE_Extensions_Entry>);
impl entropic::Entropic for TAIIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TAIIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedMDTIE_Extensions_Entry {}
impl entropic::Entropic for TAIBasedMDTIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedMDTIE_Extensions(pub Vec<TAIBasedMDTIE_Extensions_Entry>);
impl entropic::Entropic for TAIBasedMDTIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIBasedMDTIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TAIBasedMDTIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBroadcastEUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for TAIBroadcastEUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastEUTRA_ItemIE_Extensions(pub Vec<TAIBroadcastEUTRA_ItemIE_Extensions_Entry>);
impl entropic::Entropic for TAIBroadcastEUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIBroadcastEUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TAIBroadcastEUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBroadcastNR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for TAIBroadcastNR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastNR_ItemIE_Extensions(pub Vec<TAIBroadcastNR_ItemIE_Extensions_Entry>);
impl entropic::Entropic for TAIBroadcastNR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIBroadcastNR_ItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(TAIBroadcastNR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAICancelledEUTRA_ItemIE_Extensions_Entry {}
impl entropic::Entropic for TAICancelledEUTRA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledEUTRA_ItemIE_Extensions(pub Vec<TAICancelledEUTRA_ItemIE_Extensions_Entry>);
impl entropic::Entropic for TAICancelledEUTRA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAICancelledEUTRA_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TAICancelledEUTRA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAICancelledNR_ItemIE_Extensions_Entry {}
impl entropic::Entropic for TAICancelledNR_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledNR_ItemIE_Extensions(pub Vec<TAICancelledNR_ItemIE_Extensions_Entry>);
impl entropic::Entropic for TAICancelledNR_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAICancelledNR_ItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(TAICancelledNR_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIListForInactiveItemIE_Extensions_Entry {}
impl entropic::Entropic for TAIListForInactiveItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListForInactiveItemIE_Extensions(pub Vec<TAIListForInactiveItemIE_Extensions_Entry>);
impl entropic::Entropic for TAIListForInactiveItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIListForInactiveItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TAIListForInactiveItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIListForPagingItemIE_Extensions_Entry {}
impl entropic::Entropic for TAIListForPagingItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListForPagingItemIE_Extensions(pub Vec<TAIListForPagingItemIE_Extensions_Entry>);
impl entropic::Entropic for TAIListForPagingItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIListForPagingItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TAIListForPagingItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "32", sz_ub = "32")]
pub struct TNGF_ID_tNGF_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for TNGF_ID_tNGF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(32..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(TNGF_ID_tNGF_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 32);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNGF_ID_choice_Extensions {}
impl entropic::Entropic for TNGF_ID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLAssociationItemIE_Extensions_Entry {}
impl entropic::Entropic for TNLAssociationItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLAssociationItemIE_Extensions(pub Vec<TNLAssociationItemIE_Extensions_Entry>);
impl entropic::Entropic for TNLAssociationItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TNLAssociationItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(TNLAssociationItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TSCAssistanceInformationIE_Extensions_Entry {}
impl entropic::Entropic for TSCAssistanceInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TSCAssistanceInformationIE_Extensions(
    pub Vec<TSCAssistanceInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for TSCAssistanceInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TSCAssistanceInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TSCAssistanceInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TSCTrafficCharacteristicsIE_Extensions_Entry {}
impl entropic::Entropic for TSCTrafficCharacteristicsIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TSCTrafficCharacteristicsIE_Extensions(
    pub Vec<TSCTrafficCharacteristicsIE_Extensions_Entry>,
);
impl entropic::Entropic for TSCTrafficCharacteristicsIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TSCTrafficCharacteristicsIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TSCTrafficCharacteristicsIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "32", sz_ub = "32")]
pub struct TWIF_ID_tWIF_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for TWIF_ID_tWIF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(32..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(TWIF_ID_tWIF_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 32);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TWIF_ID_choice_Extensions {}
impl entropic::Entropic for TWIF_ID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TargetID_choice_ExtensionsValue {
    #[asn(key = 178)]
    Id_TargetRNC_ID(TargetRNC_ID),
}
impl asn1_codecs::Asn1Choice for TargetID_choice_ExtensionsValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_TargetRNC_ID(_) => 178u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetID_choice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TargetID_choice_ExtensionsValue,
}
impl entropic::Entropic for TargetID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: TargetID_choice_ExtensionsValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions_Entry {}
impl entropic::Entropic
    for TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions_Entry
{
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions(
    pub Vec<TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic
    for TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions
{
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 267)]
    Id_DAPSResponseInfoList(DAPSResponseInfoList),
}
impl asn1_codecs::Asn1Choice
    for TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DAPSResponseInfoList(_) => 267u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic
    for TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_Entry
{
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value : TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue = source . get_entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions(
    pub Vec<TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_Entry :: from_entropy_source (source) ?) ;
        }
        Ok(TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetRANNodeIDIE_Extensions_Entry {}
impl entropic::Entropic for TargetRANNodeIDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetRANNodeIDIE_Extensions(pub Vec<TargetRANNodeIDIE_Extensions_Entry>);
impl entropic::Entropic for TargetRANNodeIDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TargetRANNodeIDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(TargetRANNodeIDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetRNC_IDIE_Extensions_Entry {}
impl entropic::Entropic for TargetRNC_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetRNC_IDIE_Extensions(pub Vec<TargetRNC_IDIE_Extensions_Entry>);
impl entropic::Entropic for TargetRNC_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TargetRNC_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(TargetRNC_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargeteNB_IDIE_Extensions_Entry {}
impl entropic::Entropic for TargeteNB_IDIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargeteNB_IDIE_Extensions(pub Vec<TargeteNB_IDIE_Extensions_Entry>);
impl entropic::Entropic for TargeteNB_IDIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TargeteNB_IDIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(TargeteNB_IDIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TooearlyIntersystemHOIE_Extensions_Entry {}
impl entropic::Entropic for TooearlyIntersystemHOIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TooearlyIntersystemHOIE_Extensions(pub Vec<TooearlyIntersystemHOIE_Extensions_Entry>);
impl entropic::Entropic for TooearlyIntersystemHOIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TooearlyIntersystemHOIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(TooearlyIntersystemHOIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TraceActivationIE_Extensions_EntryExtensionValue {
    #[asn(key = 255)]
    Id_MDTConfiguration(MDT_Configuration),
    #[asn(key = 257)]
    Id_TraceCollectionEntityURI(URI_address),
}
impl asn1_codecs::Asn1Choice for TraceActivationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MDTConfiguration(_) => 255u128.try_into().unwrap(),
            Self::Id_TraceCollectionEntityURI(_) => 257u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceActivationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: TraceActivationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for TraceActivationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: TraceActivationIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TraceActivationIE_Extensions(pub Vec<TraceActivationIE_Extensions_Entry>);
impl entropic::Entropic for TraceActivationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TraceActivationIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(TraceActivationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TraceFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 44)]
    Id_NGRANTraceID(NGRANTraceID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for TraceFailureIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_NGRANTraceID(_) => 44u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceFailureIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for TraceFailureIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: TraceFailureIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceFailureIndicationProtocolIEs(pub Vec<TraceFailureIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TraceStartProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 108)]
    Id_TraceActivation(TraceActivation),
}
impl asn1_codecs::Asn1Choice for TraceStartProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_TraceActivation(_) => 108u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceStartProtocolIEs_EntryValue,
}
impl entropic::Entropic for TraceStartProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: TraceStartProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceStartProtocolIEs(pub Vec<TraceStartProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct UE_DifferentiationInfoPeriodicCommunicationIndicator(pub u8);
impl UE_DifferentiationInfoPeriodicCommunicationIndicator {
    pub const PERIODICALLY: u8 = 0u8;
    pub const ONDEMAND: u8 = 1u8;
}
impl entropic::Entropic for UE_DifferentiationInfoPeriodicCommunicationIndicator {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UE_DifferentiationInfoPeriodicCommunicationIndicator(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3600", extensible = true)]
pub struct UE_DifferentiationInfoPeriodicTime(pub u16);
impl entropic::Entropic for UE_DifferentiationInfoPeriodicTime {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UE_DifferentiationInfoPeriodicTime(
            source.get_uniform_range(1..=3600)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=3600 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct UE_DifferentiationInfoStationaryIndication(pub u8);
impl UE_DifferentiationInfoStationaryIndication {
    pub const STATIONARY: u8 = 0u8;
    pub const MOBILE: u8 = 1u8;
}
impl entropic::Entropic for UE_DifferentiationInfoStationaryIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UE_DifferentiationInfoStationaryIndication(
            source.get_uniform_range(0..=1)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct UE_DifferentiationInfoTrafficProfile(pub u8);
impl UE_DifferentiationInfoTrafficProfile {
    pub const SINGLE_PACKET: u8 = 0u8;
    pub const DUAL_PACKETS: u8 = 1u8;
    pub const MULTIPLE_PACKETS: u8 = 2u8;
}
impl entropic::Entropic for UE_DifferentiationInfoTrafficProfile {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UE_DifferentiationInfoTrafficProfile(
            source.get_uniform_range(0..=2)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct UE_DifferentiationInfoBatteryIndication(pub u8);
impl UE_DifferentiationInfoBatteryIndication {
    pub const BATTERY_POWERED: u8 = 0u8;
    pub const BATTERY_POWERED_NOT_RECHARGEABLE_OR_REPLACEABLE: u8 = 1u8;
    pub const NOT_BATTERY_POWERED: u8 = 2u8;
}
impl entropic::Entropic for UE_DifferentiationInfoBatteryIndication {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(UE_DifferentiationInfoBatteryIndication(
            source.get_uniform_range(0..=2)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_DifferentiationInfoIE_Extensions_Entry {}
impl entropic::Entropic for UE_DifferentiationInfoIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_DifferentiationInfoIE_Extensions(pub Vec<UE_DifferentiationInfoIE_Extensions_Entry>);
impl entropic::Entropic for UE_DifferentiationInfoIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UE_DifferentiationInfoIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UE_DifferentiationInfoIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_NGAP_ID_pairIE_Extensions_Entry {}
impl entropic::Entropic for UE_NGAP_ID_pairIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_NGAP_ID_pairIE_Extensions(pub Vec<UE_NGAP_ID_pairIE_Extensions_Entry>);
impl entropic::Entropic for UE_NGAP_ID_pairIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UE_NGAP_ID_pairIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(UE_NGAP_ID_pairIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_NGAP_IDs_choice_Extensions {}
impl entropic::Entropic for UE_NGAP_IDs_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalNG_connectionItemIE_Extensions_Entry {}
impl entropic::Entropic for UE_associatedLogicalNG_connectionItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_associatedLogicalNG_connectionItemIE_Extensions(
    pub Vec<UE_associatedLogicalNG_connectionItemIE_Extensions_Entry>,
);
impl entropic::Entropic for UE_associatedLogicalNG_connectionItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UE_associatedLogicalNG_connectionItemIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(UE_associatedLogicalNG_connectionItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAggregateMaximumBitRateIE_Extensions_Entry {}
impl entropic::Entropic for UEAggregateMaximumBitRateIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAggregateMaximumBitRateIE_Extensions(
    pub Vec<UEAggregateMaximumBitRateIE_Extensions_Entry>,
);
impl entropic::Entropic for UEAggregateMaximumBitRateIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEAggregateMaximumBitRateIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UEAggregateMaximumBitRateIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextModificationFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextModificationFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationFailureProtocolIEs(
    pub Vec<UEContextModificationFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 24)]
    Id_EmergencyFallbackIndicator(EmergencyFallbackIndicator),
    #[asn(key = 199)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 31)]
    Id_IndexToRFSP(IndexToRFSP),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 40)]
    Id_NewAMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 162)]
    Id_NewGUAMI(GUAMI),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
    #[asn(key = 238)]
    Id_RGLevelWirelineAccessCharacteristics(RGLevelWirelineAccessCharacteristics),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 94)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}
impl asn1_codecs::Asn1Choice for UEContextModificationRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CNAssistedRANTuning(_) => 165u128.try_into().unwrap(),
            Self::Id_CoreNetworkAssistanceInformationForInactive(_) => 18u128.try_into().unwrap(),
            Self::Id_EmergencyFallbackIndicator(_) => 24u128.try_into().unwrap(),
            Self::Id_IAB_Authorized(_) => 199u128.try_into().unwrap(),
            Self::Id_IndexToRFSP(_) => 31u128.try_into().unwrap(),
            Self::Id_LTEUESidelinkAggregateMaximumBitrate(_) => 217u128.try_into().unwrap(),
            Self::Id_LTEV2XServicesAuthorized(_) => 215u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 218u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 216u128.try_into().unwrap(),
            Self::Id_NewAMF_UE_NGAP_ID(_) => 40u128.try_into().unwrap(),
            Self::Id_NewGUAMI(_) => 162u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 219u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RANPagingPriority(_) => 83u128.try_into().unwrap(),
            Self::Id_RGLevelWirelineAccessCharacteristics(_) => 238u128.try_into().unwrap(),
            Self::Id_RRCInactiveTransitionReportRequest(_) => 91u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 177u128.try_into().unwrap(),
            Self::Id_SecurityKey(_) => 94u128.try_into().unwrap(),
            Self::Id_UEAggregateMaximumBitRate(_) => 110u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 119u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextModificationRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationRequestProtocolIEs(
    pub Vec<UEContextModificationRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 92)]
    Id_RRCState(RRCState),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for UEContextModificationResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RRCState(_) => 92u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextModificationResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationResponseProtocolIEs(
    pub Vec<UEContextModificationResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 114)]
    Id_UE_NGAP_IDs(UE_NGAP_IDs),
}
impl asn1_codecs::Asn1Choice for UEContextReleaseCommandProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_UE_NGAP_IDs(_) => 114u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCommandProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextReleaseCommandProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextReleaseCommandProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCommandProtocolIEs(pub Vec<UEContextReleaseCommandProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCompleteProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 32)]
    Id_InfoOnRecommendedCellsAndRANNodesForPaging(InfoOnRecommendedCellsAndRANNodesForPaging),
    #[asn(key = 60)]
    Id_PDUSessionResourceListCxtRelCpl(PDUSessionResourceListCxtRelCpl),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for UEContextReleaseCompleteProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_InfoOnRecommendedCellsAndRANNodesForPaging(_) => 32u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceListCxtRelCpl(_) => 60u128.try_into().unwrap(),
            Self::Id_PagingAssisDataforCEcapabUE(_) => 207u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCompleteProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCompleteProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextReleaseCompleteProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextReleaseCompleteProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCompleteProtocolIEs(pub Vec<UEContextReleaseCompleteProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 133)]
    Id_PDUSessionResourceListCxtRelReq(PDUSessionResourceListCxtRelReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextReleaseRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceListCxtRelReq(_) => 133u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextReleaseRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextReleaseRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseRequestProtocolIEs(pub Vec<UEContextReleaseRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextResumeFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextResumeFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextResumeFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeFailureProtocolIEs(pub Vec<UEContextResumeFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 32)]
    Id_InfoOnRecommendedCellsAndRANNodesForPaging(InfoOnRecommendedCellsAndRANNodesForPaging),
    #[asn(key = 229)]
    Id_PDUSessionResourceFailedToResumeListRESReq(PDUSessionResourceFailedToResumeListRESReq),
    #[asn(key = 232)]
    Id_PDUSessionResourceResumeListRESReq(PDUSessionResourceResumeListRESReq),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 237)]
    Id_RRC_Resume_Cause(RRCEstablishmentCause),
    #[asn(key = 235)]
    Id_Suspend_Request_Indication(Suspend_Request_Indication),
}
impl asn1_codecs::Asn1Choice for UEContextResumeRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_InfoOnRecommendedCellsAndRANNodesForPaging(_) => 32u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToResumeListRESReq(_) => 229u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceResumeListRESReq(_) => 232u128.try_into().unwrap(),
            Self::Id_PagingAssisDataforCEcapabUE(_) => 207u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RRC_Resume_Cause(_) => 237u128.try_into().unwrap(),
            Self::Id_Suspend_Request_Indication(_) => 235u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextResumeRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextResumeRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeRequestProtocolIEs(pub Vec<UEContextResumeRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeRequestTransferIE_Extensions_Entry {}
impl entropic::Entropic for UEContextResumeRequestTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEContextResumeRequestTransferIE_Extensions(
    pub Vec<UEContextResumeRequestTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for UEContextResumeRequestTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextResumeRequestTransferIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UEContextResumeRequestTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 230)]
    Id_PDUSessionResourceFailedToResumeListRESRes(PDUSessionResourceFailedToResumeListRESRes),
    #[asn(key = 233)]
    Id_PDUSessionResourceResumeListRESRes(PDUSessionResourceResumeListRESRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 236)]
    Id_Suspend_Response_Indication(Suspend_Response_Indication),
}
impl asn1_codecs::Asn1Choice for UEContextResumeResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_Extended_ConnectedTime(_) => 206u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceFailedToResumeListRESRes(_) => 230u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceResumeListRESRes(_) => 233u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 93u128.try_into().unwrap(),
            Self::Id_Suspend_Response_Indication(_) => 236u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextResumeResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextResumeResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeResponseProtocolIEs(pub Vec<UEContextResumeResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeResponseTransferIE_Extensions_Entry {}
impl entropic::Entropic for UEContextResumeResponseTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEContextResumeResponseTransferIE_Extensions(
    pub Vec<UEContextResumeResponseTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for UEContextResumeResponseTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UEContextResumeResponseTransferIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(UEContextResumeResponseTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextSuspendFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_Cause(_) => 15u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextSuspendFailureProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextSuspendFailureProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendFailureProtocolIEs(pub Vec<UEContextSuspendFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 32)]
    Id_InfoOnRecommendedCellsAndRANNodesForPaging(InfoOnRecommendedCellsAndRANNodesForPaging),
    #[asn(key = 231)]
    Id_PDUSessionResourceSuspendListSUSReq(PDUSessionResourceSuspendListSUSReq),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextSuspendRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_InfoOnRecommendedCellsAndRANNodesForPaging(_) => 32u128.try_into().unwrap(),
            Self::Id_PDUSessionResourceSuspendListSUSReq(_) => 231u128.try_into().unwrap(),
            Self::Id_PagingAssisDataforCEcapabUE(_) => 207u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextSuspendRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextSuspendRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendRequestProtocolIEs(pub Vec<UEContextSuspendRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendRequestTransferIE_Extensions_Entry {}
impl entropic::Entropic for UEContextSuspendRequestTransferIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEContextSuspendRequestTransferIE_Extensions(
    pub Vec<UEContextSuspendRequestTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for UEContextSuspendRequestTransferIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UEContextSuspendRequestTransferIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(UEContextSuspendRequestTransferIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
}
impl asn1_codecs::Asn1Choice for UEContextSuspendResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 93u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextSuspendResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEContextSuspendResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendResponseProtocolIEs(pub Vec<UEContextSuspendResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEHistoryInformationFromTheUE_choice_Extensions {}
impl entropic::Entropic for UEHistoryInformationFromTheUE_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct UEIdentityIndexValue_indexLength10(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for UEIdentityIndexValue_indexLength10 {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(10, 16383);
        let total_bitlen = source.get_bounded_len(10..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(UEIdentityIndexValue_indexLength10(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 10);
        let capped_max = std::cmp::min(10, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(10..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEIdentityIndexValue_choice_Extensions {}
impl entropic::Entropic for UEIdentityIndexValue_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 210)]
    Id_NB_IoT_UEPriority(NB_IoT_UEPriority),
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
}
impl asn1_codecs::Asn1Choice for UEInformationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AllowedNSSAI(_) => 0u128.try_into().unwrap(),
            Self::Id_FiveG_S_TMSI(_) => 26u128.try_into().unwrap(),
            Self::Id_NB_IoT_UEPriority(_) => 210u128.try_into().unwrap(),
            Self::Id_S_NSSAI(_) => 148u128.try_into().unwrap(),
            Self::Id_UE_DifferentiationInfo(_) => 209u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 117u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEInformationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEInformationTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UEInformationTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEInformationTransferProtocolIEs(pub Vec<UEInformationTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingIdentity_choice_Extensions {}
impl entropic::Entropic for UEPagingIdentity_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPresenceInAreaOfInterestItemIE_Extensions_Entry {}
impl entropic::Entropic for UEPresenceInAreaOfInterestItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEPresenceInAreaOfInterestItemIE_Extensions(
    pub Vec<UEPresenceInAreaOfInterestItemIE_Extensions_Entry>,
);
impl entropic::Entropic for UEPresenceInAreaOfInterestItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEPresenceInAreaOfInterestItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UEPresenceInAreaOfInterestItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERLFReportContainer_choice_Extensions {}
impl entropic::Entropic for UERLFReportContainer_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityCheckRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityCheckRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 117u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityCheckRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityCheckRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityCheckRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UERadioCapabilityCheckRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityCheckRequestProtocolIEs(
    pub Vec<UERadioCapabilityCheckRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityCheckResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 30)]
    Id_IMSVoiceSupportIndicator(IMSVoiceSupportIndicator),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityCheckResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_IMSVoiceSupportIndicator(_) => 30u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityCheckResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityCheckResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityCheckResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UERadioCapabilityCheckResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityCheckResponseProtocolIEs(
    pub Vec<UERadioCapabilityCheckResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityForPagingIE_Extensions_EntryExtensionValue {
    #[asn(key = 214)]
    Id_UERadioCapabilityForPagingOfNB_IoT(UERadioCapabilityForPagingOfNB_IoT),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityForPagingIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_UERadioCapabilityForPagingOfNB_IoT(_) => 214u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityForPagingIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UERadioCapabilityForPagingIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for UERadioCapabilityForPagingIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: UERadioCapabilityForPagingIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityForPagingIE_Extensions(
    pub Vec<UERadioCapabilityForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for UERadioCapabilityForPagingIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UERadioCapabilityForPagingIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UERadioCapabilityForPagingIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue {
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue {
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 117u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 264u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityInfoIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 265)]
    Id_UERadioCapability_EUTRA_Format(UERadioCapability),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityInfoIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 117u128.try_into().unwrap(),
            Self::Id_UERadioCapability_EUTRA_Format(_) => 265u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityForPaging(_) => 118u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityInfoIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityInfoIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityInfoIndicationProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UERadioCapabilityInfoIndicationProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityInfoIndicationProtocolIEs(
    pub Vec<UERadioCapabilityInfoIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESecurityCapabilitiesIE_Extensions_Entry {}
impl entropic::Entropic for UESecurityCapabilitiesIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESecurityCapabilitiesIE_Extensions(pub Vec<UESecurityCapabilitiesIE_Extensions_Entry>);
impl entropic::Entropic for UESecurityCapabilitiesIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UESecurityCapabilitiesIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UESecurityCapabilitiesIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UETNLABindingReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UETNLABindingReleaseRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UETNLABindingReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UETNLABindingReleaseRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UETNLABindingReleaseRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UETNLABindingReleaseRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UETNLABindingReleaseRequestProtocolIEs(
    pub Vec<UETNLABindingReleaseRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_CP_SecurityInformationIE_Extensions_Entry {}
impl entropic::Entropic for UL_CP_SecurityInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UL_CP_SecurityInformationIE_Extensions(
    pub Vec<UL_CP_SecurityInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for UL_CP_SecurityInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UL_CP_SecurityInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UL_CP_SecurityInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UL_NGU_UP_TNLModifyItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}
impl asn1_codecs::Asn1Choice for UL_NGU_UP_TNLModifyItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RedundantDL_NGU_UP_TNLInformation(_) => 192u128.try_into().unwrap(),
            Self::Id_RedundantUL_NGU_UP_TNLInformation(_) => 195u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_NGU_UP_TNLModifyItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UL_NGU_UP_TNLModifyItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for UL_NGU_UP_TNLModifyItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: UL_NGU_UP_TNLModifyItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UL_NGU_UP_TNLModifyItemIE_Extensions(
    pub Vec<UL_NGU_UP_TNLModifyItemIE_Extensions_Entry>,
);
impl entropic::Entropic for UL_NGU_UP_TNLModifyItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UL_NGU_UP_TNLModifyItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UL_NGU_UP_TNLModifyItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UPTransportLayerInformation_choice_Extensions {}
impl entropic::Entropic for UPTransportLayerInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UPTransportLayerInformationItemIE_Extensions_Entry {}
impl entropic::Entropic for UPTransportLayerInformationItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UPTransportLayerInformationItemIE_Extensions(
    pub Vec<UPTransportLayerInformationItemIE_Extensions_Entry>,
);
impl entropic::Entropic for UPTransportLayerInformationItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UPTransportLayerInformationItemIE_Extensions_Entry::from_entropy_source(source)?,
            );
        }
        Ok(UPTransportLayerInformationItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UPTransportLayerInformationPairItemIE_Extensions_Entry {}
impl entropic::Entropic for UPTransportLayerInformationPairItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UPTransportLayerInformationPairItemIE_Extensions(
    pub Vec<UPTransportLayerInformationPairItemIE_Extensions_Entry>,
);
impl entropic::Entropic for UPTransportLayerInformationPairItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UPTransportLayerInformationPairItemIE_Extensions_Entry::from_entropy_source(
                    source,
                )?,
            );
        }
        Ok(UPTransportLayerInformationPairItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UnavailableGUAMIItemIE_Extensions_Entry {}
impl entropic::Entropic for UnavailableGUAMIItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UnavailableGUAMIItemIE_Extensions(pub Vec<UnavailableGUAMIItemIE_Extensions_Entry>);
impl entropic::Entropic for UnavailableGUAMIItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UnavailableGUAMIItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UnavailableGUAMIItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UnsuccessfulOutcomeValue {
    #[asn(key = 0)]
    Id_AMFConfigurationUpdate(AMFConfigurationUpdateFailure),
    #[asn(key = 12)]
    Id_HandoverPreparation(HandoverPreparationFailure),
    #[asn(key = 13)]
    Id_HandoverResourceAllocation(HandoverFailure),
    #[asn(key = 14)]
    Id_InitialContextSetup(InitialContextSetupFailure),
    #[asn(key = 21)]
    Id_NGSetup(NGSetupFailure),
    #[asn(key = 25)]
    Id_PathSwitchRequest(PathSwitchRequestFailure),
    #[asn(key = 35)]
    Id_RANConfigurationUpdate(RANConfigurationUpdateFailure),
    #[asn(key = 40)]
    Id_UEContextModification(UEContextModificationFailure),
    #[asn(key = 58)]
    Id_UEContextResume(UEContextResumeFailure),
    #[asn(key = 59)]
    Id_UEContextSuspend(UEContextSuspendFailure),
}
impl asn1_codecs::Asn1Choice for UnsuccessfulOutcomeValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMFConfigurationUpdate(_) => 0u128.try_into().unwrap(),
            Self::Id_HandoverPreparation(_) => 12u128.try_into().unwrap(),
            Self::Id_HandoverResourceAllocation(_) => 13u128.try_into().unwrap(),
            Self::Id_InitialContextSetup(_) => 14u128.try_into().unwrap(),
            Self::Id_NGSetup(_) => 21u128.try_into().unwrap(),
            Self::Id_PathSwitchRequest(_) => 25u128.try_into().unwrap(),
            Self::Id_RANConfigurationUpdate(_) => 35u128.try_into().unwrap(),
            Self::Id_UEContextModification(_) => 40u128.try_into().unwrap(),
            Self::Id_UEContextResume(_) => 58u128.try_into().unwrap(),
            Self::Id_UEContextSuspend(_) => 59u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}
impl asn1_codecs::Asn1Choice for UplinkNASTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 38u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNASTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkNASTransportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UplinkNASTransportProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNASTransportProtocolIEs(pub Vec<UplinkNASTransportProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}
impl asn1_codecs::Asn1Choice for UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_NRPPa_PDU(_) => 46u128.try_into().unwrap(),
            Self::Id_RoutingID(_) => 89u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNonUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<UplinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRANConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 158)]
    Id_ENDC_SONConfigurationTransferUL(EN_DCSONConfigurationTransfer),
    #[asn(key = 251)]
    Id_IntersystemSONConfigurationTransferUL(IntersystemSONConfigurationTransfer),
    #[asn(key = 99)]
    Id_SONConfigurationTransferUL(SONConfigurationTransfer),
}
impl asn1_codecs::Asn1Choice for UplinkRANConfigurationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ENDC_SONConfigurationTransferUL(_) => 158u128.try_into().unwrap(),
            Self::Id_IntersystemSONConfigurationTransferUL(_) => 251u128.try_into().unwrap(),
            Self::Id_SONConfigurationTransferUL(_) => 99u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRANConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRANConfigurationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkRANConfigurationTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UplinkRANConfigurationTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRANConfigurationTransferProtocolIEs(
    pub Vec<UplinkRANConfigurationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRANEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 268)]
    Id_EarlyStatusTransfer_TransparentContainer(EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}
impl asn1_codecs::Asn1Choice for UplinkRANEarlyStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_EarlyStatusTransfer_TransparentContainer(_) => 268u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRANEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRANEarlyStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkRANEarlyStatusTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UplinkRANEarlyStatusTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRANEarlyStatusTransferProtocolIEs(
    pub Vec<UplinkRANEarlyStatusTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRANStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 84)]
    Id_RANStatusTransfer_TransparentContainer(RANStatusTransfer_TransparentContainer),
}
impl asn1_codecs::Asn1Choice for UplinkRANStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RANStatusTransfer_TransparentContainer(_) => 84u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRANStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRANStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkRANStatusTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UplinkRANStatusTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRANStatusTransferProtocolIEs(pub Vec<UplinkRANStatusTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRIMInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 175)]
    Id_RIMInformationTransfer(RIMInformationTransfer),
}
impl asn1_codecs::Asn1Choice for UplinkRIMInformationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RIMInformationTransfer(_) => 175u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRIMInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRIMInformationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkRIMInformationTransferProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UplinkRIMInformationTransferProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRIMInformationTransferProtocolIEs(
    pub Vec<UplinkRIMInformationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}
impl asn1_codecs::Asn1Choice for UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AMF_UE_NGAP_ID(_) => 10u128.try_into().unwrap(),
            Self::Id_NRPPa_PDU(_) => 46u128.try_into().unwrap(),
            Self::Id_RAN_UE_NGAP_ID(_) => 85u128.try_into().unwrap(),
            Self::Id_RoutingID(_) => 89u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue =
            source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformation_choice_ExtensionsValue {
    #[asn(key = 244)]
    Id_UserLocationInformationTNGF(UserLocationInformationTNGF),
    #[asn(key = 248)]
    Id_UserLocationInformationTWIF(UserLocationInformationTWIF),
    #[asn(key = 243)]
    Id_UserLocationInformationW_AGF(UserLocationInformationW_AGF),
}
impl asn1_codecs::Asn1Choice for UserLocationInformation_choice_ExtensionsValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_UserLocationInformationTNGF(_) => 244u128.try_into().unwrap(),
            Self::Id_UserLocationInformationTWIF(_) => 248u128.try_into().unwrap(),
            Self::Id_UserLocationInformationW_AGF(_) => 243u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformation_choice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UserLocationInformation_choice_ExtensionsValue,
}
impl entropic::Entropic for UserLocationInformation_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UserLocationInformation_choice_ExtensionsValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationEUTRAIE_Extensions_EntryExtensionValue {
    #[asn(key = 149)]
    Id_PSCellInformation(NGRAN_CGI),
}
impl asn1_codecs::Asn1Choice for UserLocationInformationEUTRAIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_PSCellInformation(_) => 149u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationEUTRAIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UserLocationInformationEUTRAIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for UserLocationInformationEUTRAIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: UserLocationInformationEUTRAIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationEUTRAIE_Extensions(
    pub Vec<UserLocationInformationEUTRAIE_Extensions_Entry>,
);
impl entropic::Entropic for UserLocationInformationEUTRAIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UserLocationInformationEUTRAIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UserLocationInformationEUTRAIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationN3IWFIE_Extensions_Entry {}
impl entropic::Entropic for UserLocationInformationN3IWFIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationN3IWFIE_Extensions(
    pub Vec<UserLocationInformationN3IWFIE_Extensions_Entry>,
);
impl entropic::Entropic for UserLocationInformationN3IWFIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UserLocationInformationN3IWFIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UserLocationInformationN3IWFIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationNRIE_Extensions_EntryExtensionValue {
    #[asn(key = 263)]
    Id_NID(NID),
    #[asn(key = 149)]
    Id_PSCellInformation(NGRAN_CGI),
}
impl asn1_codecs::Asn1Choice for UserLocationInformationNRIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_NID(_) => 263u128.try_into().unwrap(),
            Self::Id_PSCellInformation(_) => 149u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationNRIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UserLocationInformationNRIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for UserLocationInformationNRIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: UserLocationInformationNRIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationNRIE_Extensions(
    pub Vec<UserLocationInformationNRIE_Extensions_Entry>,
);
impl entropic::Entropic for UserLocationInformationNRIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UserLocationInformationNRIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UserLocationInformationNRIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationTNGFIE_Extensions_Entry {}
impl entropic::Entropic for UserLocationInformationTNGFIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationTNGFIE_Extensions(
    pub Vec<UserLocationInformationTNGFIE_Extensions_Entry>,
);
impl entropic::Entropic for UserLocationInformationTNGFIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UserLocationInformationTNGFIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UserLocationInformationTNGFIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationTWIFIE_Extensions_Entry {}
impl entropic::Entropic for UserLocationInformationTWIFIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationTWIFIE_Extensions(
    pub Vec<UserLocationInformationTWIFIE_Extensions_Entry>,
);
impl entropic::Entropic for UserLocationInformationTWIFIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UserLocationInformationTWIFIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UserLocationInformationTWIFIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationW_AGF_choice_ExtensionsValue {
    #[asn(key = 275)]
    Id_GlobalCable_ID(GlobalCable_ID),
}
impl asn1_codecs::Asn1Choice for UserLocationInformationW_AGF_choice_ExtensionsValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_GlobalCable_ID(_) => 275u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationW_AGF_choice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UserLocationInformationW_AGF_choice_ExtensionsValue,
}
impl entropic::Entropic for UserLocationInformationW_AGF_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: UserLocationInformationW_AGF_choice_ExtensionsValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserPlaneSecurityInformationIE_Extensions_Entry {}
impl entropic::Entropic for UserPlaneSecurityInformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserPlaneSecurityInformationIE_Extensions(
    pub Vec<UserPlaneSecurityInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for UserPlaneSecurityInformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UserPlaneSecurityInformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(UserPlaneSecurityInformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct VolumeTimedReport_ItemStartTimeStamp(pub Vec<u8>);
impl entropic::Entropic for VolumeTimedReport_ItemStartTimeStamp {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(VolumeTimedReport_ItemStartTimeStamp(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct VolumeTimedReport_ItemEndTimeStamp(pub Vec<u8>);
impl entropic::Entropic for VolumeTimedReport_ItemEndTimeStamp {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_entropy_source(source)?);
        }
        Ok(VolumeTimedReport_ItemEndTimeStamp(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct VolumeTimedReport_ItemUsageCountUL(pub u64);
impl entropic::Entropic for VolumeTimedReport_ItemUsageCountUL {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(VolumeTimedReport_ItemUsageCountUL(
            source.get_uniform_range(0..=18446744073709551615)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=18446744073709551615 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct VolumeTimedReport_ItemUsageCountDL(pub u64);
impl entropic::Entropic for VolumeTimedReport_ItemUsageCountDL {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(VolumeTimedReport_ItemUsageCountDL(
            source.get_uniform_range(0..=18446744073709551615)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=18446744073709551615 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VolumeTimedReport_ItemIE_Extensions_Entry {}
impl entropic::Entropic for VolumeTimedReport_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct VolumeTimedReport_ItemIE_Extensions(pub Vec<VolumeTimedReport_ItemIE_Extensions_Entry>);
impl entropic::Entropic for VolumeTimedReport_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(VolumeTimedReport_ItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(VolumeTimedReport_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct W_AGF_ID_w_AGF_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for W_AGF_ID_w_AGF_ID {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.get_entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.get_entropic()?);
        }
        Ok(W_AGF_ID_w_AGF_ID(bv))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct W_AGF_ID_choice_Extensions {}
impl entropic::Entropic for W_AGF_ID_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANMeasConfigNameItemIE_Extensions_Entry {}
impl entropic::Entropic for WLANMeasConfigNameItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WLANMeasConfigNameItemIE_Extensions(pub Vec<WLANMeasConfigNameItemIE_Extensions_Entry>);
impl entropic::Entropic for WLANMeasConfigNameItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WLANMeasConfigNameItemIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(WLANMeasConfigNameItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rssi(pub u8);
impl WLANMeasurementConfigurationWlan_rssi {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for WLANMeasurementConfigurationWlan_rssi {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(WLANMeasurementConfigurationWlan_rssi(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rtt(pub u8);
impl WLANMeasurementConfigurationWlan_rtt {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for WLANMeasurementConfigurationWlan_rtt {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(WLANMeasurementConfigurationWlan_rtt(
            source.get_uniform_range(0..=0)?,
        ))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANMeasurementConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for WLANMeasurementConfigurationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WLANMeasurementConfigurationIE_Extensions(
    pub Vec<WLANMeasurementConfigurationIE_Extensions_Entry>,
);
impl entropic::Entropic for WLANMeasurementConfigurationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WLANMeasurementConfigurationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(WLANMeasurementConfigurationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WUS_Assistance_InformationIE_Extensions_Entry {}
impl entropic::Entropic for WUS_Assistance_InformationIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WUS_Assistance_InformationIE_Extensions(
    pub Vec<WUS_Assistance_InformationIE_Extensions_Entry>,
);
impl entropic::Entropic for WUS_Assistance_InformationIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WUS_Assistance_InformationIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(WUS_Assistance_InformationIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WarningAreaList_choice_Extensions {}
impl entropic::Entropic for WarningAreaList_choice_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningRequestProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_ConcurrentWarningMessageInd(ConcurrentWarningMessageInd),
    #[asn(key = 20)]
    Id_DataCodingScheme(DataCodingScheme),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 47)]
    Id_NumberOfBroadcastsRequested(NumberOfBroadcastsRequested),
    #[asn(key = 87)]
    Id_RepetitionPeriod(RepetitionPeriod),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 141)]
    Id_WarningAreaCoordinates(WarningAreaCoordinates),
    #[asn(key = 122)]
    Id_WarningAreaList(WarningAreaList),
    #[asn(key = 123)]
    Id_WarningMessageContents(WarningMessageContents),
    #[asn(key = 124)]
    Id_WarningSecurityInfo(WarningSecurityInfo),
    #[asn(key = 125)]
    Id_WarningType(WarningType),
}
impl asn1_codecs::Asn1Choice for WriteReplaceWarningRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ConcurrentWarningMessageInd(_) => 17u128.try_into().unwrap(),
            Self::Id_DataCodingScheme(_) => 20u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 35u128.try_into().unwrap(),
            Self::Id_NumberOfBroadcastsRequested(_) => 47u128.try_into().unwrap(),
            Self::Id_RepetitionPeriod(_) => 87u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 95u128.try_into().unwrap(),
            Self::Id_WarningAreaCoordinates(_) => 141u128.try_into().unwrap(),
            Self::Id_WarningAreaList(_) => 122u128.try_into().unwrap(),
            Self::Id_WarningMessageContents(_) => 123u128.try_into().unwrap(),
            Self::Id_WarningSecurityInfo(_) => 124u128.try_into().unwrap(),
            Self::Id_WarningType(_) => 125u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for WriteReplaceWarningRequestProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: WriteReplaceWarningRequestProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningRequestProtocolIEs(
    pub Vec<WriteReplaceWarningRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningResponseProtocolIEs_EntryValue {
    #[asn(key = 13)]
    Id_BroadcastCompletedAreaList(BroadcastCompletedAreaList),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
}
impl asn1_codecs::Asn1Choice for WriteReplaceWarningResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BroadcastCompletedAreaList(_) => 13u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 19u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 35u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 95u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for WriteReplaceWarningResponseProtocolIEs_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let value: WriteReplaceWarningResponseProtocolIEs_EntryValue = source.get_entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningResponseProtocolIEs(
    pub Vec<WriteReplaceWarningResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum XnExtTLA_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 173)]
    Id_SCTP_TLAs(SCTP_TLAs),
}
impl asn1_codecs::Asn1Choice for XnExtTLA_ItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SCTP_TLAs(_) => 173u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct XnExtTLA_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: XnExtTLA_ItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for XnExtTLA_ItemIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let criticality: Criticality = source.get_entropic()?;
        let extension_value: XnExtTLA_ItemIE_Extensions_EntryExtensionValue =
            source.get_entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.criticality.to_entropy_sink(sink)?;
        __entropic_internal_length += self.extension_value.to_entropy_sink(sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct XnExtTLA_ItemIE_Extensions(pub Vec<XnExtTLA_ItemIE_Extensions_Entry>);
impl entropic::Entropic for XnExtTLA_ItemIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(XnExtTLA_ItemIE_Extensions_Entry::from_entropy_source(
                source,
            )?);
        }
        Ok(XnExtTLA_ItemIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct XnTNLConfigurationInfoIE_Extensions_Entry {}
impl entropic::Entropic for XnTNLConfigurationInfoIE_Extensions_Entry {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        Ok(Self {})
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct XnTNLConfigurationInfoIE_Extensions(pub Vec<XnTNLConfigurationInfoIE_Extensions_Entry>);
impl entropic::Entropic for XnTNLConfigurationInfoIE_Extensions {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let capped_max = std::cmp::min(65535, 10);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(XnTNLConfigurationInfoIE_Extensions_Entry::from_entropy_source(source)?);
        }
        Ok(XnTNLConfigurationInfoIE_Extensions(v))
    }
    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 10);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

impl entropic::Entropic for PDUSessionResourceSetupRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_RANPagingPriority(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_NAS_PDU(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListSUReq(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceSetupRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_RANPagingPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_NAS_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListSUReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceSetupRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceSetupResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListSURes(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListSURes(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(PDUSessionResourceSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceSetupResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListSURes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListSURes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceReleaseCommandProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_RANPagingPriority(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_NAS_PDU(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_PDUSessionResourceToReleaseListRelCmd(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceReleaseCommandProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_RANPagingPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_NAS_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceReleaseCommandProtocolIEs_EntryValue::Id_PDUSessionResourceToReleaseListRelCmd(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceReleaseResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListRelRes(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(PDUSessionResourceReleaseResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceReleaseResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListRelRes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceReleaseResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceModifyRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_RANPagingPriority(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModReq(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceModifyRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_RANPagingPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceModifyRequestProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceModifyResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModRes(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToModifyListModRes(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceModifyResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModRes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToModifyListModRes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceModifyResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceNotifyProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_PDUSessionResourceNotifyList(source.get_entropic()?);
            ie_list.push(PDUSessionResourceNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListNot(source.get_entropic()?);
            ie_list.push(PDUSessionResourceNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(PDUSessionResourceNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceNotifyProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_PDUSessionResourceNotifyList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListNot(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceNotifyProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceModifyIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModInd(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceModifyIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModInd(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyIndicationProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PDUSessionResourceModifyConfirmProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyConfirmProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyConfirmProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModCfm(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyConfirmProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToModifyListModCfm(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyConfirmProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(PDUSessionResourceModifyConfirmProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PDUSessionResourceModifyConfirmProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_PDUSessionResourceModifyListModCfm(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToModifyListModCfm(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PDUSessionResourceModifyConfirmProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for InitialContextSetupRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_OldAMF(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_0011) == 0b_0000_0011 { // 1/4 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_GUAMI(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListCxtReq(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_SecurityKey(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_TraceActivation(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_MobilityRestrictionList(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapability(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_IndexToRFSP(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_MaskedIMEISV(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_NAS_PDU(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_EmergencyFallbackIndicator(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_RedirectionVoiceFallback(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_LocationReportingRequestType(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_CNAssistedRANTuning(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_IAB_Authorized(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_Extended_ConnectedTime(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_CEmodeBrestricted(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_UE_UP_CIoT_Support(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_RGLevelWirelineAccessCharacteristics(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTPLMNList(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(InitialContextSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(InitialContextSetupRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_OldAMF(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0011)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_GUAMI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListCxtReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_SecurityKey(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_TraceActivation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_MobilityRestrictionList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_IndexToRFSP(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_MaskedIMEISV(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_NAS_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_EmergencyFallbackIndicator(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_RedirectionVoiceFallback(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_LocationReportingRequestType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_CNAssistedRANTuning(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_IAB_Authorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_Extended_ConnectedTime(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_CEmodeBrestricted(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_UE_UP_CIoT_Support(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_RGLevelWirelineAccessCharacteristics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTPLMNList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for InitialContextSetupResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(InitialContextSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(InitialContextSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListCxtRes(source.get_entropic()?);
            ie_list.push(InitialContextSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListCxtRes(source.get_entropic()?);
            ie_list.push(InitialContextSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(InitialContextSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(InitialContextSetupResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(InitialContextSetupResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListCxtRes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListCxtRes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for InitialContextSetupFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(InitialContextSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(InitialContextSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupFailureProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListCxtFail(source.get_entropic()?);
            ie_list.push(InitialContextSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialContextSetupFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(InitialContextSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialContextSetupFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(InitialContextSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(InitialContextSetupFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(InitialContextSetupFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupFailureProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListCxtFail(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialContextSetupFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialContextSetupFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextReleaseRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextReleaseRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextReleaseRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextReleaseRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextReleaseRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextReleaseRequestProtocolIEs_EntryValue::Id_PDUSessionResourceListCxtRelReq(source.get_entropic()?);
            ie_list.push(UEContextReleaseRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextReleaseRequestProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(UEContextReleaseRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextReleaseRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextReleaseRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextReleaseRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextReleaseRequestProtocolIEs_EntryValue::Id_PDUSessionResourceListCxtRelReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextReleaseRequestProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextReleaseCommandProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextReleaseCommandProtocolIEs_EntryValue::Id_UE_NGAP_IDs(source.get_entropic()?);
            ie_list.push(UEContextReleaseCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextReleaseCommandProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(UEContextReleaseCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextReleaseCommandProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextReleaseCommandProtocolIEs_EntryValue::Id_UE_NGAP_IDs(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextReleaseCommandProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextReleaseCompleteProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextReleaseCompleteProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextReleaseCompleteProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextReleaseCompleteProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextReleaseCompleteProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextReleaseCompleteProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(UEContextReleaseCompleteProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextReleaseCompleteProtocolIEs_EntryValue::Id_InfoOnRecommendedCellsAndRANNodesForPaging(source.get_entropic()?);
            ie_list.push(UEContextReleaseCompleteProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextReleaseCompleteProtocolIEs_EntryValue::Id_PDUSessionResourceListCxtRelCpl(source.get_entropic()?);
            ie_list.push(UEContextReleaseCompleteProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextReleaseCompleteProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UEContextReleaseCompleteProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextReleaseCompleteProtocolIEs_EntryValue::Id_PagingAssisDataforCEcapabUE(source.get_entropic()?);
            ie_list.push(UEContextReleaseCompleteProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextReleaseCompleteProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextReleaseCompleteProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextReleaseCompleteProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextReleaseCompleteProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextReleaseCompleteProtocolIEs_EntryValue::Id_InfoOnRecommendedCellsAndRANNodesForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextReleaseCompleteProtocolIEs_EntryValue::Id_PDUSessionResourceListCxtRelCpl(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextReleaseCompleteProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextReleaseCompleteProtocolIEs_EntryValue::Id_PagingAssisDataforCEcapabUE(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextResumeRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_RRC_Resume_Cause(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_PDUSessionResourceResumeListRESReq(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToResumeListRESReq(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_Suspend_Request_Indication(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_InfoOnRecommendedCellsAndRANNodesForPaging(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeRequestProtocolIEs_EntryValue::Id_PagingAssisDataforCEcapabUE(source.get_entropic()?);
            ie_list.push(UEContextResumeRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextResumeRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_RRC_Resume_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_PDUSessionResourceResumeListRESReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToResumeListRESReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_Suspend_Request_Indication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_InfoOnRecommendedCellsAndRANNodesForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeRequestProtocolIEs_EntryValue::Id_PagingAssisDataforCEcapabUE(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextResumeResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_PDUSessionResourceResumeListRESRes(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToResumeListRESRes(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_SecurityContext(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_Suspend_Response_Indication(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_Extended_ConnectedTime(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UEContextResumeResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextResumeResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_PDUSessionResourceResumeListRESRes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToResumeListRESRes(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_SecurityContext(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_Suspend_Response_Indication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_Extended_ConnectedTime(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextResumeResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextResumeFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextResumeFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextResumeFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextResumeFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(UEContextResumeFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextResumeFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UEContextResumeFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextResumeFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextResumeFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextResumeFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextSuspendRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextSuspendRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextSuspendRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextSuspendRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextSuspendRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextSuspendRequestProtocolIEs_EntryValue::Id_InfoOnRecommendedCellsAndRANNodesForPaging(source.get_entropic()?);
            ie_list.push(UEContextSuspendRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextSuspendRequestProtocolIEs_EntryValue::Id_PagingAssisDataforCEcapabUE(source.get_entropic()?);
            ie_list.push(UEContextSuspendRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextSuspendRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSuspendListSUSReq(source.get_entropic()?);
            ie_list.push(UEContextSuspendRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextSuspendRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextSuspendRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextSuspendRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextSuspendRequestProtocolIEs_EntryValue::Id_InfoOnRecommendedCellsAndRANNodesForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextSuspendRequestProtocolIEs_EntryValue::Id_PagingAssisDataforCEcapabUE(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextSuspendRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSuspendListSUSReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextSuspendResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextSuspendResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextSuspendResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextSuspendResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextSuspendResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextSuspendResponseProtocolIEs_EntryValue::Id_SecurityContext(source.get_entropic()?);
            ie_list.push(UEContextSuspendResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextSuspendResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UEContextSuspendResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextSuspendResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextSuspendResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextSuspendResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextSuspendResponseProtocolIEs_EntryValue::Id_SecurityContext(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextSuspendResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextSuspendFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextSuspendFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextSuspendFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextSuspendFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextSuspendFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextSuspendFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(UEContextSuspendFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextSuspendFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UEContextSuspendFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextSuspendFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextSuspendFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextSuspendFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextSuspendFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextSuspendFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextModificationRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_RANPagingPriority(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_SecurityKey(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_IndexToRFSP(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_EmergencyFallbackIndicator(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_NewAMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_NewGUAMI(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_CNAssistedRANTuning(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_IAB_Authorized(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationRequestProtocolIEs_EntryValue::Id_RGLevelWirelineAccessCharacteristics(source.get_entropic()?);
            ie_list.push(UEContextModificationRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextModificationRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_RANPagingPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_SecurityKey(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_IndexToRFSP(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_EmergencyFallbackIndicator(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_NewAMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_NewGUAMI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_CNAssistedRANTuning(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_IAB_Authorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationRequestProtocolIEs_EntryValue::Id_RGLevelWirelineAccessCharacteristics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextModificationResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextModificationResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextModificationResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextModificationResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextModificationResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationResponseProtocolIEs_EntryValue::Id_RRCState(source.get_entropic()?);
            ie_list.push(UEContextModificationResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationResponseProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(UEContextModificationResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UEContextModificationResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextModificationResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextModificationResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextModificationResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextModificationResponseProtocolIEs_EntryValue::Id_RRCState(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationResponseProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEContextModificationResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEContextModificationFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextModificationFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextModificationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextModificationFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UEContextModificationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEContextModificationFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(UEContextModificationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEContextModificationFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UEContextModificationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEContextModificationFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEContextModificationFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextModificationFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextModificationFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEContextModificationFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for RRCInactiveTransitionReportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(RRCInactiveTransitionReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(RRCInactiveTransitionReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_RRCState(source.get_entropic()?);
            ie_list.push(RRCInactiveTransitionReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(RRCInactiveTransitionReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(RRCInactiveTransitionReportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_RRCState(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RRCInactiveTransitionReportProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for RetrieveUEInformationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RetrieveUEInformationProtocolIEs_EntryValue::Id_FiveG_S_TMSI(source.get_entropic()?);
            ie_list.push(RetrieveUEInformationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(RetrieveUEInformationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(RetrieveUEInformationProtocolIEs_EntryValue::Id_FiveG_S_TMSI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UEInformationTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UEInformationTransferProtocolIEs_EntryValue::Id_FiveG_S_TMSI(source.get_entropic()?);
            ie_list.push(UEInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEInformationTransferProtocolIEs_EntryValue::Id_NB_IoT_UEPriority(source.get_entropic()?);
            ie_list.push(UEInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEInformationTransferProtocolIEs_EntryValue::Id_UERadioCapability(source.get_entropic()?);
            ie_list.push(UEInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEInformationTransferProtocolIEs_EntryValue::Id_S_NSSAI(source.get_entropic()?);
            ie_list.push(UEInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEInformationTransferProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(UEInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UEInformationTransferProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(source.get_entropic()?);
            ie_list.push(UEInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UEInformationTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UEInformationTransferProtocolIEs_EntryValue::Id_FiveG_S_TMSI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UEInformationTransferProtocolIEs_EntryValue::Id_NB_IoT_UEPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEInformationTransferProtocolIEs_EntryValue::Id_UERadioCapability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEInformationTransferProtocolIEs_EntryValue::Id_S_NSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEInformationTransferProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UEInformationTransferProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for RANCPRelocationIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RANCPRelocationIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(RANCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RANCPRelocationIndicationProtocolIEs_EntryValue::Id_FiveG_S_TMSI(source.get_entropic()?);
            ie_list.push(RANCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RANCPRelocationIndicationProtocolIEs_EntryValue::Id_EUTRA_CGI(source.get_entropic()?);
            ie_list.push(RANCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RANCPRelocationIndicationProtocolIEs_EntryValue::Id_TAI(source.get_entropic()?);
            ie_list.push(RANCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RANCPRelocationIndicationProtocolIEs_EntryValue::Id_UL_CP_SecurityInformation(source.get_entropic()?);
            ie_list.push(RANCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(RANCPRelocationIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(RANCPRelocationIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RANCPRelocationIndicationProtocolIEs_EntryValue::Id_FiveG_S_TMSI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RANCPRelocationIndicationProtocolIEs_EntryValue::Id_EUTRA_CGI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RANCPRelocationIndicationProtocolIEs_EntryValue::Id_TAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RANCPRelocationIndicationProtocolIEs_EntryValue::Id_UL_CP_SecurityInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverRequiredProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_HandoverType(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_TargetID(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_DirectForwardingPathAvailability(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_PDUSessionResourceListHORqd(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequiredProtocolIEs_EntryValue::Id_SourceToTarget_TransparentContainer(source.get_entropic()?);
            ie_list.push(HandoverRequiredProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverRequiredProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_HandoverType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_TargetID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_DirectForwardingPathAvailability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_PDUSessionResourceListHORqd(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequiredProtocolIEs_EntryValue::Id_SourceToTarget_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverCommandProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_HandoverType(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_0011) == 0b_0000_0011 { // 1/4 chance of being present
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_NASSecurityParametersFromNGRAN(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_PDUSessionResourceHandoverList(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_PDUSessionResourceToReleaseListHOCmd(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_TargetToSource_TransparentContainer(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverCommandProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(HandoverCommandProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverCommandProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_HandoverType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_NASSecurityParametersFromNGRAN(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0011)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_PDUSessionResourceHandoverList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_PDUSessionResourceToReleaseListHOCmd(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_TargetToSource_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCommandProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverPreparationFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverPreparationFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverPreparationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverPreparationFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverPreparationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverPreparationFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(HandoverPreparationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverPreparationFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(HandoverPreparationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverPreparationFailureProtocolIEs_EntryValue::Id_TargettoSource_Failure_TransparentContainer(source.get_entropic()?);
            ie_list.push(HandoverPreparationFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverPreparationFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverPreparationFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverPreparationFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverPreparationFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverPreparationFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverPreparationFailureProtocolIEs_EntryValue::Id_TargettoSource_Failure_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_HandoverType(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_SecurityContext(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_NewSecurityContextInd(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_NASC(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListHOReq(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_TraceActivation(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_MaskedIMEISV(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_SourceToTarget_TransparentContainer(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_MobilityRestrictionList(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_LocationReportingRequestType(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_GUAMI(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_RedirectionVoiceFallback(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_CNAssistedRANTuning(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_IAB_Authorized(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_CEmodeBrestricted(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_UE_UP_CIoT_Support(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTPLMNList(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestProtocolIEs_EntryValue::Id_Extended_ConnectedTime(source.get_entropic()?);
            ie_list.push(HandoverRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_HandoverType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_SecurityContext(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_NewSecurityContextInd(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_NASC(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_PDUSessionResourceSetupListHOReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_TraceActivation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_MaskedIMEISV(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_SourceToTarget_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_MobilityRestrictionList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_LocationReportingRequestType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_GUAMI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_RedirectionVoiceFallback(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_CNAssistedRANTuning(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_IAB_Authorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_CEmodeBrestricted(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_UE_UP_CIoT_Support(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTPLMNList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestProtocolIEs_EntryValue::Id_Extended_ConnectedTime(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverRequestAcknowledgeProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceAdmittedList(source.get_entropic()?);
            ie_list.push(HandoverRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListHOAck(source.get_entropic()?);
            ie_list.push(HandoverRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_TargetToSource_TransparentContainer(source.get_entropic()?);
            ie_list.push(HandoverRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(HandoverRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverRequestAcknowledgeProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceAdmittedList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListHOAck(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_TargetToSource_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(HandoverFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(HandoverFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverFailureProtocolIEs_EntryValue::Id_TargettoSource_Failure_TransparentContainer(source.get_entropic()?);
            ie_list.push(HandoverFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(HandoverFailureProtocolIEs_EntryValue::Id_TargettoSource_Failure_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverNotifyProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverNotifyProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverNotifyProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverNotifyProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(HandoverNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverNotifyProtocolIEs_EntryValue::Id_NotifySourceNGRANNode(source.get_entropic()?);
            ie_list.push(HandoverNotifyProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverNotifyProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverNotifyProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverNotifyProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverNotifyProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverNotifyProtocolIEs_EntryValue::Id_NotifySourceNGRANNode(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PathSwitchRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PathSwitchRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestProtocolIEs_EntryValue::Id_SourceAMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PathSwitchRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(PathSwitchRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(source.get_entropic()?);
            ie_list.push(PathSwitchRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestProtocolIEs_EntryValue::Id_PDUSessionResourceToBeSwitchedDLList(source.get_entropic()?);
            ie_list.push(PathSwitchRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListPSReq(source.get_entropic()?);
            ie_list.push(PathSwitchRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestProtocolIEs_EntryValue::Id_RRC_Resume_Cause(source.get_entropic()?);
            ie_list.push(PathSwitchRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PathSwitchRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PathSwitchRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestProtocolIEs_EntryValue::Id_SourceAMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestProtocolIEs_EntryValue::Id_PDUSessionResourceToBeSwitchedDLList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestProtocolIEs_EntryValue::Id_PDUSessionResourceFailedToSetupListPSReq(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestProtocolIEs_EntryValue::Id_RRC_Resume_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PathSwitchRequestAcknowledgeProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UESecurityCapabilities(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_SecurityContext(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NewSecurityContextInd(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceSwitchedList(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListPSAck(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_RedirectionVoiceFallback(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CNAssistedRANTuning(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_SRVCCOperationPossible(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_Extended_ConnectedTime(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PC5QoSParameters(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CEmodeBrestricted(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UE_UP_CIoT_Support(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(PathSwitchRequestAcknowledgeProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UESecurityCapabilities(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_SecurityContext(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NewSecurityContextInd(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceSwitchedList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListPSAck(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CoreNetworkAssistanceInformationForInactive(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_RRCInactiveTransitionReportRequest(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_RedirectionVoiceFallback(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CNAssistedRANTuning(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_SRVCCOperationPossible(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_Extended_ConnectedTime(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_LTEV2XServicesAuthorized(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_LTEUESidelinkAggregateMaximumBitrate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PC5QoSParameters(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CEmodeBrestricted(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UE_UP_CIoT_Support(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PathSwitchRequestFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PathSwitchRequestFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(PathSwitchRequestFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PathSwitchRequestFailureProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListPSFail(source.get_entropic()?);
            ie_list.push(PathSwitchRequestFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PathSwitchRequestFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(PathSwitchRequestFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PathSwitchRequestFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PathSwitchRequestFailureProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestFailureProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestFailureProtocolIEs_EntryValue::Id_PDUSessionResourceReleasedListPSFail(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PathSwitchRequestFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverCancelProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCancelProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverCancelProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCancelProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverCancelProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCancelProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(HandoverCancelProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverCancelProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverCancelProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCancelProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCancelProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverCancelAcknowledgeProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverCancelAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverCancelAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(HandoverCancelAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverCancelAcknowledgeProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for HandoverSuccessProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverSuccessProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverSuccessProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = HandoverSuccessProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(HandoverSuccessProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(HandoverSuccessProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(HandoverSuccessProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(HandoverSuccessProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UplinkRANEarlyStatusTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkRANEarlyStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkRANEarlyStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_EarlyStatusTransfer_TransparentContainer(source.get_entropic()?);
            ie_list.push(UplinkRANEarlyStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UplinkRANEarlyStatusTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UplinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_EarlyStatusTransfer_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DownlinkRANEarlyStatusTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkRANEarlyStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkRANEarlyStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_EarlyStatusTransfer_TransparentContainer(source.get_entropic()?);
            ie_list.push(DownlinkRANEarlyStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(DownlinkRANEarlyStatusTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue::Id_EarlyStatusTransfer_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UplinkRANStatusTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkRANStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkRANStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkRANStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkRANStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkRANStatusTransferProtocolIEs_EntryValue::Id_RANStatusTransfer_TransparentContainer(source.get_entropic()?);
            ie_list.push(UplinkRANStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UplinkRANStatusTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UplinkRANStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkRANStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkRANStatusTransferProtocolIEs_EntryValue::Id_RANStatusTransfer_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DownlinkRANStatusTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkRANStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkRANStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkRANStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkRANStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkRANStatusTransferProtocolIEs_EntryValue::Id_RANStatusTransfer_TransparentContainer(source.get_entropic()?);
            ie_list.push(DownlinkRANStatusTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(DownlinkRANStatusTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DownlinkRANStatusTransferProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkRANStatusTransferProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkRANStatusTransferProtocolIEs_EntryValue::Id_RANStatusTransfer_TransparentContainer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PagingProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PagingProtocolIEs_EntryValue::Id_UEPagingIdentity(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_PagingDRX(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PagingProtocolIEs_EntryValue::Id_TAIListForPaging(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_PagingPriority(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_PagingOrigin(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_AssistanceDataForPaging(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_NB_IoT_Paging_eDRXInfo(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_NB_IoT_PagingDRX(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_WUS_Assistance_Information(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_PagingeDRXInformation(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PagingProtocolIEs_EntryValue::Id_CEmodeBrestricted(source.get_entropic()?);
            ie_list.push(PagingProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PagingProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PagingProtocolIEs_EntryValue::Id_UEPagingIdentity(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_PagingDRX(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_TAIListForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_PagingPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_PagingOrigin(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_AssistanceDataForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_NB_IoT_Paging_eDRXInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_NB_IoT_PagingDRX(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_WUS_Assistance_Information(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_PagingeDRXInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PagingProtocolIEs_EntryValue::Id_CEmodeBrestricted(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for InitialUEMessageProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_NAS_PDU(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_RRCEstablishmentCause(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_FiveG_S_TMSI(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_AMFSetID(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_UEContextRequest(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_SourceToTarget_AMFInformationReroute(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_SelectedPLMNIdentity(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_IABNodeIndication(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_CEmodeBSupport_Indicator(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_LTEM_Indication(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_EDT_Session(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_AuthenticatedIndication(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = InitialUEMessageProtocolIEs_EntryValue::Id_NPN_AccessInformation(source.get_entropic()?);
            ie_list.push(InitialUEMessageProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(InitialUEMessageProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_NAS_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_RRCEstablishmentCause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_FiveG_S_TMSI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_AMFSetID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_UEContextRequest(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_SourceToTarget_AMFInformationReroute(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_SelectedPLMNIdentity(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_IABNodeIndication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_CEmodeBSupport_Indicator(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_LTEM_Indication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_EDT_Session(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_AuthenticatedIndication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(InitialUEMessageProtocolIEs_EntryValue::Id_NPN_AccessInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DownlinkNASTransportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_OldAMF(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_RANPagingPriority(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_NAS_PDU(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_MobilityRestrictionList(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_IndexToRFSP(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_SRVCCOperationPossible(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_Extended_ConnectedTime(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_CEmodeBrestricted(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_UERadioCapability(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_UECapabilityInfoRequest(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_EndIndication(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkNASTransportProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(DownlinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(DownlinkNASTransportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_OldAMF(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_RANPagingPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_NAS_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_MobilityRestrictionList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_IndexToRFSP(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_UEAggregateMaximumBitRate(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_SRVCCOperationPossible(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_Extended_ConnectedTime(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_CEmodeBrestricted(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_UERadioCapability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_UECapabilityInfoRequest(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_EndIndication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkNASTransportProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UplinkNASTransportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkNASTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkNASTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkNASTransportProtocolIEs_EntryValue::Id_NAS_PDU(source.get_entropic()?);
            ie_list.push(UplinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkNASTransportProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(UplinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }

        /*      
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UplinkNASTransportProtocolIEs_EntryValue::Id_W_AGFIdentityInformation(source.get_entropic()?);
            ie_list.push(UplinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UplinkNASTransportProtocolIEs_EntryValue::Id_TNGFIdentityInformation(source.get_entropic()?);
            ie_list.push(UplinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UplinkNASTransportProtocolIEs_EntryValue::Id_TWIFIdentityInformation(source.get_entropic()?);
            ie_list.push(UplinkNASTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
        */
                
        
        Ok(UplinkNASTransportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UplinkNASTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkNASTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkNASTransportProtocolIEs_EntryValue::Id_NAS_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkNASTransportProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
        /*      
        if let Some(UplinkNASTransportProtocolIEs_EntryValue::Id_W_AGFIdentityInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UplinkNASTransportProtocolIEs_EntryValue::Id_TNGFIdentityInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UplinkNASTransportProtocolIEs_EntryValue::Id_TWIFIdentityInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
        */      

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for NASNonDeliveryIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(NASNonDeliveryIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(NASNonDeliveryIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_NAS_PDU(source.get_entropic()?);
            ie_list.push(NASNonDeliveryIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(NASNonDeliveryIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(NASNonDeliveryIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_NAS_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for RerouteNASRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RerouteNASRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(RerouteNASRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RerouteNASRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(RerouteNASRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }

        /*
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RerouteNASRequestProtocolIEs_EntryValue::Id_NGAP_Message(source.get_entropic()?);
            ie_list.push(RerouteNASRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
        */
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RerouteNASRequestProtocolIEs_EntryValue::Id_AMFSetID(source.get_entropic()?);
            ie_list.push(RerouteNASRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RerouteNASRequestProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(RerouteNASRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RerouteNASRequestProtocolIEs_EntryValue::Id_SourceToTarget_AMFInformationReroute(source.get_entropic()?);
            ie_list.push(RerouteNASRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(RerouteNASRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(RerouteNASRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RerouteNASRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };

        /*       
        if let Some(RerouteNASRequestProtocolIEs_EntryValue::Id_NGAP_Message(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
        */
                
        if let Some(RerouteNASRequestProtocolIEs_EntryValue::Id_AMFSetID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RerouteNASRequestProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RerouteNASRequestProtocolIEs_EntryValue::Id_SourceToTarget_AMFInformationReroute(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for NGSetupRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupRequestProtocolIEs_EntryValue::Id_GlobalRANNodeID(source.get_entropic()?);
            ie_list.push(NGSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupRequestProtocolIEs_EntryValue::Id_RANNodeName(source.get_entropic()?);
            ie_list.push(NGSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupRequestProtocolIEs_EntryValue::Id_SupportedTAList(source.get_entropic()?);
            ie_list.push(NGSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupRequestProtocolIEs_EntryValue::Id_DefaultPagingDRX(source.get_entropic()?);
            ie_list.push(NGSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupRequestProtocolIEs_EntryValue::Id_UERetentionInformation(source.get_entropic()?);
            ie_list.push(NGSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupRequestProtocolIEs_EntryValue::Id_NB_IoT_DefaultPagingDRX(source.get_entropic()?);
            ie_list.push(NGSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupRequestProtocolIEs_EntryValue::Id_Extended_RANNodeName(source.get_entropic()?);
            ie_list.push(NGSetupRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(NGSetupRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(NGSetupRequestProtocolIEs_EntryValue::Id_GlobalRANNodeID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupRequestProtocolIEs_EntryValue::Id_RANNodeName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGSetupRequestProtocolIEs_EntryValue::Id_SupportedTAList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupRequestProtocolIEs_EntryValue::Id_DefaultPagingDRX(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupRequestProtocolIEs_EntryValue::Id_UERetentionInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGSetupRequestProtocolIEs_EntryValue::Id_NB_IoT_DefaultPagingDRX(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGSetupRequestProtocolIEs_EntryValue::Id_Extended_RANNodeName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for NGSetupResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_AMFName(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_ServedGUAMIList(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_RelativeAMFCapacity(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_PLMNSupportList(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_UERetentionInformation(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_IAB_Supported(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupResponseProtocolIEs_EntryValue::Id_Extended_AMFName(source.get_entropic()?);
            ie_list.push(NGSetupResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(NGSetupResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_AMFName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_ServedGUAMIList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_RelativeAMFCapacity(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_PLMNSupportList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_UERetentionInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_IAB_Supported(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGSetupResponseProtocolIEs_EntryValue::Id_Extended_AMFName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for NGSetupFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGSetupFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(NGSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupFailureProtocolIEs_EntryValue::Id_TimeToWait(source.get_entropic()?);
            ie_list.push(NGSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGSetupFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(NGSetupFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(NGSetupFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(NGSetupFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGSetupFailureProtocolIEs_EntryValue::Id_TimeToWait(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGSetupFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for RANConfigurationUpdateProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateProtocolIEs_EntryValue::Id_RANNodeName(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateProtocolIEs_EntryValue::Id_SupportedTAList(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateProtocolIEs_EntryValue::Id_DefaultPagingDRX(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateProtocolIEs_EntryValue::Id_GlobalRANNodeID(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateProtocolIEs_EntryValue::Id_NGRAN_TNLAssociationToRemoveList(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateProtocolIEs_EntryValue::Id_NB_IoT_DefaultPagingDRX(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateProtocolIEs_EntryValue::Id_Extended_RANNodeName(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(RANConfigurationUpdateProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(RANConfigurationUpdateProtocolIEs_EntryValue::Id_RANNodeName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RANConfigurationUpdateProtocolIEs_EntryValue::Id_SupportedTAList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RANConfigurationUpdateProtocolIEs_EntryValue::Id_DefaultPagingDRX(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RANConfigurationUpdateProtocolIEs_EntryValue::Id_GlobalRANNodeID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RANConfigurationUpdateProtocolIEs_EntryValue::Id_NGRAN_TNLAssociationToRemoveList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RANConfigurationUpdateProtocolIEs_EntryValue::Id_NB_IoT_DefaultPagingDRX(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RANConfigurationUpdateProtocolIEs_EntryValue::Id_Extended_RANNodeName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for RANConfigurationUpdateAcknowledgeProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(RANConfigurationUpdateAcknowledgeProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for RANConfigurationUpdateFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = RANConfigurationUpdateFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateFailureProtocolIEs_EntryValue::Id_TimeToWait(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = RANConfigurationUpdateFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(RANConfigurationUpdateFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(RANConfigurationUpdateFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(RANConfigurationUpdateFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(RANConfigurationUpdateFailureProtocolIEs_EntryValue::Id_TimeToWait(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(RANConfigurationUpdateFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for AMFConfigurationUpdateProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMFName(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_ServedGUAMIList(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_RelativeAMFCapacity(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_PLMNSupportList(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMF_TNLAssociationToAddList(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMF_TNLAssociationToRemoveList(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMF_TNLAssociationToUpdateList(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateProtocolIEs_EntryValue::Id_Extended_AMFName(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(AMFConfigurationUpdateProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMFName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_ServedGUAMIList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_RelativeAMFCapacity(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_PLMNSupportList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMF_TNLAssociationToAddList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMF_TNLAssociationToRemoveList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_AMF_TNLAssociationToUpdateList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateProtocolIEs_EntryValue::Id_Extended_AMFName(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for AMFConfigurationUpdateAcknowledgeProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_AMF_TNLAssociationSetupList(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_AMF_TNLAssociationFailedToSetupList(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(AMFConfigurationUpdateAcknowledgeProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_AMF_TNLAssociationSetupList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_AMF_TNLAssociationFailedToSetupList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for AMFConfigurationUpdateFailureProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = AMFConfigurationUpdateFailureProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateFailureProtocolIEs_EntryValue::Id_TimeToWait(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFConfigurationUpdateFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(AMFConfigurationUpdateFailureProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(AMFConfigurationUpdateFailureProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(AMFConfigurationUpdateFailureProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(AMFConfigurationUpdateFailureProtocolIEs_EntryValue::Id_TimeToWait(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFConfigurationUpdateFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for AMFStatusIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = AMFStatusIndicationProtocolIEs_EntryValue::Id_UnavailableGUAMIList(source.get_entropic()?);
            ie_list.push(AMFStatusIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(AMFStatusIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(AMFStatusIndicationProtocolIEs_EntryValue::Id_UnavailableGUAMIList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for NGResetProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGResetProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(NGResetProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = NGResetProtocolIEs_EntryValue::Id_ResetType(source.get_entropic()?);
            ie_list.push(NGResetProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(NGResetProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(NGResetProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(NGResetProtocolIEs_EntryValue::Id_ResetType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for NGResetAcknowledgeProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGResetAcknowledgeProtocolIEs_EntryValue::Id_UE_associatedLogicalNG_connectionList(source.get_entropic()?);
            ie_list.push(NGResetAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = NGResetAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(NGResetAcknowledgeProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(NGResetAcknowledgeProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(NGResetAcknowledgeProtocolIEs_EntryValue::Id_UE_associatedLogicalNG_connectionList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(NGResetAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for ErrorIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ErrorIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(ErrorIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ErrorIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(ErrorIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ErrorIndicationProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(ErrorIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ErrorIndicationProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(ErrorIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ErrorIndicationProtocolIEs_EntryValue::Id_FiveG_S_TMSI(source.get_entropic()?);
            ie_list.push(ErrorIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(ErrorIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(ErrorIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ErrorIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ErrorIndicationProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ErrorIndicationProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ErrorIndicationProtocolIEs_EntryValue::Id_FiveG_S_TMSI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for OverloadStartProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = OverloadStartProtocolIEs_EntryValue::Id_AMFOverloadResponse(source.get_entropic()?);
            ie_list.push(OverloadStartProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = OverloadStartProtocolIEs_EntryValue::Id_AMFTrafficLoadReductionIndication(source.get_entropic()?);
            ie_list.push(OverloadStartProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = OverloadStartProtocolIEs_EntryValue::Id_OverloadStartNSSAIList(source.get_entropic()?);
            ie_list.push(OverloadStartProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(OverloadStartProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(OverloadStartProtocolIEs_EntryValue::Id_AMFOverloadResponse(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(OverloadStartProtocolIEs_EntryValue::Id_AMFTrafficLoadReductionIndication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(OverloadStartProtocolIEs_EntryValue::Id_OverloadStartNSSAIList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for OverloadStopProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        return Err(entropic::Error::InsufficientBytes); // BUG: OverloadStop triggers infinite loop in aper_encode
        
        Ok(OverloadStopProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        return Err(entropic::Error::InsufficientBytes); // BUG: OverloadStop triggers infinite loop in aper_encode       

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UplinkRANConfigurationTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UplinkRANConfigurationTransferProtocolIEs_EntryValue::Id_SONConfigurationTransferUL(source.get_entropic()?);
            ie_list.push(UplinkRANConfigurationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UplinkRANConfigurationTransferProtocolIEs_EntryValue::Id_ENDC_SONConfigurationTransferUL(source.get_entropic()?);
            ie_list.push(UplinkRANConfigurationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UplinkRANConfigurationTransferProtocolIEs_EntryValue::Id_IntersystemSONConfigurationTransferUL(source.get_entropic()?);
            ie_list.push(UplinkRANConfigurationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UplinkRANConfigurationTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UplinkRANConfigurationTransferProtocolIEs_EntryValue::Id_SONConfigurationTransferUL(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UplinkRANConfigurationTransferProtocolIEs_EntryValue::Id_ENDC_SONConfigurationTransferUL(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UplinkRANConfigurationTransferProtocolIEs_EntryValue::Id_IntersystemSONConfigurationTransferUL(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DownlinkRANConfigurationTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkRANConfigurationTransferProtocolIEs_EntryValue::Id_SONConfigurationTransferDL(source.get_entropic()?);
            ie_list.push(DownlinkRANConfigurationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkRANConfigurationTransferProtocolIEs_EntryValue::Id_ENDC_SONConfigurationTransferDL(source.get_entropic()?);
            ie_list.push(DownlinkRANConfigurationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkRANConfigurationTransferProtocolIEs_EntryValue::Id_IntersystemSONConfigurationTransferDL(source.get_entropic()?);
            ie_list.push(DownlinkRANConfigurationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(DownlinkRANConfigurationTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DownlinkRANConfigurationTransferProtocolIEs_EntryValue::Id_SONConfigurationTransferDL(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkRANConfigurationTransferProtocolIEs_EntryValue::Id_ENDC_SONConfigurationTransferDL(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(DownlinkRANConfigurationTransferProtocolIEs_EntryValue::Id_IntersystemSONConfigurationTransferDL(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for WriteReplaceWarningRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_MessageIdentifier(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_SerialNumber(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningAreaList(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_RepetitionPeriod(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_NumberOfBroadcastsRequested(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningType(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningSecurityInfo(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_DataCodingScheme(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningMessageContents(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_ConcurrentWarningMessageInd(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningAreaCoordinates(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(WriteReplaceWarningRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_MessageIdentifier(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_SerialNumber(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningAreaList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_RepetitionPeriod(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_NumberOfBroadcastsRequested(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningSecurityInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_DataCodingScheme(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningMessageContents(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_ConcurrentWarningMessageInd(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningAreaCoordinates(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for WriteReplaceWarningResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_MessageIdentifier(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_SerialNumber(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_BroadcastCompletedAreaList(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(WriteReplaceWarningResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(WriteReplaceWarningResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_MessageIdentifier(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_SerialNumber(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_BroadcastCompletedAreaList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PWSCancelRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSCancelRequestProtocolIEs_EntryValue::Id_MessageIdentifier(source.get_entropic()?);
            ie_list.push(PWSCancelRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSCancelRequestProtocolIEs_EntryValue::Id_SerialNumber(source.get_entropic()?);
            ie_list.push(PWSCancelRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PWSCancelRequestProtocolIEs_EntryValue::Id_WarningAreaList(source.get_entropic()?);
            ie_list.push(PWSCancelRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PWSCancelRequestProtocolIEs_EntryValue::Id_CancelAllWarningMessages(source.get_entropic()?);
            ie_list.push(PWSCancelRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(PWSCancelRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PWSCancelRequestProtocolIEs_EntryValue::Id_MessageIdentifier(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSCancelRequestProtocolIEs_EntryValue::Id_SerialNumber(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSCancelRequestProtocolIEs_EntryValue::Id_WarningAreaList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PWSCancelRequestProtocolIEs_EntryValue::Id_CancelAllWarningMessages(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PWSCancelResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSCancelResponseProtocolIEs_EntryValue::Id_MessageIdentifier(source.get_entropic()?);
            ie_list.push(PWSCancelResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSCancelResponseProtocolIEs_EntryValue::Id_SerialNumber(source.get_entropic()?);
            ie_list.push(PWSCancelResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PWSCancelResponseProtocolIEs_EntryValue::Id_BroadcastCancelledAreaList(source.get_entropic()?);
            ie_list.push(PWSCancelResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PWSCancelResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(PWSCancelResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(PWSCancelResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PWSCancelResponseProtocolIEs_EntryValue::Id_MessageIdentifier(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSCancelResponseProtocolIEs_EntryValue::Id_SerialNumber(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSCancelResponseProtocolIEs_EntryValue::Id_BroadcastCancelledAreaList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(PWSCancelResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PWSRestartIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSRestartIndicationProtocolIEs_EntryValue::Id_CellIDListForRestart(source.get_entropic()?);
            ie_list.push(PWSRestartIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSRestartIndicationProtocolIEs_EntryValue::Id_GlobalRANNodeID(source.get_entropic()?);
            ie_list.push(PWSRestartIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSRestartIndicationProtocolIEs_EntryValue::Id_TAIListForRestart(source.get_entropic()?);
            ie_list.push(PWSRestartIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = PWSRestartIndicationProtocolIEs_EntryValue::Id_EmergencyAreaIDListForRestart(source.get_entropic()?);
            ie_list.push(PWSRestartIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(PWSRestartIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PWSRestartIndicationProtocolIEs_EntryValue::Id_CellIDListForRestart(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSRestartIndicationProtocolIEs_EntryValue::Id_GlobalRANNodeID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSRestartIndicationProtocolIEs_EntryValue::Id_TAIListForRestart(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSRestartIndicationProtocolIEs_EntryValue::Id_EmergencyAreaIDListForRestart(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for PWSFailureIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSFailureIndicationProtocolIEs_EntryValue::Id_PWSFailedCellIDList(source.get_entropic()?);
            ie_list.push(PWSFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = PWSFailureIndicationProtocolIEs_EntryValue::Id_GlobalRANNodeID(source.get_entropic()?);
            ie_list.push(PWSFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(PWSFailureIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(PWSFailureIndicationProtocolIEs_EntryValue::Id_PWSFailedCellIDList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(PWSFailureIndicationProtocolIEs_EntryValue::Id_GlobalRANNodeID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DownlinkUEAssociatedNRPPaTransportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(source.get_entropic()?);
            ie_list.push(DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(source.get_entropic()?);
            ie_list.push(DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(DownlinkUEAssociatedNRPPaTransportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UplinkUEAssociatedNRPPaTransportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(source.get_entropic()?);
            ie_list.push(UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(source.get_entropic()?);
            ie_list.push(UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UplinkUEAssociatedNRPPaTransportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DownlinkNonUEAssociatedNRPPaTransportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(source.get_entropic()?);
            ie_list.push(DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(source.get_entropic()?);
            ie_list.push(DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(DownlinkNonUEAssociatedNRPPaTransportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UplinkNonUEAssociatedNRPPaTransportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(source.get_entropic()?);
            ie_list.push(UplinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(source.get_entropic()?);
            ie_list.push(UplinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UplinkNonUEAssociatedNRPPaTransportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_RoutingID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue::Id_NRPPa_PDU(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for TraceStartProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = TraceStartProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(TraceStartProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = TraceStartProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(TraceStartProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = TraceStartProtocolIEs_EntryValue::Id_TraceActivation(source.get_entropic()?);
            ie_list.push(TraceStartProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(TraceStartProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(TraceStartProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(TraceStartProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(TraceStartProtocolIEs_EntryValue::Id_TraceActivation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for TraceFailureIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = TraceFailureIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(TraceFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = TraceFailureIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(TraceFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = TraceFailureIndicationProtocolIEs_EntryValue::Id_NGRANTraceID(source.get_entropic()?);
            ie_list.push(TraceFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = TraceFailureIndicationProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(TraceFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(TraceFailureIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(TraceFailureIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(TraceFailureIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(TraceFailureIndicationProtocolIEs_EntryValue::Id_NGRANTraceID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(TraceFailureIndicationProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DeactivateTraceProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DeactivateTraceProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DeactivateTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DeactivateTraceProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(DeactivateTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = DeactivateTraceProtocolIEs_EntryValue::Id_NGRANTraceID(source.get_entropic()?);
            ie_list.push(DeactivateTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(DeactivateTraceProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DeactivateTraceProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DeactivateTraceProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(DeactivateTraceProtocolIEs_EntryValue::Id_NGRANTraceID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for CellTrafficTraceProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = CellTrafficTraceProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(CellTrafficTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = CellTrafficTraceProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(CellTrafficTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = CellTrafficTraceProtocolIEs_EntryValue::Id_NGRANTraceID(source.get_entropic()?);
            ie_list.push(CellTrafficTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = CellTrafficTraceProtocolIEs_EntryValue::Id_NGRAN_CGI(source.get_entropic()?);
            ie_list.push(CellTrafficTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = CellTrafficTraceProtocolIEs_EntryValue::Id_TraceCollectionEntityIPAddress(source.get_entropic()?);
            ie_list.push(CellTrafficTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = CellTrafficTraceProtocolIEs_EntryValue::Id_PrivacyIndicator(source.get_entropic()?);
            ie_list.push(CellTrafficTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = CellTrafficTraceProtocolIEs_EntryValue::Id_TraceCollectionEntityURI(source.get_entropic()?);
            ie_list.push(CellTrafficTraceProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(CellTrafficTraceProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(CellTrafficTraceProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(CellTrafficTraceProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(CellTrafficTraceProtocolIEs_EntryValue::Id_NGRANTraceID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(CellTrafficTraceProtocolIEs_EntryValue::Id_NGRAN_CGI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(CellTrafficTraceProtocolIEs_EntryValue::Id_TraceCollectionEntityIPAddress(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(CellTrafficTraceProtocolIEs_EntryValue::Id_PrivacyIndicator(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(CellTrafficTraceProtocolIEs_EntryValue::Id_TraceCollectionEntityURI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for LocationReportingControlProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportingControlProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(LocationReportingControlProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportingControlProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(LocationReportingControlProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportingControlProtocolIEs_EntryValue::Id_LocationReportingRequestType(source.get_entropic()?);
            ie_list.push(LocationReportingControlProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(LocationReportingControlProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(LocationReportingControlProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(LocationReportingControlProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(LocationReportingControlProtocolIEs_EntryValue::Id_LocationReportingRequestType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for LocationReportingFailureIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(LocationReportingFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(LocationReportingFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_Cause(source.get_entropic()?);
            ie_list.push(LocationReportingFailureIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(LocationReportingFailureIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_Cause(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for LocationReportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(LocationReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(LocationReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(LocationReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = LocationReportProtocolIEs_EntryValue::Id_UEPresenceInAreaOfInterestList(source.get_entropic()?);
            ie_list.push(LocationReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = LocationReportProtocolIEs_EntryValue::Id_LocationReportingRequestType(source.get_entropic()?);
            ie_list.push(LocationReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(LocationReportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(LocationReportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(LocationReportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(LocationReportProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(LocationReportProtocolIEs_EntryValue::Id_UEPresenceInAreaOfInterestList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(LocationReportProtocolIEs_EntryValue::Id_LocationReportingRequestType(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UETNLABindingReleaseRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UETNLABindingReleaseRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UETNLABindingReleaseRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UETNLABindingReleaseRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UETNLABindingReleaseRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UETNLABindingReleaseRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UETNLABindingReleaseRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UETNLABindingReleaseRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UERadioCapabilityInfoIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityInfoIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityInfoIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapability(source.get_entropic()?);
            ie_list.push(UERadioCapabilityInfoIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(source.get_entropic()?);
            ie_list.push(UERadioCapabilityInfoIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapability_EUTRA_Format(source.get_entropic()?);
            ie_list.push(UERadioCapabilityInfoIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UERadioCapabilityInfoIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UERadioCapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapability_EUTRA_Format(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UERadioCapabilityCheckRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_UERadioCapability(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UERadioCapabilityCheckRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_UERadioCapability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(UERadioCapabilityCheckRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UERadioCapabilityCheckResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_IMSVoiceSupportIndicator(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UERadioCapabilityCheckResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UERadioCapabilityCheckResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_IMSVoiceSupportIndicator(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityCheckResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for SecondaryRATDataUsageReportProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(SecondaryRATDataUsageReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(SecondaryRATDataUsageReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_PDUSessionResourceSecondaryRATUsageList(source.get_entropic()?);
            ie_list.push(SecondaryRATDataUsageReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_HandoverFlag(source.get_entropic()?);
            ie_list.push(SecondaryRATDataUsageReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_UserLocationInformation(source.get_entropic()?);
            ie_list.push(SecondaryRATDataUsageReportProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(SecondaryRATDataUsageReportProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_PDUSessionResourceSecondaryRATUsageList(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_HandoverFlag(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_UserLocationInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UplinkRIMInformationTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UplinkRIMInformationTransferProtocolIEs_EntryValue::Id_RIMInformationTransfer(source.get_entropic()?);
            ie_list.push(UplinkRIMInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UplinkRIMInformationTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UplinkRIMInformationTransferProtocolIEs_EntryValue::Id_RIMInformationTransfer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for DownlinkRIMInformationTransferProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = DownlinkRIMInformationTransferProtocolIEs_EntryValue::Id_RIMInformationTransfer(source.get_entropic()?);
            ie_list.push(DownlinkRIMInformationTransferProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(DownlinkRIMInformationTransferProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(DownlinkRIMInformationTransferProtocolIEs_EntryValue::Id_RIMInformationTransfer(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for ConnectionEstablishmentIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UERadioCapability(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_EndIndication(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_S_NSSAI(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_DL_CP_SecurityInformation(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_NB_IoT_UEPriority(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_CEmodeBrestricted(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(ConnectionEstablishmentIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(ConnectionEstablishmentIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UERadioCapability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_EndIndication(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_S_NSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UE_DifferentiationInfo(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_DL_CP_SecurityInformation(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_NB_IoT_UEPriority(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_Enhanced_CoverageRestriction(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_CEmodeBrestricted(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UERadioCapabilityIDMappingRequestProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        
        Ok(UERadioCapabilityIDMappingRequestProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for UERadioCapabilityIDMappingResponseProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_UERadioCapabilityID(source.get_entropic()?);
            ie_list.push(UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_UERadioCapability(source.get_entropic()?);
            ie_list.push(UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(source.get_entropic()?);
            ie_list.push(UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(UERadioCapabilityIDMappingResponseProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_UERadioCapabilityID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_UERadioCapability(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    
impl entropic::Entropic for AMFCPRelocationIndicationProtocolIEs {
    #[inline]
    fn from_entropy_source<'a, I: Iterator<Item = &'a u8>, E: EntropyScheme>(
        source: &mut Source<'a, I, E>,
    ) -> Result<Self, Error> {
        let mut ie_list = Vec::new();

        // Loop this part for every enum discriminant

        
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(AMFCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0111_1111) != 0b_0111_1111 { // 1/128 chance of missing
            let ie_value = AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(source.get_entropic()?);
            ie_list.push(AMFCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::REJECT),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_S_NSSAI(source.get_entropic()?);
            ie_list.push(AMFCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        let b = source.get_byte()?;
        if (b & 0b_0000_1111) == 0b_0000_1111 { // 1/16 chance of being present
            let ie_value = AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_AllowedNSSAI(source.get_entropic()?);
            ie_list.push(AMFCPRelocationIndicationProtocolIEs_Entry {
                id: ProtocolIE_ID(ie_value.choice_key()),
                criticality: Criticality(Criticality::IGNORE),
                value: ie_value,
            });
        }
                
        
        Ok(AMFCPRelocationIndicationProtocolIEs(ie_list))
    }

    #[inline]
    fn to_entropy_sink<'a, I: Iterator<Item = &'a mut u8>, E: EntropyScheme>(
        &self,
        sink: &mut Sink<'a, I, E>,
    ) -> Result<usize, Error> {
        let mut ie_idx = 0;
        let mut length = 0;

        
        if let Some(AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_AMF_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_RAN_UE_NGAP_ID(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_0000)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0111_1111)?;
        };
                
        if let Some(AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_S_NSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                
        if let Some(AMFCPRelocationIndicationProtocolIEs_EntryValue::Id_AllowedNSSAI(value)) = self.0.get(ie_idx).map(|ie| &ie.value) {
            ie_idx += 1;
            length += sink.put_byte(0b_0000_1111)?;
            length += sink.put_entropic(value)?;
        } else {
            length += sink.put_byte(0b_0000_0000)?;
        };
                

        if ie_idx != self.0.len() {
            return Err(entropic::Error::Internal)
        }

        Ok(length)
    }
}
    